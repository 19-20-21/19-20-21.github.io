{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u76ee\u5f55 \u00b6 \u539f\u6587\u8bf7\u9605\u8bfb learncpp.com \u7b2c\u4e00\u7ae0 \u4ecb\u7ecd ... \u7b2c\u5341\u4e8c\u7ae0 \u865a\u51fd\u6570 \u7b2c\u5341\u4e09\u7ae0 \u6a21\u677f \u7b2c\u5341\u56db\u7ae0 \u5f02\u5e38","title":"\u76ee\u5f55"},{"location":"#_1","text":"\u539f\u6587\u8bf7\u9605\u8bfb learncpp.com \u7b2c\u4e00\u7ae0 \u4ecb\u7ecd ... \u7b2c\u5341\u4e8c\u7ae0 \u865a\u51fd\u6570 \u7b2c\u5341\u4e09\u7ae0 \u6a21\u677f \u7b2c\u5341\u56db\u7ae0 \u5f02\u5e38","title":"\u76ee\u5f55"},{"location":"0-Introduction-getting-started/","text":"\u7b2c\u96f6\u7ae0 \u4ecb\u7ecd/\u8d77\u6b65 \u00b6 0.1-\u6559\u7a0b\u4ecb\u7ecd (Introduction to these tutorials)","title":"\u7b2c\u96f6\u7ae0 \u4ecb\u7ecd/\u8d77\u6b65"},{"location":"0-Introduction-getting-started/#_1","text":"0.1-\u6559\u7a0b\u4ecb\u7ecd (Introduction to these tutorials)","title":"\u7b2c\u96f6\u7ae0 \u4ecb\u7ecd/\u8d77\u6b65"},{"location":"0-Introduction-getting-started/0.1-Introduction-to-these-tutorials/","text":"0.1 \u6559\u7a0b\u4ecb\u7ecd \u00b6 Welcome\uff01 \u00b6 \u6b22\u8fce\u6765\u5230\u4e50\u5b66C++\u6559\u7a0b\uff01\u8fd9\u4e00\u7cfb\u5217\u6559\u7a0b\u65e8\u5728\u8ba9\u4f60\u66f4\u8f7b\u677e\u5feb\u4e50\u7684\u5b66\u4f1aC++\u3002 \u548c\u5176\u4ed6\u5927\u591a\u6570\u7f51\u7ad9\u548c\u4e66\u7c4d\u4e0d\u4e00\u6837\uff0c\u5373\u4f7f\u6ca1\u6709\u7f16\u7a0b\u7ecf\u9a8c\u7684\u4eba\u4e5f\u80fd\u653e\u5fc3\u98df\u7528\u672c\u6559\u7a0b\u3002\u5728\u8fd9\u4e2a\u8fc7\u7a0b\u4e2d\u6211\u4eec\u4f1a\u901a\u8fc7\u7ed9\u4f60\u5927\u91cf\u7684\u793a\u4f8b\u4ee3\u7801\uff0c\u8ba9\u4f60\u5728\u7f16\u7a0b\u7684\u5b9e\u8df5\u4e2d\u5b66\u4f1aC++\u3002 \u65e0\u8bba\u4f60\u662fC++\u7684\u4e1a\u4f59\u7231\u597d\u8005\u8fd8\u662f\u9760\u5199C++\u5403\u996d\u7684\u5f00\u53d1\u8005\uff0c\u4e0e\u672c\u6559\u7a0b\u7684\u5076\u7136\u9082\u9005\uff0c\u5c06\u4e3a\u4f60\u6307\u5f15C++\u7f16\u7a0b\u7684\u5766\u9014\u3002 \u6559\u7a0b\u7684\u7ed3\u6784 \u00b6 \u5e8f\u7ae0\u7684\u6559\u7a0b\u8ba9\u4f60\u5927\u4f53\u4e0a\u4e86\u89e3C++\u662f\u4ec0\u4e48\uff0c\u5b83\u662f\u600e\u6837\u6a2a\u7a7a\u51fa\u4e16\uff0c\u4e00\u4e2aC++\u7a0b\u5e8f\u662f\u600e\u4e48\u8dd1\u8d77\u6765\u7684\uff0c\u4ee5\u53ca\u2014\u2014\u5728\u4f60\u5f00\u59cb\u52a8\u624b\u7f16\u7a0b\u524d\u9700\u8981\u5b89\u88c5\u7684\u5de5\u5177\u3002\u7136\u540e\uff0c\u6211\u4eec\u4f1a\u6559\u4f1a\u4f60\u521b\u9020\u51fa\u4f60\u7684\u7b2c\u4e00\u4e2a\u7a0b\u5e8f\u3002 \u4e4b\u540e\u7684\u6559\u7a0b\u91cc\uff0c\u6211\u4eec\u4f1a\u4e00\u8d77\u63a2\u7d22C++\u8bed\u8a00\u7684\u5404\u4e2a\u90e8\u5206\u3002\u5728\u7b2c\u4e00\u7ae0\uff0c\u4f60\u4f1a\u5bf9C++\u8bed\u8a00\u7684\u5927\u591a\u6570\u91cd\u8981\u6982\u5ff5\u6709\u5168\u800c\u6d45\u7684\u8ba4\u8bc6\uff0c\u7531\u6b64\u4f60\u5f00\u59cb\u6709\u80fd\u529b\u7f16\u5199\u4e00\u4e9b\u7b80\u5355\u7684\u5c0f\u7a0b\u5e8f\u3002\u4e4b\u540e\u7684\u7ae0\u8282\u91cc\u6211\u4eec\u4f1a\u66f4\u6df1\u5165\u7684\u63a2\u8ba8\u8fd9\u4e9b\u6982\u5ff5\uff0c\u4ee5\u53ca\u2014\u2014\u4ecb\u7ecd\u4e00\u4e9b\u5168\u65b0\u7684\u6982\u5ff5\u3002 \u672c\u6559\u7a0b\u7684\u6bcf\u4e00\u4e2a\u7ae0\u8282\u90fd\u6709\u4e00\u4e2a\u4e3b\u9898\uff0c\u7ae0\u8282\u7684\u5185\u5bb9\u5927\u4f53\u4e0a\u56f4\u7ed5\u7740\u8fd9\u4e2a\u4e3b\u9898\u5c55\u5f00\u3002\u6bcf\u4e00\u7ae0\u6ca1\u6709\u56fa\u5b9a\u7684\u5efa\u8bae\u9605\u8bfb\u65f6\u95f4\uff0c\u4ee5\u4f60\u6700\u8212\u9002\u7684\u901f\u5ea6\u524d\u8fdb\u5427\uff01 \u6559\u7a0b\u7684\u76ee\u6807 \u00b6 \u5728\u5f00\u59cb\u4e4b\u524d\uff0c\u8ba9\u6211\u4eec\u6765\u770b\u770b\u672c\u6559\u7a0b\u7684\u51e0\u4e2a\u91cd\u8981\u76ee\u6807\uff1a \u6db5\u76d6C++\u76f8\u5173\u7684\u5185\u5bb9\u3002 \u4f20\u7edf\u7684\u7f16\u7a0b\u6559\u6750\u5c3d\u7ba1\u5728\u8bb2\u89e3\u7f16\u7a0b\u8bed\u8a00\u8bed\u6cd5\u57fa\u7840\u4e0a\u505a\u7684\u5f88\u8be6\u7ec6\uff0c\u4f46\u4ed6\u4eec\u5f80\u5f80\u5ffd\u89c6\u4e86\u4e00\u4e9b\u8bed\u8a00\u76f8\u5173\u7684\u9644\u52a0\u5185\u5bb9\u3002\u6bd4\u65b9\u8bf4\uff0c\u8fd9\u4e9b\u4e66\u7c4d\u5f80\u5f80\u4f1a\u5728\u7f16\u7801\u98ce\u683c\u3001\u5e38\u89c1\u8bef\u533a\u3001\u8c03\u8bd5\u3001\u7f16\u7a0b\u4e60\u60ef\u7684\u597d\u574f\u3001\u4ee5\u53ca\u4ee3\u7801\u6d4b\u8bd5\u4e0a\u8282\u7701\u7b14\u58a8\u3002\u90a3\u540e\u679c\u5c31\u662f\uff0c\u5f53\u4f60\u8bfb\u5b8c\u8fd9\u4e9b\u4e66\u65f6\uff0c\u4f60\u5927\u4f53\u4e0a\u77e5\u9053\u600e\u4e48\u7528\u8fd9\u95e8\u8bed\u8a00\u8fdb\u884c\u7f16\u7a0b\uff0c\u4f46\u4f60\u53ef\u80fd\u5728\u7f16\u7801\u4e60\u60ef\u548c\u7f16\u7a0b\u98ce\u683c\u4e0a\u4e00\u584c\u7cca\u6d82\uff0c\u8fd9\u4e9b\u4e60\u60ef\u5f80\u5f80\u4f1a\u5728\u672a\u6765\u6210\u4e3a\u4f60\u7f16\u7a0b\u4e4b\u8def\u7684\u7eca\u811a\u77f3\u3002\u672c\u6559\u7a0b\u5c06\u4f1a\u5728\u6bcf\u7ae0\u8282\u6070\u5f53\u7684\u5730\u65b9\u8ba8\u8bba\u8fd9\u4e9b\u9644\u52a0\u7684\u5185\u5bb9\uff0c\u786e\u4fdd\u8bfb\u8005\u5728\u9605\u8bfb\u8fc7\u7a0b\u4e2d\u4e0d\u65ad\u53d7\u5176\u718f\u67d3\uff0c\u6df1\u5165\u4eba\u5fc3\u3002\u5f53\u4f60\u5408\u4e0a\u672c\u6559\u7a0b\u7684\u5c01\u5e95\u65f6\uff0c\u4f60\u4e0d\u4ec5\u4ec5\u5b66\u4f1a\u4e86\u600e\u6837\u7528C++\u7f16\u7a0b\uff0c\u8fd8\u5c06\u77e5\u9053\u4ec0\u4e48\u573a\u666f\u4e0b\u4e0d\u5e94\u4f7f\u7528C++\u7f16\u7a0b\uff0c\u8fd9\u4e24\u8005\u540c\u7b49\u91cd\u8981\uff0c\u4e0d\u53ef\u504f\u5e9f\u3002 \u6d77\u91cf\u4e30\u5bcc\u7684\u4f8b\u5b50\u3002 \u901a\u8fc7\u9605\u8bfb\u5b9e\u4f8b\u4ee3\u7801\uff0c\u5927\u591a\u6570\u4eba\u6216\u591a\u6216\u5c11\u5730\u80fd\u591f\u6709\u6548\u5730\u5b66\u5230\u77e5\u8bc6\u3002\u672c\u6559\u7a0b\u81f4\u529b\u4e8e\u63d0\u4f9b\u5927\u91cf\u6e05\u6670\u7b80\u6d01\u7684\u793a\u4f8b\uff0c\u901a\u8fc7\u793a\u4f8b\u6765\u5b66\u4ee5\u81f4\u7528\u3002\u540c\u65f6\u6211\u4eec\u4e5f\u4f1a\u5c3d\u53ef\u80fd\u907f\u514d\u4e24\u5927\u53d9\u8ff0\u65f6\u7684\u201c\u6076\u9b54\u201d\uff1a\uff0c\u6bd4\u65b9\u8bf4\uff0c the magic hand wave \uff08\u4e5f\u79f0\u4e3a\u2026\u2026<\u6b64\u5904\u7701\u7565\u4e00\u4e07\u5b57>\uff09 \uff0c\u8bf8\u5982\u6b64\u7c7b\u4e3a\u4e86\u8282\u7701\u7a7a\u95f4\uff0c\u628a\u793a\u4f8b\u7684\u4e00\u90e8\u5206\u7ed9\u7701\u6389\u7684\u884c\u4e3a\uff0c\u4ee5\u53ca\uff0c\u5728\u793a\u4f8b\u4e2d\u5f15\u5165\u4e86\u4e00\u4e9b\u65b0\u6982\u5ff5\uff0c\u5374\u4e0d\u5bf9\u8fd9\u4e9b\u6982\u5ff5\u8fdb\u884c\u89e3\u91ca\u8bf4\u660e\u7684\u884c\u5f84\u3002\u6211\u4eec\u4f1a\u5c3d\u91cf\u907f\u514d\u8fd9\u79cd\u5bb9\u6613\u8ba9\u8bfb\u8005\u5728\u9605\u8bfb\u4e2d\u5361\u4f4f\u7684\u53d9\u8ff0\u65b9\u5f0f\u3002 \u5927\u91cf\u7528\u4e8e\u7ec3\u4e60\u7684\u7a0b\u5e8f \u672c\u6559\u7a0b\u6bcf\u7ae0\u8282\u7684\u7ed3\u5c3e\u4f1a\u6db5\u76d6\u4e00\u90e8\u5206\u5e26\u7b54\u6848\u7684\u7ec3\u4e60\u9898\uff0c\u8bfb\u8005\u53ef\u4ee5\u5c1d\u8bd5\u81ea\u5df1\u8fdb\u884c\u7ec3\u4e60\uff0c\u5e76\u628a\u4f60\u7684\u7b54\u6848\u548c\u6211\u4eec\u63d0\u4f9b\u7684\u7b54\u6848\u8fdb\u884c\u5bf9\u6bd4\u601d\u8003\uff0c\u6216\u8005\u8bf4\u5f53\u4f60\u5361\u5728\u67d0\u9053\u9898\u7684\u65f6\u5019\u770b\u4e00\u770b\u6211\u4eec\u63d0\u4f9b\u7684\u601d\u8def\u3002\u63a5\u7740\uff0c\u4f60\u53ef\u4ee5\u56de\u5230\u4f60\u9700\u8981\u505a\u66f4\u591a\u529f\u8bfe\u7684\u5730\u65b9\u8fdb\u884c\u5b66\u4e60\u3002 \u6700\u91cd\u8981\u7684\u4e8b\uff1a\u73a9\u5f97\u5f00\u5fc3\u3002\u7f16\u7a0b\u672c\u8eab\u662f\u4e00\u4ef6\u5145\u6ee1\u4e50\u8da3\u7684\u4e8b\u60c5\uff0c\u5982\u679c\u4f60\u5728\u8fd9\u4e2a\u8fc7\u7a0b\u4e2d\u65e0\u6bd4\u75db\u82e6\uff0c\u8bf4\u660e\u4f60\u8fd8\u6ca1\u6709\u771f\u6b63\u6478\u5230\u6b64\u4e2d\u7684\u95e8\u9053\u3002\u75b2\u60eb\u3001\u751a\u81f3\u95f7\u95f7\u4e0d\u4e50\u7684\u7a0b\u5e8f\u5458\u5f80\u5f80\u4f1a\u8c2c\u8bef\u4e0d\u65ad\uff0c\u5e76\u4e14\u4e0e\u5176\u8c03\u8bd5\u7a0b\u5e8f\u82b1\u8d39\u5927\u91cf\u7684\u65f6\u95f4\uff0c\u4e0d\u5982\u4e00\u5f00\u59cb\u6211\u4eec\u5c31\u5199\u51fa\u63a5\u8fd1\u5b8c\u7f8e\u7684\u4ee3\u7801\u3002\u53e6\u5916\uff0c\u4e0d\u8981\u8fc7\u52b3\u7f16\u7a0b\uff0c\u5c0f\u61a9\u7247\u523b\u6216\u8005\u9163\u7761\u81f3\u4e1c\u65b9\u53d1\u767d\uff0c\u89e3\u51b3\u95ee\u9898\u7684\u65b9\u6cd5\u5c06\u5728\u6668\u5149\u71b9\u5fae\u65f6\u95ea\u73b0\u5728\u4f60\u7684\u8111\u6d77\u91cc\u3002 \u5145\u5206\u5229\u7528\u672c\u6559\u7a0b \u00b6 \u5728\u4f60\u5b66\u4e60\u672c\u6559\u7a0b\u7684\u8fc7\u7a0b\u4e2d\uff0c\u6211\u4eec\u6709\u4e00\u4e9b\u5c0f\u5c0f\u7684\u5efa\u8bae\u4e5f\u8bb8\u53ef\u4ee5\u8ba9\u4f60\u5b66\u4e60\u7684\u6536\u76ca\u6700\u5927\u5316\uff1a \u4eb2\u81ea\u628a\u793a\u4f8b\u7684\u4ee3\u7801\u624b\u6253\u4e00\u904d\u5e76\u4e14\u7f16\u8bd1\u8fd0\u884c\uff0c\u4e0d\u8981\u590d\u5236\u7c98\u8d34\uff01\u8fd9\u4f1a\u5e2e\u52a9\u4f60\u77e5\u9053\u54ea\u4e9b\u5730\u65b9\u4f60\u5bb9\u6613\u51fa\u9519\uff0c\u5e76\u4e14\u8ba9\u4f60\u5bf9\u5e38\u89c1\u7684\u7f16\u8bd1\u8b66\u544a\u548c\u9519\u8bef\u719f\u6089\u3002\u4e0d\u8981\u65e0\u8111\u7684copy\u4ee3\u7801\uff0c\u5f53\u4f60\u624b\u6253\u6bcf\u4e00\u884c\u4ee3\u7801\u65f6\uff0c\u4f60\u90fd\u8981\u601d\u8003\u5b83\u4eec\u505a\u4e86\u4ec0\u4e48\uff0c\u5b9e\u73b0\u4e86\u7a0b\u5e8f\u7684\u54ea\u4e9b\u529f\u80fd\u3002\u5f53\u4f60\u9047\u5230\u4e00\u4e9b\u4e0d\u80fd\u7406\u89e3\u6216\u8005\u4f60\u8ba4\u4e3a\u4e0d\u5408\u7406\u7684\u4e1c\u897f\u65f6\uff0c\u8fd9\u65f6\u5019\u5c31\u9700\u8981\u4f60\u8fdb\u4e00\u6b65\u67e5\u9605\u8d44\u6599\uff0c\u6df1\u5165\u8c03\u7814\u3002 \u5728\u7f16\u7a0b\u7684\u65f6\u5019\uff0c\u4f60\u53ef\u80fd\u4f1a\u72af\u4e0b\u8c2c\u8bef\u6216\u8005\u4ea7\u751fbug\u3002\u5728\u5bfb\u6c42\u5927\u4f6c\u5e2e\u52a9\u524d\uff0c\u5c3d\u91cf\u5c1d\u8bd5\u81ea\u5df1\u53bb\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\u3002bug\u7684\u67e5\u627e\u4ee5\u53ca\u4fee\u590d\u4e5f\u662f\u4e00\u4e2a\u597d\u7684\u7a0b\u5e8f\u5458\u7684\u5173\u952e\u6280\u80fd\u3002\u522b\u5fd8\u4e86\u5b66\u4e60\u4f7f\u7528\u8c03\u8bd5\u5668\uff08\u6211\u4eec\u4f1a\u5728\u4e4b\u540e\u7684\u8bfe\u7a0b\u4e2d\u8bb2\u89e3\u4f7f\u7528\u65b9\u6cd5\uff09\u2014\u2014\u4e00\u79cd\u80fd\u5e2e\u4f60\u627e\u5230bug\u4f4d\u7f6e\u7684\u5173\u952e\u5de5\u5177\u3002 \u5bf9\u793a\u4f8b\u4ee3\u7801\u8fdb\u884c\u8fdb\u4e00\u6b65\u7684\u5b9e\u9a8c\u3002\u5c1d\u8bd5\u4fee\u6539\u793a\u4f8b\u4e2d\u7684\u6570\u636e\u548c\u6587\u672c\u770b\u770b\u4f1a\u53d1\u751f\u4ec0\u4e48\uff0c\u4fee\u6539\u4ee3\u7801\u7684\u903b\u8f91\u4ee5\u8fdb\u4e00\u6b65\u5b9e\u73b0\u65b0\u7684\u529f\u80fd\uff08\u6bd4\u5982\u8bf4\uff0c\u539f\u6765\u7a0b\u5e8f\u662f\u8ba1\u7b97\u4e24\u6570\u548c\uff0c\u6211\u4eec\u8ba9\u4ed6\u53ef\u4ee5\u8ba1\u7b97\u4e09\u4e2a\u6570\u7684\u548c\uff09\u3002\u60f3\u4e0d\u540c\u7684\u529e\u6cd5\u8ba9\u7a0b\u5e8f\u7ec8\u6b62\u8fd0\u884c\uff08\u5982\u679c\u7a0b\u5e8f\u8981\u6c42\u7528\u6237\u8f93\u5165\uff0c\u6211\u4eec\u53ef\u4ee5\u5c1d\u8bd5\u5404\u79cd\u8f93\u5165\uff09\u3002\u901a\u8fc7\u4fee\u6539\u793a\u4f8b\u7a0b\u5e8f\u8fdb\u884c\u5b9e\u9a8c\uff0c\u4f60\u4f1a\u6bd4\u4ec5\u4ec5\u53ea\u4f7f\u7528\u5b9e\u4f8b\u7a0b\u5e8f\u5b66\u5230\u66f4\u591a\u4e1c\u897f\u3002 \u82b1\u70b9\u65f6\u95f4\u5b8c\u6210\u5c0f\u6d4b\u9a8c\u3002\u5982\u679c\u4f60\u662f\u7f16\u7a0b\u83dc\u9e21\uff0c\u4f60\u53ef\u80fd\u4f1a\u89c9\u5f97\u4ed6\u4eec\u6709\u70b9\u96be\u5ea6\uff08\u8fd9\u5f88\u6b63\u5e38\uff0c\u56e0\u4e3a\u4f60\u7684\u5927\u8111\u5728\u4e0d\u65ad\u9002\u5e94\u7f16\u7a0b\u7684\u601d\u7ef4\uff09\u3002\u5982\u679c\u4e00\u6b21\u6ca1\u6709\u505a\u5bf9\u4e5f\u4e0d\u8981\u6cae\u4e27\uff0c\u518d\u8bd5\u51e0\u6b21\u4f60\u6ca1\u51c6\u5c31\u4f1a\u6210\u529f\u3002\u5982\u679c\u4f60\u786e\u5b9e\u5361\u4f4f\u4e86\uff0c\u770b\u770b\u7b54\u6848\u4e5f\u662f\u65e0\u6240\u8c13\u7684\u3002\u53ea\u8981\u786e\u4fdd\u4f60\u7406\u89e3\u4e86\u7b54\u6848\u7684\u5185\u5bb9\u548c\u539f\u7406\u3002 \u7528\u4f60\u5b66\u5230\u7684\u6982\u5ff5\u5199\u4f60\u81ea\u5df1\u7684\u5c0f\u7a0b\u5e8f\u3002\u7eb8\u4e0a\u5f97\u6765\u7ec8\u89c9\u6d45\uff0c\u7edd\u77e5\u6b64\u4e8b\u8981\u8eac\u884c\u3002 \u7f51\u7ad9\u76f8\u5173\uff08\u6307 learncpp.com \uff09 \u00b6 \u95ee\uff1a\u7f51\u7ad9\u600e\u4e48\u6ce8\u518c\uff1f\u600e\u6837\u624d\u80fd\u767b\u5f55\uff1f \u7b54 \uff1a\u672c\u7ad9\u7684\u6240\u6709\u5185\u5bb9\u90fd\u80fd\u514d\u767b\u5f55\u6d4f\u89c8\u2014\u2014\u6240\u4ee5\uff0c\u65e0\u9700\u6ce8\u518c\uff01 \u95ee\uff1a\u8fd9\u4e9b\u6559\u7a0b\u6700\u65e92007\u5e74\u7f16\u5199\u7684\uff0c\u73b0\u5728\u8fd8\u80fd\u7528\u5417\uff1f \u7b54 \uff1a\u5f53\u7136\uff0c\u80af\u5b9a\u53ef\u4ee5\u7528\u3002 C++\u7684\u6807\u51c6\u4fee\u8ba2\u5e76\u975e\u7279\u522b\u9891\u7e41\uff0c\u5373\u4f7f\u6709\u53d8\u5316\uff0c\u4e5f\u662f\u5728\u539f\u6765\u7684\u57fa\u7840\u4e0a\u589e\u52a0\u65b0\u7684\u7279\u6027\u3002\u5f53\u7136\uff0c\u672c\u6559\u7a0b\u4e5f\u4f1a\u968f\u7740\u8bed\u8a00\u6807\u51c6\u53d8\u5316\u548c\u8bfb\u8005\u53cd\u9988\u5b9a\u671f\u66f4\u65b0\u3002 \u95ee\uff1a\u672c\u7f51\u7ad9\u7684\u6559\u7a0b\u6709pdf\u7248\u672c\u4f9b\u79bb\u7ebf\u9605\u8bfb\u5417\uff1f \u7b54\uff1a\u62b1\u6b49\uff0c\u8fd9\u4e2a\u6ca1\u6709\u3002\u672c\u7f51\u7ad9\u514d\u8d39\u5f00\u53d1\u7684\u539f\u56e0\u662f\u56e0\u4e3a\u53d7\u5e7f\u544a\u5546\u8d5e\u52a9\u2014\u2014\u800cpdf\u7248\u672c\u65e0\u6cd5\u6295\u5165\u5e7f\u544a\u3002\u5f53\u7136\uff0c\u4f60\u4e5f\u53ef\u4ee5\u628a\u672c\u7ad9\u4e0a\u7684\u7f51\u9875\u8f6c\u6362\u4e3apdf\u505a\u79c1\u4eba\u7528\u9014\uff0c\u53ea\u8981\u4e0d\u628apdf\u7248\u672c\u4f20\u64ad\u51fa\u53bb\u5c31ok\u4e86\u3002 \u95ee\uff1a\u5982\u679c\u6211\u5361\u5728\u67d0\u4e2a\u6982\u5ff5\u4e86\u600e\u4e48\u529e\uff1f \u7b54\uff1a\u5982\u679c\u4f60\u5bf9\u67d0\u4e00\u90e8\u5206\u4e0d\u592a\u660e\u767d\uff0c\u4f60\u53ef\u4ee5\uff1a \u9605\u8bfb\u8bc4\u8bba\u3002\u5176\u4ed6\u7684\u8bfb\u8005\u53ef\u80fd\u4e5f\u9047\u5230\u4e86\u76f8\u4f3c\u7684\u95ee\u9898\u3002 \u7c97\u8bfb\u4e0b\u4e00\u7ae0\u7684\u6559\u7a0b\u2014\u2014\u8bf4\u4e0d\u5b9a\u4f60\u7684\u7591\u60d1\u4f1a\u5728\u90a3\u91cc\u5f97\u5230\u89e3\u7b54\u3002 \u5584\u7528\u641c\u7d22\u5f15\u64ce\u67e5\u627e\u4f60\u7684\u95ee\u9898\u3002 \u5728\u7c7b\u4f3c StackOverflow \u7684\u95ee\u7b54\u7f51\u7ad9\u4e0a\u63d0\u95ee\u3002 \u5982\u679c\u90fd\u6ca1\u7528\u7684\u8bdd\uff0c\u6682\u65f6\u8df3\u8fc7\u8fd9\u4e00\u90e8\u5206\u4e0d\u61c2\u7684\u5185\u5bb9\uff0c\u4ee5\u5f85\u5c06\u6765\u7ffb\u770b\u3002\u5230\u90a3\u65f6\u4f60\u53ef\u80fd\u4f1a\u53d1\u73b0\uff0c\u5728\u5b66\u4e60\u4e86\u5176\u4ed6\u7ae0\u7684\u77e5\u8bc6\u548c\u6587\u7ae0\u4ee5\u540e\uff0c\u518d\u56de\u5934\u6765\u770b\uff0c\u66fe\u7ecf\u8270\u6da9\u96be\u61c2\u7684\u4e1c\u897f\u4e00\u4e0b\u5b50\u8305\u585e\u987f\u5f00\u3002 \u95ee\uff1a\u5982\u679c\u6211\u9057\u5fd8\u4e86\u67d0\u4e2a\u6982\u5ff5\u600e\u4e48\u529e\uff1f \u7b54\uff1a\u5584\u7528 \u4e3b\u9875\u7d22\u5f15 ,\u67e5\u627e\u4f60\u9700\u8981\u4e86\u89e3\u7684\u6982\u5ff5\uff0c\u4f60\u4f1a\u627e\u5230\u8bb2\u89e3\u76f8\u5173\u77e5\u8bc6\u7684\u7ae0\u8282\u3002 \u95ee\uff1a\u600e\u4e48\u80fd\u5728\u8bc4\u8bba\u533a\u5e26\u5934\u50cf\u8bc4\u8bba\uff1f \u8bc4\u8bba\u533a\u4f7f\u7528\u4e86gravatars\u3002\u4f60\u53ef\u4ee5\u5728 gravatar.com \u521b\u5efa\u4e00\u4e2a\u8d26\u6237\u3002\u70b9\u51fb\u201cCreate your own gravatar\u201d\u6309\u94ae\u5e76\u6ce8\u518c\u3002\u4f60\u7684gravatar\u8d26\u6237\u5c06\u4e0e\u4f60\u7684\u90ae\u7bb1\uff08\u53ef\u9009\uff09\u5173\u8054\u3002 \u95ee\uff1a\u672c\u7f51\u7ad9\u6709\u9ed1\u591c\u6a21\u5f0f\u5417\uff1f \u7b54\uff1a\u6ca1\u6709\u81ea\u5e26\u7684\u3002\u4f46\u4f60\u80fd\u624b\u52a8\u641e\u4e00\u641e\uff0c\u8be6\u89c1 darkreader.org \u6700\u540e\uff0c\u4e00\u4e2a\u5c0f\u5c0f\u7684\u4e0d\u60c5\u4e4b\u8bf7\uff1a\u672c\u7f51\u7ad9\u56e0\u5e7f\u544a\u5546\u8d5e\u52a9\u800c\u5f97\u4ee5\u514d\u8d39\u3002\u5982\u679c\u4f60\u559c\u6b22\u672c\u7f51\u7ad9\u7684\u8bfe\u7a0b\uff0c\u53ef\u8003\u8651\u5173\u95ed\u5e7f\u544a\u62e6\u622a\u5668\u6765\u652f\u6301\u6211\u4eec\u3002 \u597d\u7684\uff0c\u4e00\u5207\u5c31\u7eea\uff0c\u8ba9\u6211\u4eec\u5f00\u59cb\u5427\uff01","title":"0.1 \u6559\u7a0b\u4ecb\u7ecd"},{"location":"0-Introduction-getting-started/0.1-Introduction-to-these-tutorials/#01","text":"","title":"0.1 \u6559\u7a0b\u4ecb\u7ecd"},{"location":"0-Introduction-getting-started/0.1-Introduction-to-these-tutorials/#welcome","text":"\u6b22\u8fce\u6765\u5230\u4e50\u5b66C++\u6559\u7a0b\uff01\u8fd9\u4e00\u7cfb\u5217\u6559\u7a0b\u65e8\u5728\u8ba9\u4f60\u66f4\u8f7b\u677e\u5feb\u4e50\u7684\u5b66\u4f1aC++\u3002 \u548c\u5176\u4ed6\u5927\u591a\u6570\u7f51\u7ad9\u548c\u4e66\u7c4d\u4e0d\u4e00\u6837\uff0c\u5373\u4f7f\u6ca1\u6709\u7f16\u7a0b\u7ecf\u9a8c\u7684\u4eba\u4e5f\u80fd\u653e\u5fc3\u98df\u7528\u672c\u6559\u7a0b\u3002\u5728\u8fd9\u4e2a\u8fc7\u7a0b\u4e2d\u6211\u4eec\u4f1a\u901a\u8fc7\u7ed9\u4f60\u5927\u91cf\u7684\u793a\u4f8b\u4ee3\u7801\uff0c\u8ba9\u4f60\u5728\u7f16\u7a0b\u7684\u5b9e\u8df5\u4e2d\u5b66\u4f1aC++\u3002 \u65e0\u8bba\u4f60\u662fC++\u7684\u4e1a\u4f59\u7231\u597d\u8005\u8fd8\u662f\u9760\u5199C++\u5403\u996d\u7684\u5f00\u53d1\u8005\uff0c\u4e0e\u672c\u6559\u7a0b\u7684\u5076\u7136\u9082\u9005\uff0c\u5c06\u4e3a\u4f60\u6307\u5f15C++\u7f16\u7a0b\u7684\u5766\u9014\u3002","title":"Welcome\uff01"},{"location":"0-Introduction-getting-started/0.1-Introduction-to-these-tutorials/#_1","text":"\u5e8f\u7ae0\u7684\u6559\u7a0b\u8ba9\u4f60\u5927\u4f53\u4e0a\u4e86\u89e3C++\u662f\u4ec0\u4e48\uff0c\u5b83\u662f\u600e\u6837\u6a2a\u7a7a\u51fa\u4e16\uff0c\u4e00\u4e2aC++\u7a0b\u5e8f\u662f\u600e\u4e48\u8dd1\u8d77\u6765\u7684\uff0c\u4ee5\u53ca\u2014\u2014\u5728\u4f60\u5f00\u59cb\u52a8\u624b\u7f16\u7a0b\u524d\u9700\u8981\u5b89\u88c5\u7684\u5de5\u5177\u3002\u7136\u540e\uff0c\u6211\u4eec\u4f1a\u6559\u4f1a\u4f60\u521b\u9020\u51fa\u4f60\u7684\u7b2c\u4e00\u4e2a\u7a0b\u5e8f\u3002 \u4e4b\u540e\u7684\u6559\u7a0b\u91cc\uff0c\u6211\u4eec\u4f1a\u4e00\u8d77\u63a2\u7d22C++\u8bed\u8a00\u7684\u5404\u4e2a\u90e8\u5206\u3002\u5728\u7b2c\u4e00\u7ae0\uff0c\u4f60\u4f1a\u5bf9C++\u8bed\u8a00\u7684\u5927\u591a\u6570\u91cd\u8981\u6982\u5ff5\u6709\u5168\u800c\u6d45\u7684\u8ba4\u8bc6\uff0c\u7531\u6b64\u4f60\u5f00\u59cb\u6709\u80fd\u529b\u7f16\u5199\u4e00\u4e9b\u7b80\u5355\u7684\u5c0f\u7a0b\u5e8f\u3002\u4e4b\u540e\u7684\u7ae0\u8282\u91cc\u6211\u4eec\u4f1a\u66f4\u6df1\u5165\u7684\u63a2\u8ba8\u8fd9\u4e9b\u6982\u5ff5\uff0c\u4ee5\u53ca\u2014\u2014\u4ecb\u7ecd\u4e00\u4e9b\u5168\u65b0\u7684\u6982\u5ff5\u3002 \u672c\u6559\u7a0b\u7684\u6bcf\u4e00\u4e2a\u7ae0\u8282\u90fd\u6709\u4e00\u4e2a\u4e3b\u9898\uff0c\u7ae0\u8282\u7684\u5185\u5bb9\u5927\u4f53\u4e0a\u56f4\u7ed5\u7740\u8fd9\u4e2a\u4e3b\u9898\u5c55\u5f00\u3002\u6bcf\u4e00\u7ae0\u6ca1\u6709\u56fa\u5b9a\u7684\u5efa\u8bae\u9605\u8bfb\u65f6\u95f4\uff0c\u4ee5\u4f60\u6700\u8212\u9002\u7684\u901f\u5ea6\u524d\u8fdb\u5427\uff01","title":"\u6559\u7a0b\u7684\u7ed3\u6784"},{"location":"0-Introduction-getting-started/0.1-Introduction-to-these-tutorials/#_2","text":"\u5728\u5f00\u59cb\u4e4b\u524d\uff0c\u8ba9\u6211\u4eec\u6765\u770b\u770b\u672c\u6559\u7a0b\u7684\u51e0\u4e2a\u91cd\u8981\u76ee\u6807\uff1a \u6db5\u76d6C++\u76f8\u5173\u7684\u5185\u5bb9\u3002 \u4f20\u7edf\u7684\u7f16\u7a0b\u6559\u6750\u5c3d\u7ba1\u5728\u8bb2\u89e3\u7f16\u7a0b\u8bed\u8a00\u8bed\u6cd5\u57fa\u7840\u4e0a\u505a\u7684\u5f88\u8be6\u7ec6\uff0c\u4f46\u4ed6\u4eec\u5f80\u5f80\u5ffd\u89c6\u4e86\u4e00\u4e9b\u8bed\u8a00\u76f8\u5173\u7684\u9644\u52a0\u5185\u5bb9\u3002\u6bd4\u65b9\u8bf4\uff0c\u8fd9\u4e9b\u4e66\u7c4d\u5f80\u5f80\u4f1a\u5728\u7f16\u7801\u98ce\u683c\u3001\u5e38\u89c1\u8bef\u533a\u3001\u8c03\u8bd5\u3001\u7f16\u7a0b\u4e60\u60ef\u7684\u597d\u574f\u3001\u4ee5\u53ca\u4ee3\u7801\u6d4b\u8bd5\u4e0a\u8282\u7701\u7b14\u58a8\u3002\u90a3\u540e\u679c\u5c31\u662f\uff0c\u5f53\u4f60\u8bfb\u5b8c\u8fd9\u4e9b\u4e66\u65f6\uff0c\u4f60\u5927\u4f53\u4e0a\u77e5\u9053\u600e\u4e48\u7528\u8fd9\u95e8\u8bed\u8a00\u8fdb\u884c\u7f16\u7a0b\uff0c\u4f46\u4f60\u53ef\u80fd\u5728\u7f16\u7801\u4e60\u60ef\u548c\u7f16\u7a0b\u98ce\u683c\u4e0a\u4e00\u584c\u7cca\u6d82\uff0c\u8fd9\u4e9b\u4e60\u60ef\u5f80\u5f80\u4f1a\u5728\u672a\u6765\u6210\u4e3a\u4f60\u7f16\u7a0b\u4e4b\u8def\u7684\u7eca\u811a\u77f3\u3002\u672c\u6559\u7a0b\u5c06\u4f1a\u5728\u6bcf\u7ae0\u8282\u6070\u5f53\u7684\u5730\u65b9\u8ba8\u8bba\u8fd9\u4e9b\u9644\u52a0\u7684\u5185\u5bb9\uff0c\u786e\u4fdd\u8bfb\u8005\u5728\u9605\u8bfb\u8fc7\u7a0b\u4e2d\u4e0d\u65ad\u53d7\u5176\u718f\u67d3\uff0c\u6df1\u5165\u4eba\u5fc3\u3002\u5f53\u4f60\u5408\u4e0a\u672c\u6559\u7a0b\u7684\u5c01\u5e95\u65f6\uff0c\u4f60\u4e0d\u4ec5\u4ec5\u5b66\u4f1a\u4e86\u600e\u6837\u7528C++\u7f16\u7a0b\uff0c\u8fd8\u5c06\u77e5\u9053\u4ec0\u4e48\u573a\u666f\u4e0b\u4e0d\u5e94\u4f7f\u7528C++\u7f16\u7a0b\uff0c\u8fd9\u4e24\u8005\u540c\u7b49\u91cd\u8981\uff0c\u4e0d\u53ef\u504f\u5e9f\u3002 \u6d77\u91cf\u4e30\u5bcc\u7684\u4f8b\u5b50\u3002 \u901a\u8fc7\u9605\u8bfb\u5b9e\u4f8b\u4ee3\u7801\uff0c\u5927\u591a\u6570\u4eba\u6216\u591a\u6216\u5c11\u5730\u80fd\u591f\u6709\u6548\u5730\u5b66\u5230\u77e5\u8bc6\u3002\u672c\u6559\u7a0b\u81f4\u529b\u4e8e\u63d0\u4f9b\u5927\u91cf\u6e05\u6670\u7b80\u6d01\u7684\u793a\u4f8b\uff0c\u901a\u8fc7\u793a\u4f8b\u6765\u5b66\u4ee5\u81f4\u7528\u3002\u540c\u65f6\u6211\u4eec\u4e5f\u4f1a\u5c3d\u53ef\u80fd\u907f\u514d\u4e24\u5927\u53d9\u8ff0\u65f6\u7684\u201c\u6076\u9b54\u201d\uff1a\uff0c\u6bd4\u65b9\u8bf4\uff0c the magic hand wave \uff08\u4e5f\u79f0\u4e3a\u2026\u2026<\u6b64\u5904\u7701\u7565\u4e00\u4e07\u5b57>\uff09 \uff0c\u8bf8\u5982\u6b64\u7c7b\u4e3a\u4e86\u8282\u7701\u7a7a\u95f4\uff0c\u628a\u793a\u4f8b\u7684\u4e00\u90e8\u5206\u7ed9\u7701\u6389\u7684\u884c\u4e3a\uff0c\u4ee5\u53ca\uff0c\u5728\u793a\u4f8b\u4e2d\u5f15\u5165\u4e86\u4e00\u4e9b\u65b0\u6982\u5ff5\uff0c\u5374\u4e0d\u5bf9\u8fd9\u4e9b\u6982\u5ff5\u8fdb\u884c\u89e3\u91ca\u8bf4\u660e\u7684\u884c\u5f84\u3002\u6211\u4eec\u4f1a\u5c3d\u91cf\u907f\u514d\u8fd9\u79cd\u5bb9\u6613\u8ba9\u8bfb\u8005\u5728\u9605\u8bfb\u4e2d\u5361\u4f4f\u7684\u53d9\u8ff0\u65b9\u5f0f\u3002 \u5927\u91cf\u7528\u4e8e\u7ec3\u4e60\u7684\u7a0b\u5e8f \u672c\u6559\u7a0b\u6bcf\u7ae0\u8282\u7684\u7ed3\u5c3e\u4f1a\u6db5\u76d6\u4e00\u90e8\u5206\u5e26\u7b54\u6848\u7684\u7ec3\u4e60\u9898\uff0c\u8bfb\u8005\u53ef\u4ee5\u5c1d\u8bd5\u81ea\u5df1\u8fdb\u884c\u7ec3\u4e60\uff0c\u5e76\u628a\u4f60\u7684\u7b54\u6848\u548c\u6211\u4eec\u63d0\u4f9b\u7684\u7b54\u6848\u8fdb\u884c\u5bf9\u6bd4\u601d\u8003\uff0c\u6216\u8005\u8bf4\u5f53\u4f60\u5361\u5728\u67d0\u9053\u9898\u7684\u65f6\u5019\u770b\u4e00\u770b\u6211\u4eec\u63d0\u4f9b\u7684\u601d\u8def\u3002\u63a5\u7740\uff0c\u4f60\u53ef\u4ee5\u56de\u5230\u4f60\u9700\u8981\u505a\u66f4\u591a\u529f\u8bfe\u7684\u5730\u65b9\u8fdb\u884c\u5b66\u4e60\u3002 \u6700\u91cd\u8981\u7684\u4e8b\uff1a\u73a9\u5f97\u5f00\u5fc3\u3002\u7f16\u7a0b\u672c\u8eab\u662f\u4e00\u4ef6\u5145\u6ee1\u4e50\u8da3\u7684\u4e8b\u60c5\uff0c\u5982\u679c\u4f60\u5728\u8fd9\u4e2a\u8fc7\u7a0b\u4e2d\u65e0\u6bd4\u75db\u82e6\uff0c\u8bf4\u660e\u4f60\u8fd8\u6ca1\u6709\u771f\u6b63\u6478\u5230\u6b64\u4e2d\u7684\u95e8\u9053\u3002\u75b2\u60eb\u3001\u751a\u81f3\u95f7\u95f7\u4e0d\u4e50\u7684\u7a0b\u5e8f\u5458\u5f80\u5f80\u4f1a\u8c2c\u8bef\u4e0d\u65ad\uff0c\u5e76\u4e14\u4e0e\u5176\u8c03\u8bd5\u7a0b\u5e8f\u82b1\u8d39\u5927\u91cf\u7684\u65f6\u95f4\uff0c\u4e0d\u5982\u4e00\u5f00\u59cb\u6211\u4eec\u5c31\u5199\u51fa\u63a5\u8fd1\u5b8c\u7f8e\u7684\u4ee3\u7801\u3002\u53e6\u5916\uff0c\u4e0d\u8981\u8fc7\u52b3\u7f16\u7a0b\uff0c\u5c0f\u61a9\u7247\u523b\u6216\u8005\u9163\u7761\u81f3\u4e1c\u65b9\u53d1\u767d\uff0c\u89e3\u51b3\u95ee\u9898\u7684\u65b9\u6cd5\u5c06\u5728\u6668\u5149\u71b9\u5fae\u65f6\u95ea\u73b0\u5728\u4f60\u7684\u8111\u6d77\u91cc\u3002","title":"\u6559\u7a0b\u7684\u76ee\u6807"},{"location":"0-Introduction-getting-started/0.1-Introduction-to-these-tutorials/#_3","text":"\u5728\u4f60\u5b66\u4e60\u672c\u6559\u7a0b\u7684\u8fc7\u7a0b\u4e2d\uff0c\u6211\u4eec\u6709\u4e00\u4e9b\u5c0f\u5c0f\u7684\u5efa\u8bae\u4e5f\u8bb8\u53ef\u4ee5\u8ba9\u4f60\u5b66\u4e60\u7684\u6536\u76ca\u6700\u5927\u5316\uff1a \u4eb2\u81ea\u628a\u793a\u4f8b\u7684\u4ee3\u7801\u624b\u6253\u4e00\u904d\u5e76\u4e14\u7f16\u8bd1\u8fd0\u884c\uff0c\u4e0d\u8981\u590d\u5236\u7c98\u8d34\uff01\u8fd9\u4f1a\u5e2e\u52a9\u4f60\u77e5\u9053\u54ea\u4e9b\u5730\u65b9\u4f60\u5bb9\u6613\u51fa\u9519\uff0c\u5e76\u4e14\u8ba9\u4f60\u5bf9\u5e38\u89c1\u7684\u7f16\u8bd1\u8b66\u544a\u548c\u9519\u8bef\u719f\u6089\u3002\u4e0d\u8981\u65e0\u8111\u7684copy\u4ee3\u7801\uff0c\u5f53\u4f60\u624b\u6253\u6bcf\u4e00\u884c\u4ee3\u7801\u65f6\uff0c\u4f60\u90fd\u8981\u601d\u8003\u5b83\u4eec\u505a\u4e86\u4ec0\u4e48\uff0c\u5b9e\u73b0\u4e86\u7a0b\u5e8f\u7684\u54ea\u4e9b\u529f\u80fd\u3002\u5f53\u4f60\u9047\u5230\u4e00\u4e9b\u4e0d\u80fd\u7406\u89e3\u6216\u8005\u4f60\u8ba4\u4e3a\u4e0d\u5408\u7406\u7684\u4e1c\u897f\u65f6\uff0c\u8fd9\u65f6\u5019\u5c31\u9700\u8981\u4f60\u8fdb\u4e00\u6b65\u67e5\u9605\u8d44\u6599\uff0c\u6df1\u5165\u8c03\u7814\u3002 \u5728\u7f16\u7a0b\u7684\u65f6\u5019\uff0c\u4f60\u53ef\u80fd\u4f1a\u72af\u4e0b\u8c2c\u8bef\u6216\u8005\u4ea7\u751fbug\u3002\u5728\u5bfb\u6c42\u5927\u4f6c\u5e2e\u52a9\u524d\uff0c\u5c3d\u91cf\u5c1d\u8bd5\u81ea\u5df1\u53bb\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\u3002bug\u7684\u67e5\u627e\u4ee5\u53ca\u4fee\u590d\u4e5f\u662f\u4e00\u4e2a\u597d\u7684\u7a0b\u5e8f\u5458\u7684\u5173\u952e\u6280\u80fd\u3002\u522b\u5fd8\u4e86\u5b66\u4e60\u4f7f\u7528\u8c03\u8bd5\u5668\uff08\u6211\u4eec\u4f1a\u5728\u4e4b\u540e\u7684\u8bfe\u7a0b\u4e2d\u8bb2\u89e3\u4f7f\u7528\u65b9\u6cd5\uff09\u2014\u2014\u4e00\u79cd\u80fd\u5e2e\u4f60\u627e\u5230bug\u4f4d\u7f6e\u7684\u5173\u952e\u5de5\u5177\u3002 \u5bf9\u793a\u4f8b\u4ee3\u7801\u8fdb\u884c\u8fdb\u4e00\u6b65\u7684\u5b9e\u9a8c\u3002\u5c1d\u8bd5\u4fee\u6539\u793a\u4f8b\u4e2d\u7684\u6570\u636e\u548c\u6587\u672c\u770b\u770b\u4f1a\u53d1\u751f\u4ec0\u4e48\uff0c\u4fee\u6539\u4ee3\u7801\u7684\u903b\u8f91\u4ee5\u8fdb\u4e00\u6b65\u5b9e\u73b0\u65b0\u7684\u529f\u80fd\uff08\u6bd4\u5982\u8bf4\uff0c\u539f\u6765\u7a0b\u5e8f\u662f\u8ba1\u7b97\u4e24\u6570\u548c\uff0c\u6211\u4eec\u8ba9\u4ed6\u53ef\u4ee5\u8ba1\u7b97\u4e09\u4e2a\u6570\u7684\u548c\uff09\u3002\u60f3\u4e0d\u540c\u7684\u529e\u6cd5\u8ba9\u7a0b\u5e8f\u7ec8\u6b62\u8fd0\u884c\uff08\u5982\u679c\u7a0b\u5e8f\u8981\u6c42\u7528\u6237\u8f93\u5165\uff0c\u6211\u4eec\u53ef\u4ee5\u5c1d\u8bd5\u5404\u79cd\u8f93\u5165\uff09\u3002\u901a\u8fc7\u4fee\u6539\u793a\u4f8b\u7a0b\u5e8f\u8fdb\u884c\u5b9e\u9a8c\uff0c\u4f60\u4f1a\u6bd4\u4ec5\u4ec5\u53ea\u4f7f\u7528\u5b9e\u4f8b\u7a0b\u5e8f\u5b66\u5230\u66f4\u591a\u4e1c\u897f\u3002 \u82b1\u70b9\u65f6\u95f4\u5b8c\u6210\u5c0f\u6d4b\u9a8c\u3002\u5982\u679c\u4f60\u662f\u7f16\u7a0b\u83dc\u9e21\uff0c\u4f60\u53ef\u80fd\u4f1a\u89c9\u5f97\u4ed6\u4eec\u6709\u70b9\u96be\u5ea6\uff08\u8fd9\u5f88\u6b63\u5e38\uff0c\u56e0\u4e3a\u4f60\u7684\u5927\u8111\u5728\u4e0d\u65ad\u9002\u5e94\u7f16\u7a0b\u7684\u601d\u7ef4\uff09\u3002\u5982\u679c\u4e00\u6b21\u6ca1\u6709\u505a\u5bf9\u4e5f\u4e0d\u8981\u6cae\u4e27\uff0c\u518d\u8bd5\u51e0\u6b21\u4f60\u6ca1\u51c6\u5c31\u4f1a\u6210\u529f\u3002\u5982\u679c\u4f60\u786e\u5b9e\u5361\u4f4f\u4e86\uff0c\u770b\u770b\u7b54\u6848\u4e5f\u662f\u65e0\u6240\u8c13\u7684\u3002\u53ea\u8981\u786e\u4fdd\u4f60\u7406\u89e3\u4e86\u7b54\u6848\u7684\u5185\u5bb9\u548c\u539f\u7406\u3002 \u7528\u4f60\u5b66\u5230\u7684\u6982\u5ff5\u5199\u4f60\u81ea\u5df1\u7684\u5c0f\u7a0b\u5e8f\u3002\u7eb8\u4e0a\u5f97\u6765\u7ec8\u89c9\u6d45\uff0c\u7edd\u77e5\u6b64\u4e8b\u8981\u8eac\u884c\u3002","title":"\u5145\u5206\u5229\u7528\u672c\u6559\u7a0b"},{"location":"0-Introduction-getting-started/0.1-Introduction-to-these-tutorials/#learncppcom","text":"\u95ee\uff1a\u7f51\u7ad9\u600e\u4e48\u6ce8\u518c\uff1f\u600e\u6837\u624d\u80fd\u767b\u5f55\uff1f \u7b54 \uff1a\u672c\u7ad9\u7684\u6240\u6709\u5185\u5bb9\u90fd\u80fd\u514d\u767b\u5f55\u6d4f\u89c8\u2014\u2014\u6240\u4ee5\uff0c\u65e0\u9700\u6ce8\u518c\uff01 \u95ee\uff1a\u8fd9\u4e9b\u6559\u7a0b\u6700\u65e92007\u5e74\u7f16\u5199\u7684\uff0c\u73b0\u5728\u8fd8\u80fd\u7528\u5417\uff1f \u7b54 \uff1a\u5f53\u7136\uff0c\u80af\u5b9a\u53ef\u4ee5\u7528\u3002 C++\u7684\u6807\u51c6\u4fee\u8ba2\u5e76\u975e\u7279\u522b\u9891\u7e41\uff0c\u5373\u4f7f\u6709\u53d8\u5316\uff0c\u4e5f\u662f\u5728\u539f\u6765\u7684\u57fa\u7840\u4e0a\u589e\u52a0\u65b0\u7684\u7279\u6027\u3002\u5f53\u7136\uff0c\u672c\u6559\u7a0b\u4e5f\u4f1a\u968f\u7740\u8bed\u8a00\u6807\u51c6\u53d8\u5316\u548c\u8bfb\u8005\u53cd\u9988\u5b9a\u671f\u66f4\u65b0\u3002 \u95ee\uff1a\u672c\u7f51\u7ad9\u7684\u6559\u7a0b\u6709pdf\u7248\u672c\u4f9b\u79bb\u7ebf\u9605\u8bfb\u5417\uff1f \u7b54\uff1a\u62b1\u6b49\uff0c\u8fd9\u4e2a\u6ca1\u6709\u3002\u672c\u7f51\u7ad9\u514d\u8d39\u5f00\u53d1\u7684\u539f\u56e0\u662f\u56e0\u4e3a\u53d7\u5e7f\u544a\u5546\u8d5e\u52a9\u2014\u2014\u800cpdf\u7248\u672c\u65e0\u6cd5\u6295\u5165\u5e7f\u544a\u3002\u5f53\u7136\uff0c\u4f60\u4e5f\u53ef\u4ee5\u628a\u672c\u7ad9\u4e0a\u7684\u7f51\u9875\u8f6c\u6362\u4e3apdf\u505a\u79c1\u4eba\u7528\u9014\uff0c\u53ea\u8981\u4e0d\u628apdf\u7248\u672c\u4f20\u64ad\u51fa\u53bb\u5c31ok\u4e86\u3002 \u95ee\uff1a\u5982\u679c\u6211\u5361\u5728\u67d0\u4e2a\u6982\u5ff5\u4e86\u600e\u4e48\u529e\uff1f \u7b54\uff1a\u5982\u679c\u4f60\u5bf9\u67d0\u4e00\u90e8\u5206\u4e0d\u592a\u660e\u767d\uff0c\u4f60\u53ef\u4ee5\uff1a \u9605\u8bfb\u8bc4\u8bba\u3002\u5176\u4ed6\u7684\u8bfb\u8005\u53ef\u80fd\u4e5f\u9047\u5230\u4e86\u76f8\u4f3c\u7684\u95ee\u9898\u3002 \u7c97\u8bfb\u4e0b\u4e00\u7ae0\u7684\u6559\u7a0b\u2014\u2014\u8bf4\u4e0d\u5b9a\u4f60\u7684\u7591\u60d1\u4f1a\u5728\u90a3\u91cc\u5f97\u5230\u89e3\u7b54\u3002 \u5584\u7528\u641c\u7d22\u5f15\u64ce\u67e5\u627e\u4f60\u7684\u95ee\u9898\u3002 \u5728\u7c7b\u4f3c StackOverflow \u7684\u95ee\u7b54\u7f51\u7ad9\u4e0a\u63d0\u95ee\u3002 \u5982\u679c\u90fd\u6ca1\u7528\u7684\u8bdd\uff0c\u6682\u65f6\u8df3\u8fc7\u8fd9\u4e00\u90e8\u5206\u4e0d\u61c2\u7684\u5185\u5bb9\uff0c\u4ee5\u5f85\u5c06\u6765\u7ffb\u770b\u3002\u5230\u90a3\u65f6\u4f60\u53ef\u80fd\u4f1a\u53d1\u73b0\uff0c\u5728\u5b66\u4e60\u4e86\u5176\u4ed6\u7ae0\u7684\u77e5\u8bc6\u548c\u6587\u7ae0\u4ee5\u540e\uff0c\u518d\u56de\u5934\u6765\u770b\uff0c\u66fe\u7ecf\u8270\u6da9\u96be\u61c2\u7684\u4e1c\u897f\u4e00\u4e0b\u5b50\u8305\u585e\u987f\u5f00\u3002 \u95ee\uff1a\u5982\u679c\u6211\u9057\u5fd8\u4e86\u67d0\u4e2a\u6982\u5ff5\u600e\u4e48\u529e\uff1f \u7b54\uff1a\u5584\u7528 \u4e3b\u9875\u7d22\u5f15 ,\u67e5\u627e\u4f60\u9700\u8981\u4e86\u89e3\u7684\u6982\u5ff5\uff0c\u4f60\u4f1a\u627e\u5230\u8bb2\u89e3\u76f8\u5173\u77e5\u8bc6\u7684\u7ae0\u8282\u3002 \u95ee\uff1a\u600e\u4e48\u80fd\u5728\u8bc4\u8bba\u533a\u5e26\u5934\u50cf\u8bc4\u8bba\uff1f \u8bc4\u8bba\u533a\u4f7f\u7528\u4e86gravatars\u3002\u4f60\u53ef\u4ee5\u5728 gravatar.com \u521b\u5efa\u4e00\u4e2a\u8d26\u6237\u3002\u70b9\u51fb\u201cCreate your own gravatar\u201d\u6309\u94ae\u5e76\u6ce8\u518c\u3002\u4f60\u7684gravatar\u8d26\u6237\u5c06\u4e0e\u4f60\u7684\u90ae\u7bb1\uff08\u53ef\u9009\uff09\u5173\u8054\u3002 \u95ee\uff1a\u672c\u7f51\u7ad9\u6709\u9ed1\u591c\u6a21\u5f0f\u5417\uff1f \u7b54\uff1a\u6ca1\u6709\u81ea\u5e26\u7684\u3002\u4f46\u4f60\u80fd\u624b\u52a8\u641e\u4e00\u641e\uff0c\u8be6\u89c1 darkreader.org \u6700\u540e\uff0c\u4e00\u4e2a\u5c0f\u5c0f\u7684\u4e0d\u60c5\u4e4b\u8bf7\uff1a\u672c\u7f51\u7ad9\u56e0\u5e7f\u544a\u5546\u8d5e\u52a9\u800c\u5f97\u4ee5\u514d\u8d39\u3002\u5982\u679c\u4f60\u559c\u6b22\u672c\u7f51\u7ad9\u7684\u8bfe\u7a0b\uff0c\u53ef\u8003\u8651\u5173\u95ed\u5e7f\u544a\u62e6\u622a\u5668\u6765\u652f\u6301\u6211\u4eec\u3002 \u597d\u7684\uff0c\u4e00\u5207\u5c31\u7eea\uff0c\u8ba9\u6211\u4eec\u5f00\u59cb\u5427\uff01","title":"\u7f51\u7ad9\u76f8\u5173\uff08\u6307learncpp.com\uff09"},{"location":"12-virtual-functions/","text":"\u7b2c\u5341\u4e8c\u7ae0 \u865a\u51fd\u6570 \u00b6 12.7-\u865a\u57fa\u7c7b (Virtual Base Classes) 12.8-\u5bf9\u8c61\u5207\u5272 (Object Slicing) 12.9-\u52a8\u6001\u7c7b\u578b\u8f6c\u6362 (Dynamic Cast) 12.x-\u590d\u4e60\u3001\u7406\u89e3\u548c\u7ec3\u4e60 (Comprehensice Quiz)","title":"\u7b2c\u5341\u4e8c\u7ae0 \u865a\u51fd\u6570"},{"location":"12-virtual-functions/#_1","text":"12.7-\u865a\u57fa\u7c7b (Virtual Base Classes) 12.8-\u5bf9\u8c61\u5207\u5272 (Object Slicing) 12.9-\u52a8\u6001\u7c7b\u578b\u8f6c\u6362 (Dynamic Cast) 12.x-\u590d\u4e60\u3001\u7406\u89e3\u548c\u7ec3\u4e60 (Comprehensice Quiz)","title":"\u7b2c\u5341\u4e8c\u7ae0 \u865a\u51fd\u6570"},{"location":"12-virtual-functions/12.7-virtual-base-classes/","text":"12.7 \u865a\u57fa\u7c7b (Virtual base classes) \u00b6 \u4e0a\u4e00\u7ae0\uff0c\u5728 \u7b2c11.7\u8bfe\u2014\u2014\u591a\u91cd\u7ee7\u627f\u4e2d \uff0c\u6211\u4eec\u7559\u4e0b\u4e86\u4e00\u4e2a\u201c\u94bb\u77f3\u95ee\u9898\u201d\u3002\u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u7ee7\u7eed\u8ba8\u8bba\u3002 \u6ce8\u610f\uff1a \u672c\u8282\u662f\u4e00\u4e2a\u9ad8\u7ea7\u4e3b\u9898\uff0c\u5982\u679c\u9700\u8981\u53ef\u4ee5\u8df3\u8fc7\u6216\u7565\u8fc7\u3002 \u94bb\u77f3\u95ee\u9898 (The diamond problem) \u00b6 \u4ee5\u4e0b\u662f\u4e0a\u4e00\u8bfe\u4e2d\u7684\u793a\u4f8b\uff08\u4f7f\u7528\u4e00\u4e9b\u6784\u9020\u51fd\u6570\uff09\u6765\u8bf4\u660e\u83f1\u5f62\u95ee\u9898\uff1a class PoweredDevice { public : PoweredDevice ( int power ) { cout << \"PoweredDevice: \" << power << '\\n' ; } }; class Scanner : public PoweredDevice { public : Scanner ( int scanner , int power ) : PoweredDevice ( power ) { cout << \"Scanner: \" << scanner << '\\n' ; } }; class Printer : public PoweredDevice { public : Printer ( int printer , int power ) : PoweredDevice ( power ) { cout << \"Printer: \" << printer << '\\n' ; } }; class Copier : public Scanner , public Printer { public : Copier ( int scanner , int printer , int power ) : Scanner ( scanner , power ), Printer ( printer , power ) { } }; \u5c3d\u7ba1\u4f60\u53ef\u80fd\u89c9\u5f97\u6211\u4eec\u5f97\u5230\u4e86\u8fd9\u6837\u7684\u56fe\u5f62\uff1a \u5982\u679c\u8981\u521b\u5efa\u4e00\u4e2aCopier\u7c7b\u5bf9\u8c61\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u60a8\u5c06\u5f97\u5230PoweredDevice\u7c7b\u7684\u4e24\u4e2a\u526f\u672c\uff0c\u4e00\u4e2a\u6765\u81eaPrinter\uff0c\u4e00\u4e2a\u6765\u81eaScanner\u3002\u5176\u7ed3\u6784\u5982\u4e0b\uff1a \u6211\u4eec\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a\u7b80\u77ed\u7684\u6d4b\u8bd5\u6765\u8bf4\u660e\u8fd9\u4e00\u70b9\uff1a int main () { Copier copier ( 1 , 2 , 3 ); return 0 ; } \u8fd9\u5c06\u4ea7\u751f\u7ed3\u679c PoweredDevice: 3 Scanner: 1 PoweredDevice: 3 Printer: 2 \u5982\u4f60\u6240\u89c1\uff0cPoweredDevice\u88ab\u6784\u9020\u4e86\u4e24\u6b21\u3002 \u867d\u7136\u8fd9\u662f\u7ecf\u5e38\u9700\u8981\u7684\uff0c\u4f46\u6709\u65f6\u60a8\u53ef\u80fd\u53ea\u5e0c\u671b\u626b\u63cf\u4eea\u548c\u6253\u5370\u673a\u5171\u4eabPoweredDevice\u7684\u4e00\u4e2a\u526f\u672c\u3002 \u865a\u57fa\u7c7b (Virtual base classes) \u00b6 \u8981\u5171\u4eab\u57fa\u7c7b\uff0c\u53ea\u9700\u5728\u6d3e\u751f\u7c7b\u7684\u7ee7\u627f\u5217\u8868\u4e2d\u63d2\u5165\u201cvirtual\u201d\u5173\u952e\u5b57\u3002\u8fd9\u5c06\u521b\u5efa\u6240\u8c13\u7684\u865a\u62df\u57fa\u7c7b\uff0c\u8fd9\u610f\u5473\u7740\u53ea\u6709\u4e00\u4e2a\u57fa\u7c7b\u5bf9\u8c61\u3002\u57fa\u5bf9\u8c61\u5728\u7ee7\u627f\u6811\u4e2d\u7684\u6240\u6709\u5bf9\u8c61\u4e4b\u95f4\u5171\u4eab\uff0c\u5e76\u4e14\u53ea\u6784\u9020\u4e00\u6b21\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u793a\u4f8b\uff08\u4e3a\u7b80\u5355\u8d77\u89c1\uff0c\u4e0d\u4f7f\u7528\u6784\u9020\u51fd\u6570\uff09\u6f14\u793a\u5982\u4f55\u4f7f\u7528virtual\u5173\u952e\u5b57\u521b\u5efa\u5171\u4eab\u57fa\u7c7b\uff1a class PoweredDevice { }; class Scanner : virtual public PoweredDevice { }; class Printer : virtual public PoweredDevice { }; class Copier : public Scanner , public Printer { }; \u73b0\u5728\uff0c\u5f53\u60a8\u521b\u5efa\u4e00\u4e2aCopier\u7c7b\u5bf9\u8c61\u65f6\uff0c\u6bcf\u4e2a Copier \u53ea\u4f1a\u5f97\u5230\u4e00\u4e2a PoweredDevice \u526f\u672c\uff0c\u8be5\u526f\u672c\u5c06\u7531 Scanner \u548c Printer \u5171\u4eab\u3002 \u7136\u800c\uff0c\u8fd9\u53c8\u5f15\u51fa\u4e86\u4e00\u4e2a\u95ee\u9898\uff1a\u5982\u679c Scanner \u548c Printer \u5171\u4eabPoweredDevice\u57fa\u7c7b\uff0c\u8c01\u8d1f\u8d23\u521b\u5efa\u5b83\uff1f\u4e8b\u5b9e\u8bc1\u660e\uff0c\u7b54\u6848\u662f Copier\u3002Copier \u6784\u9020\u51fd\u6570\u8d1f\u8d23\u521b\u5efa PoweredDevice\u3002\u56e0\u6b64\uff0c\u8fd9\u5141\u8bb8 Copier \u76f4\u63a5\u8c03\u7528 \u975e\u76f4\u63a5 (non-immediate-parent) \u6784\u9020\u51fd\u6570\uff1a #include <iostream> class PoweredDevice { public : PoweredDevice ( int power ) { std :: cout << \"PoweredDevice: \" << power << '\\n' ; } }; class Scanner : virtual public PoweredDevice // note: PoweredDevice \u73b0\u5728\u662f\u4e00\u4e2a\u865a\u57fa\u7c7b { public : Scanner ( int scanner , int power ) : PoweredDevice ( power ) // \u8fd9\u884c\u662f\u521b\u5efa Scanner \u5fc5\u8981\u7684\uff0c\u5728\u8fd9\u4e2a\u4f8b\u5b50\u91cc\u6211\u4eec\u53ef\u4ee5\u5ffd\u7565\u3002 { std :: cout << \"Scanner: \" << scanner << '\\n' ; } }; class Printer : virtual public PoweredDevice // note: PoweredDevice \u73b0\u5728\u662f\u4e00\u4e2a\u865a\u57fa\u7c7b { public : Printer ( int printer , int power ) : PoweredDevice ( power ) // \u8fd9\u884c\u662f\u521b\u5efa Printer \u5fc5\u8981\u7684\uff0c\u5728\u8fd9\u4e2a\u4f8b\u5b50\u91cc\u6211\u4eec\u53ef\u4ee5\u5ffd\u7565\u3002 { std :: cout << \"Printer: \" << printer << '\\n' ; } }; class Copier : public Scanner , public Printer { public : Copier ( int scanner , int printer , int power ) : PoweredDevice ( power ), // PoweredDevice \u5728\u8fd9\u91cc\u8fdb\u884c\u6784\u9020 Scanner ( scanner , power ), Printer ( printer , power ) { } }; \u8fd8\u662f\u7528\u524d\u9762\u7684\u4f8b\u5b50 int main () { Copier copier ( 1 , 2 , 3 ); return 0 ; } \u4ea7\u751f\u7ed3\u679c PoweredDevice: 3 Scanner: 1 Printer: 2 \u5982\u60a8\u6240\u89c1\uff0cPoweredDevice\u53ea\u6784\u5efa\u4e00\u6b21\u3002 \u6709\u4e00\u4e9b\u7ec6\u8282\uff0c\u5982\u679c\u6211\u4eec\u6211\u4eec\u5fc5\u987b\u8981\u8bf4\u660e \u9996\u5148\uff1a \u865a\u57fa\u7c7b\u603b\u662f\u5728\u975e\u865a\u57fa\u7c7b\u4e4b\u524d\u521b\u5efa\uff0c\u8fd9\u786e\u4fdd\u6240\u6709\u57fa\u7c7b\u5728\u6d3e\u751f\u7c7b\u4e4b\u524d\u521b\u5efa\u3002 \u5176\u6b21\uff1a \u8bf7\u6ce8\u610f Scanner \u548c Printer \u6784\u9020\u51fd\u6570\u4ecd\u6709\u8c03\u7528 PoweredDevice \u7684\u6784\u9020\u51fd\u6570\u3002\u521b\u5efa Copier \u5b9e\u4f8b\u65f6\uff0c\u8fd9\u4e9b\u6784\u9020\u51fd\u6570\u8c03\u7528\u88ab\u5ffd\u7565\uff0c\u56e0\u4e3a Copier \u8d1f\u8d23\u521b\u5efa PoweredDevice \uff0c\u800c\u4e0d\u662f Scanner \u6216 Printer \u3002\u4f46\u662f\uff0c\u5982\u679c\u6211\u4eec\u8981\u521b\u5efa Scanner \u6216 Printer \u7684\u5b9e\u4f8b\uff0c\u90a3\u4e48\u8c03\u7528\u90a3\u4e9b\u6784\u9020\u51fd\u6570\uff0c\u5e76\u5e94\u7528\u5e38\u89c4\u7ee7\u627f\u89c4\u5219\u3002 \u7b2c\u4e09\uff1a \u5982\u679c\u4e00\u4e2a\u7c7b\u7ee7\u627f\u4e86\u4e00\u4e2a\u6216\u591a\u4e2a\u5177\u6709\u865a\u57fa\u7c7b\u7684\u7c7b\uff0c\u5219 \u672b\u7aef\u6d3e\u751f(most derived) \u7684\u7c7b\u8d1f\u8d23\u6784\u9020\u865a\u57fa\u7c7b\u3002\u5728\u672c\u4f8b\u4e2d\uff0cCopier \u7ee7\u627f Printer \u548c Scanner \uff0c\u5b83\u4eec\u90fd\u6709\u4e00\u4e2a PoweredDevice \u865a\u62df\u57fa\u7c7b\u3002Copier \u662f\u6700\u6d3e\u751f\u7684\u7c7b\uff0c\u8d1f\u8d23\u521b\u5efa PoweredDevice \u3002\u8bf7\u6ce8\u610f\uff0c\u5373\u4f7f\u5728\u5355\u4e00\u7ee7\u627f\u60c5\u51b5\u4e0b\u4e5f\u662f\u5982\u6b64\uff1a\u5982\u679c Copier \u662f\u4ece Printer \u5355\u72ec\u7ee7\u627f\u7684\uff0c\u800c Printer \u5b9e\u9645\u4e0a\u662f\u4ece PoweredDevice \u7ee7\u627f\u7684\uff0cCopier \u4ecd\u7136\u8d1f\u8d23\u521b\u5efa PoweredDevice \u3002 \u7b2c\u56db\uff1a \u7ee7\u627f\u4e00\u4e2a\u865a\u62df\u57fa\u7c7b\u7684\u6240\u6709\u7c7b\u90fd\u5c06\u6709\u4e00\u4e2a\u865a\u62df\u8868\uff0c\u5373\u4f7f\u5b83\u4eec\u901a\u5e38\u4e0d\u4f1a\u6709\uff0c\u5b9e\u4f8b\u5316\u7684\u5bf9\u8c61\u4f1a\u56e0\u4e3a\u8fd9\u4e2a\u6307\u9488\u589e\u52a0\u4e00\u4e9b\u5c3a\u5bf8\u3002 \u56e0\u4e3a Scanner \u548c Printer \u662f\u4ece PoweredDevice \u865a\u7ee7\u627f\u51fa\u6765\u7684\uff0c\u6240\u4ee5 \u53ea\u6709\u4e00\u4e2a PoweredDevice \u5b50\u5bf9\u8c61\u3002Scanner \u548c Printer \u90fd\u9700\u8981\u77e5\u9053\u5982\u4f55\u627e\u5230\u8fd9\u4e2a PoweredDevice \u5b50\u5bf9\u8c61\uff0c\u4ee5\u4fbf\u8bbf\u95ee\u5b83\u7684\u6210\u5458\uff08\u56e0\u4e3a\u6bd5\u7adf\uff0c\u5b83\u4eec\u662f\u4ece\u5b83\u6d3e\u751f\u7684\uff09\u3002\u8fd9\u901a\u5e38\u662f\u901a\u8fc7\u4e00\u4e9b\u865a\u8868\u6765\u5b9e\u73b0\u7684\uff08\u5b83\u5b9e\u9645\u4e0a\u5b58\u50a8\u4e86\u4ece\u6bcf\u4e2a\u5b50\u7c7b\u5230 PoweredDevice \u5b50\u5bf9\u8c61\u7684\u504f\u79fb\u91cf\uff09\u3002","title":"12.7 \u865a\u57fa\u7c7b (Virtual base classes)"},{"location":"12-virtual-functions/12.7-virtual-base-classes/#127-virtual-base-classes","text":"\u4e0a\u4e00\u7ae0\uff0c\u5728 \u7b2c11.7\u8bfe\u2014\u2014\u591a\u91cd\u7ee7\u627f\u4e2d \uff0c\u6211\u4eec\u7559\u4e0b\u4e86\u4e00\u4e2a\u201c\u94bb\u77f3\u95ee\u9898\u201d\u3002\u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u7ee7\u7eed\u8ba8\u8bba\u3002 \u6ce8\u610f\uff1a \u672c\u8282\u662f\u4e00\u4e2a\u9ad8\u7ea7\u4e3b\u9898\uff0c\u5982\u679c\u9700\u8981\u53ef\u4ee5\u8df3\u8fc7\u6216\u7565\u8fc7\u3002","title":"12.7 \u865a\u57fa\u7c7b (Virtual base classes)"},{"location":"12-virtual-functions/12.7-virtual-base-classes/#the-diamond-problem","text":"\u4ee5\u4e0b\u662f\u4e0a\u4e00\u8bfe\u4e2d\u7684\u793a\u4f8b\uff08\u4f7f\u7528\u4e00\u4e9b\u6784\u9020\u51fd\u6570\uff09\u6765\u8bf4\u660e\u83f1\u5f62\u95ee\u9898\uff1a class PoweredDevice { public : PoweredDevice ( int power ) { cout << \"PoweredDevice: \" << power << '\\n' ; } }; class Scanner : public PoweredDevice { public : Scanner ( int scanner , int power ) : PoweredDevice ( power ) { cout << \"Scanner: \" << scanner << '\\n' ; } }; class Printer : public PoweredDevice { public : Printer ( int printer , int power ) : PoweredDevice ( power ) { cout << \"Printer: \" << printer << '\\n' ; } }; class Copier : public Scanner , public Printer { public : Copier ( int scanner , int printer , int power ) : Scanner ( scanner , power ), Printer ( printer , power ) { } }; \u5c3d\u7ba1\u4f60\u53ef\u80fd\u89c9\u5f97\u6211\u4eec\u5f97\u5230\u4e86\u8fd9\u6837\u7684\u56fe\u5f62\uff1a \u5982\u679c\u8981\u521b\u5efa\u4e00\u4e2aCopier\u7c7b\u5bf9\u8c61\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u60a8\u5c06\u5f97\u5230PoweredDevice\u7c7b\u7684\u4e24\u4e2a\u526f\u672c\uff0c\u4e00\u4e2a\u6765\u81eaPrinter\uff0c\u4e00\u4e2a\u6765\u81eaScanner\u3002\u5176\u7ed3\u6784\u5982\u4e0b\uff1a \u6211\u4eec\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a\u7b80\u77ed\u7684\u6d4b\u8bd5\u6765\u8bf4\u660e\u8fd9\u4e00\u70b9\uff1a int main () { Copier copier ( 1 , 2 , 3 ); return 0 ; } \u8fd9\u5c06\u4ea7\u751f\u7ed3\u679c PoweredDevice: 3 Scanner: 1 PoweredDevice: 3 Printer: 2 \u5982\u4f60\u6240\u89c1\uff0cPoweredDevice\u88ab\u6784\u9020\u4e86\u4e24\u6b21\u3002 \u867d\u7136\u8fd9\u662f\u7ecf\u5e38\u9700\u8981\u7684\uff0c\u4f46\u6709\u65f6\u60a8\u53ef\u80fd\u53ea\u5e0c\u671b\u626b\u63cf\u4eea\u548c\u6253\u5370\u673a\u5171\u4eabPoweredDevice\u7684\u4e00\u4e2a\u526f\u672c\u3002","title":"\u94bb\u77f3\u95ee\u9898 (The diamond problem)"},{"location":"12-virtual-functions/12.7-virtual-base-classes/#virtual-base-classes","text":"\u8981\u5171\u4eab\u57fa\u7c7b\uff0c\u53ea\u9700\u5728\u6d3e\u751f\u7c7b\u7684\u7ee7\u627f\u5217\u8868\u4e2d\u63d2\u5165\u201cvirtual\u201d\u5173\u952e\u5b57\u3002\u8fd9\u5c06\u521b\u5efa\u6240\u8c13\u7684\u865a\u62df\u57fa\u7c7b\uff0c\u8fd9\u610f\u5473\u7740\u53ea\u6709\u4e00\u4e2a\u57fa\u7c7b\u5bf9\u8c61\u3002\u57fa\u5bf9\u8c61\u5728\u7ee7\u627f\u6811\u4e2d\u7684\u6240\u6709\u5bf9\u8c61\u4e4b\u95f4\u5171\u4eab\uff0c\u5e76\u4e14\u53ea\u6784\u9020\u4e00\u6b21\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u793a\u4f8b\uff08\u4e3a\u7b80\u5355\u8d77\u89c1\uff0c\u4e0d\u4f7f\u7528\u6784\u9020\u51fd\u6570\uff09\u6f14\u793a\u5982\u4f55\u4f7f\u7528virtual\u5173\u952e\u5b57\u521b\u5efa\u5171\u4eab\u57fa\u7c7b\uff1a class PoweredDevice { }; class Scanner : virtual public PoweredDevice { }; class Printer : virtual public PoweredDevice { }; class Copier : public Scanner , public Printer { }; \u73b0\u5728\uff0c\u5f53\u60a8\u521b\u5efa\u4e00\u4e2aCopier\u7c7b\u5bf9\u8c61\u65f6\uff0c\u6bcf\u4e2a Copier \u53ea\u4f1a\u5f97\u5230\u4e00\u4e2a PoweredDevice \u526f\u672c\uff0c\u8be5\u526f\u672c\u5c06\u7531 Scanner \u548c Printer \u5171\u4eab\u3002 \u7136\u800c\uff0c\u8fd9\u53c8\u5f15\u51fa\u4e86\u4e00\u4e2a\u95ee\u9898\uff1a\u5982\u679c Scanner \u548c Printer \u5171\u4eabPoweredDevice\u57fa\u7c7b\uff0c\u8c01\u8d1f\u8d23\u521b\u5efa\u5b83\uff1f\u4e8b\u5b9e\u8bc1\u660e\uff0c\u7b54\u6848\u662f Copier\u3002Copier \u6784\u9020\u51fd\u6570\u8d1f\u8d23\u521b\u5efa PoweredDevice\u3002\u56e0\u6b64\uff0c\u8fd9\u5141\u8bb8 Copier \u76f4\u63a5\u8c03\u7528 \u975e\u76f4\u63a5 (non-immediate-parent) \u6784\u9020\u51fd\u6570\uff1a #include <iostream> class PoweredDevice { public : PoweredDevice ( int power ) { std :: cout << \"PoweredDevice: \" << power << '\\n' ; } }; class Scanner : virtual public PoweredDevice // note: PoweredDevice \u73b0\u5728\u662f\u4e00\u4e2a\u865a\u57fa\u7c7b { public : Scanner ( int scanner , int power ) : PoweredDevice ( power ) // \u8fd9\u884c\u662f\u521b\u5efa Scanner \u5fc5\u8981\u7684\uff0c\u5728\u8fd9\u4e2a\u4f8b\u5b50\u91cc\u6211\u4eec\u53ef\u4ee5\u5ffd\u7565\u3002 { std :: cout << \"Scanner: \" << scanner << '\\n' ; } }; class Printer : virtual public PoweredDevice // note: PoweredDevice \u73b0\u5728\u662f\u4e00\u4e2a\u865a\u57fa\u7c7b { public : Printer ( int printer , int power ) : PoweredDevice ( power ) // \u8fd9\u884c\u662f\u521b\u5efa Printer \u5fc5\u8981\u7684\uff0c\u5728\u8fd9\u4e2a\u4f8b\u5b50\u91cc\u6211\u4eec\u53ef\u4ee5\u5ffd\u7565\u3002 { std :: cout << \"Printer: \" << printer << '\\n' ; } }; class Copier : public Scanner , public Printer { public : Copier ( int scanner , int printer , int power ) : PoweredDevice ( power ), // PoweredDevice \u5728\u8fd9\u91cc\u8fdb\u884c\u6784\u9020 Scanner ( scanner , power ), Printer ( printer , power ) { } }; \u8fd8\u662f\u7528\u524d\u9762\u7684\u4f8b\u5b50 int main () { Copier copier ( 1 , 2 , 3 ); return 0 ; } \u4ea7\u751f\u7ed3\u679c PoweredDevice: 3 Scanner: 1 Printer: 2 \u5982\u60a8\u6240\u89c1\uff0cPoweredDevice\u53ea\u6784\u5efa\u4e00\u6b21\u3002 \u6709\u4e00\u4e9b\u7ec6\u8282\uff0c\u5982\u679c\u6211\u4eec\u6211\u4eec\u5fc5\u987b\u8981\u8bf4\u660e \u9996\u5148\uff1a \u865a\u57fa\u7c7b\u603b\u662f\u5728\u975e\u865a\u57fa\u7c7b\u4e4b\u524d\u521b\u5efa\uff0c\u8fd9\u786e\u4fdd\u6240\u6709\u57fa\u7c7b\u5728\u6d3e\u751f\u7c7b\u4e4b\u524d\u521b\u5efa\u3002 \u5176\u6b21\uff1a \u8bf7\u6ce8\u610f Scanner \u548c Printer \u6784\u9020\u51fd\u6570\u4ecd\u6709\u8c03\u7528 PoweredDevice \u7684\u6784\u9020\u51fd\u6570\u3002\u521b\u5efa Copier \u5b9e\u4f8b\u65f6\uff0c\u8fd9\u4e9b\u6784\u9020\u51fd\u6570\u8c03\u7528\u88ab\u5ffd\u7565\uff0c\u56e0\u4e3a Copier \u8d1f\u8d23\u521b\u5efa PoweredDevice \uff0c\u800c\u4e0d\u662f Scanner \u6216 Printer \u3002\u4f46\u662f\uff0c\u5982\u679c\u6211\u4eec\u8981\u521b\u5efa Scanner \u6216 Printer \u7684\u5b9e\u4f8b\uff0c\u90a3\u4e48\u8c03\u7528\u90a3\u4e9b\u6784\u9020\u51fd\u6570\uff0c\u5e76\u5e94\u7528\u5e38\u89c4\u7ee7\u627f\u89c4\u5219\u3002 \u7b2c\u4e09\uff1a \u5982\u679c\u4e00\u4e2a\u7c7b\u7ee7\u627f\u4e86\u4e00\u4e2a\u6216\u591a\u4e2a\u5177\u6709\u865a\u57fa\u7c7b\u7684\u7c7b\uff0c\u5219 \u672b\u7aef\u6d3e\u751f(most derived) \u7684\u7c7b\u8d1f\u8d23\u6784\u9020\u865a\u57fa\u7c7b\u3002\u5728\u672c\u4f8b\u4e2d\uff0cCopier \u7ee7\u627f Printer \u548c Scanner \uff0c\u5b83\u4eec\u90fd\u6709\u4e00\u4e2a PoweredDevice \u865a\u62df\u57fa\u7c7b\u3002Copier \u662f\u6700\u6d3e\u751f\u7684\u7c7b\uff0c\u8d1f\u8d23\u521b\u5efa PoweredDevice \u3002\u8bf7\u6ce8\u610f\uff0c\u5373\u4f7f\u5728\u5355\u4e00\u7ee7\u627f\u60c5\u51b5\u4e0b\u4e5f\u662f\u5982\u6b64\uff1a\u5982\u679c Copier \u662f\u4ece Printer \u5355\u72ec\u7ee7\u627f\u7684\uff0c\u800c Printer \u5b9e\u9645\u4e0a\u662f\u4ece PoweredDevice \u7ee7\u627f\u7684\uff0cCopier \u4ecd\u7136\u8d1f\u8d23\u521b\u5efa PoweredDevice \u3002 \u7b2c\u56db\uff1a \u7ee7\u627f\u4e00\u4e2a\u865a\u62df\u57fa\u7c7b\u7684\u6240\u6709\u7c7b\u90fd\u5c06\u6709\u4e00\u4e2a\u865a\u62df\u8868\uff0c\u5373\u4f7f\u5b83\u4eec\u901a\u5e38\u4e0d\u4f1a\u6709\uff0c\u5b9e\u4f8b\u5316\u7684\u5bf9\u8c61\u4f1a\u56e0\u4e3a\u8fd9\u4e2a\u6307\u9488\u589e\u52a0\u4e00\u4e9b\u5c3a\u5bf8\u3002 \u56e0\u4e3a Scanner \u548c Printer \u662f\u4ece PoweredDevice \u865a\u7ee7\u627f\u51fa\u6765\u7684\uff0c\u6240\u4ee5 \u53ea\u6709\u4e00\u4e2a PoweredDevice \u5b50\u5bf9\u8c61\u3002Scanner \u548c Printer \u90fd\u9700\u8981\u77e5\u9053\u5982\u4f55\u627e\u5230\u8fd9\u4e2a PoweredDevice \u5b50\u5bf9\u8c61\uff0c\u4ee5\u4fbf\u8bbf\u95ee\u5b83\u7684\u6210\u5458\uff08\u56e0\u4e3a\u6bd5\u7adf\uff0c\u5b83\u4eec\u662f\u4ece\u5b83\u6d3e\u751f\u7684\uff09\u3002\u8fd9\u901a\u5e38\u662f\u901a\u8fc7\u4e00\u4e9b\u865a\u8868\u6765\u5b9e\u73b0\u7684\uff08\u5b83\u5b9e\u9645\u4e0a\u5b58\u50a8\u4e86\u4ece\u6bcf\u4e2a\u5b50\u7c7b\u5230 PoweredDevice \u5b50\u5bf9\u8c61\u7684\u504f\u79fb\u91cf\uff09\u3002","title":"\u865a\u57fa\u7c7b (Virtual base classes)"},{"location":"12-virtual-functions/12.8-object-slicing/","text":"12.8 \u5bf9\u8c61\u5207\u5272 \u00b6 \u4ec0\u4e48\u662f\u5bf9\u8c61\u5207\u5272 \u00b6 \u8ba9\u6211\u4eec\u56de\u5230\u4e4b\u524d\u7684\u4e00\u4e2a\u4f8b\u5b50 class Base { protected : int m_value {}; public : Base ( int value ) : m_value { value } { } virtual const char * getName () const { return \"Base\" ; } int getValue () const { return m_value ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () const { return \"Derived\" ; } }; int main () { Derived derived { 5 }; std :: cout << \"derived is a \" << derived . getName () << \" and has value \" << derived . getValue () << '\\n' ; Base & ref { derived }; std :: cout << \"ref is a \" << ref . getName () << \" and has value \" << ref . getValue () << '\\n' ; Base * ptr { & derived }; std :: cout << \"ptr is a \" << ptr -> getName () << \" and has value \" << ptr -> getValue () << '\\n' ; return 0 ; } \u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0cref \u5f15\u7528\u548c ptr \u6307\u9488 \u6307\u5411\u4e86\u5177\u6709 Base \u90e8\u5206\u548c\u884d\u751f\u90e8\u5206\u7684\u5bf9\u8c61\u3002\u56e0\u4e3a ref \u548c ptr \u7684\u7c7b\u578b\u662f Base\uff0cref \u548c ptr \u53ea\u80fd\u770b\u5230(access)\u6d3e\u751f\u7684\u57fa\u90e8\u5206\u2014\u2014\u6d3e\u751f\u7684\u6d3e\u751f\u90e8\u5206\u4ecd\u7136\u5b58\u5728\uff0c\u4f46\u4e0d\u80fd\u901a\u8fc7 ref \u6216 ptr \u770b\u5230\u3002\u4f46\u662f\uff0c\u901a\u8fc7\u4f7f\u7528\u865a\u51fd\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u8bbf\u95ee\u51fd\u6570\u7684\u6700\u6d3e\u751f\u7248\u672c\u3002\u56e0\u6b64\uff0c\u4e0a\u8ff0\u7a0b\u5e8f\u6253\u5370\uff1a derived is a Derived and has value 5 ref is a Derived and has value 5 ptr is a Derived and has value 5 \u4f46\u662f\u5982\u679c\u4e0d\u8bbe\u7f6e\u5f15\u7528\u6216\u8005\u6307\u9488\uff0c\u6211\u4eec\u76f4\u63a5\u628a Derived \u5bf9\u8c61\u8d4b\u503c\u7ed9\u57fa Base \u5bf9\u8c61\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f int main () { Derived derived { 5 }; Base base { derived }; // what happens here? std :: cout << \"base is a \" << base . getName () << \" and has value \" << base . getValue () << '\\n' ; return 0 ; } \u8bb0\u4f4f\u6d3e\u751f\u5bf9\u8c61\u6709\u4e00\u4e2a\u57fa\u90e8\u5206\u548c\u4e00\u4e2a\u6d3e\u751f\u90e8\u5206\uff0c\u5f53\u6211\u4eec\u8d4b\u503cDerived\u5bf9\u8c61\u5230\u57fa\u5bf9\u8c61\uff0c\u53ea\u6709 Base \u90e8\u5206\u4f1a\u88ab\u590d\u5236\uff0cDerived \u90e8\u5206\u5219\u4e0d\u4f1a\u3002\u5728\u4e0a\u65b9\u7684\u4f8b\u5b50\u4e2d\uff0c\u57fa\u5bf9\u8c61\u63a5\u6536\u4e86\u4e00\u4e2a Derived \u5bf9\u8c61\u7684 Base \u90e8\u5206\u7684copy\uff0c\u4f46\u662f\u5ffd\u7565\u4e86 Derived \u90e8\u5206\u3002\u6d3e\u751f\u90e8\u5206\u88ab\u5207\u6389 (sliced off)\u4e86\u3002 \u56e0\u6b64\uff0c\u8fd9\u79cd\u5bf9\u6d3e\u751f\u5bf9\u8c61\u5230\u57fa\u5bf9\u8c61\u7684\u8d4b\u503c\u53eb\u505a\uff0c\u5bf9\u8c61\u5207\u5272\u3002 \u56e0\u4e3a Base \u6ca1\u6709\u5305\u542b Derived \u90e8\u5206\uff0c\u56e0\u6b64 base.getName() \u4f1a\u51b3\u5b9a\u8c03\u7528 Base::getName() \u3002 \u4ee5\u4e0a\u4f8b\u5b50\u4f1a\u6253\u5370\uff1a base is a Base and has value 5 \u7528\u7684\u4ed4\u7ec6\uff0c\u5207\u5272\u4f1a\u662f\u4e00\u79cd\u4f18\u79c0\u7684\u64cd\u4f5c\u3002\u7136\u800c\u82e5\u7c97\u5fc3\u4f7f\u7528\u4f1a\u917f\u6210\u5927\u7978\uff0c\u5207\u5272\u4f1a\u9020\u6210\u4e0d\u53ef\u9884\u6599\u7684\u7ed3\u679c\uff0c\u4ee5\u5f88\u591a\u4e0d\u540c\u7684\u65b9\u5f0f\uff0c\u8ba9\u6211\u4eec\u6765\u9a8c\u8bc1\u8fd9\u4e9b\u4f8b\u5b50\u3002 \u7cdf\u7cd5\u7684\u7528\u6cd5 \u00b6 Slicing and functions \u00b6 \u73b0\u5728\u4f60\u53ef\u80fd\u8ba4\u4e3a\u4e0a\u65b9\u7684\u4f8b\u5b50\u6709\u70b9\u8822\uff0c\u6bd5\u7adf\uff0c\u4e3a\u4ec0\u4e48\u4f1a\u50cf\u90a3\u6837\u628a\u6d3e\u751f\u7c7b\u8d4b\u503c\u5230\u57fa\u7c7b\u5462\uff1f\u4f60\u53ef\u80fd\u4e0d\u4f1a\u90a3\u4e48\u505a\uff0c\u7136\u800c\u5207\u5272\u5e38\u5e38\u610f\u5916\u7684\u53d1\u751f\uff0c\u5f53\u914d\u5408\u51fd\u6570\u98df\u7528\u65f6\u3002 \u601d\u8003\u4e0b\u9762\u7684\u51fd\u6570 void printName ( const Base base ) // note: base \u901a\u8fc7\u503c\u4f20\u53c2\uff0c\u800c\u4e0d\u662f\u5f15\u7528 { std :: cout << \"I am a \" << base . getName () << '\\n' ; } \u8fd9\u662f\u4e00\u4e2a\u76f8\u5f53\u7b80\u5355\u7684\u5e26\u6709\u5e38\u91cf\u57fa\u5bf9\u8c61\u53c2\u6570\uff0c\u5e76\u4e14\u901a\u8fc7\u503c\u4f20\u53c2\uff0c\u5982\u679c\u6211\u4eec\u50cf\u8fd9\u6837\u8c03\u7528\u8fd9\u4e2a\u51fd\u6570\uff1a int main () { Derived d { 5 }; printName ( d ); // oops, \u6ca1\u6709\u610f\u8bc6\u5230\u8fd9\u662f\u901a\u8fc7\u503c\u4f20\u53c2\u3002 return 0 ; } \u5f53\u4f60\u5199\u4e0b\u8fd9\u4e2a\u7a0b\u5e8f\u7684\u65f6\u5019\uff0c\u4f60\u53ef\u80fd\u6ca1\u610f\u8bc6\u5230 base \u662f\u4e00\u4e2a\u503c\u53c2\u6570\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a\u5f15\u7528\u3002\u56e0\u6b64\u5f53\u6211\u4eec\u8c03\u7528 printName(d) \u65f6\uff0c\u6211\u4eec\u4e5f\u8bb8\u4f1a\u671f\u5f85 base.getName() \u6765\u8c03\u7528\u865a\u51fd\u6570 getName() \u5e76\u4e14\u6253\u5370 \"I am a Derived\"\uff0c\u4f46\u662f\u90a3\u4e0d\u4f1a\u53d1\u751f\u3002\u76f8\u53cd\uff0cDerived \u7684\u5bf9\u8c61 d \u4f1a\u88ab\u5207\u5272\uff0c\u53ea\u6709 Base \u90e8\u5206\u88ab\u62f7\u8d1d\u4f5c\u4e3a base \u53c2\u6570\u3002\u5f53 base.getName() \u6267\u884c\u65f6\uff0c\u5c3d\u7ba1 getName() \u51fd\u6570\u662f\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u4f46\u662f\u8fd9\u4e2a\u5bf9\u8c61\u6ca1\u6709\u6d3e\u751f\u90e8\u5206\u6765\u89e3\u6790\uff0c\u56e0\u6b64\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u4f1a\u6253\u5370\u5982\u4e0b\uff1a I am a Base \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u663e\u800c\u6613\u89c1\u53d1\u751f\u4e86\u4ec0\u4e48\uff0c\u4f46\u662f\u5982\u679c\u4f60\u7684\u51fd\u6570\u5b9e\u9645\u4e0a\u6ca1\u6709\u6253\u5370\u4efb\u4f55\u8fd9\u6837\u7684\u8bc6\u522b\u4fe1\u606f\uff0c\u5dee\u9519\u5c06\u53d8\u5f97\u975e\u5e38\u6709\u6311\u6218\u3002 \u5f53\u7136\uff0c\u8fd9\u91cc\u53d1\u751f\u7684\u5207\u5272\uff0c\u53ef\u4ee5\u5f88\u5bb9\u6613\u7684\u901a\u8fc7\u8bbe\u7f6e\u51fd\u6570\u53c2\u6570\u4e3a\u5f15\u7528\u6765\u907f\u514d\uff0c\u800c\u4e0d\u662f\u4f20\u503c\u3002\uff08\u53e6\u4e00\u4e2a\u539f\u56e0\u4e3a\u4ec0\u4e48\u5efa\u8bae\u4f20\u5f15\u7528\u7684good idea\uff09\u3002 void printName ( const Base & base ) // note: base \u901a\u8fc7\u5f15\u7528\u4f20\u53c2 { std :: cout << \"I am a \" << base . getName () << '\\n' ; } int main () { Derived d { 5 }; printName ( d ); return 0 ; } \u8fd9\u5c06\u6253\u5370 I am a Derived \u5207\u5272Vector (Slicing vectors) \u00b6 Yet another area where new programmers run into trouble with slicing is trying to implement polymorphism with std::vector. Consider the following program: \u53e6\u4e00\u4e2a\u7a0b\u5e8f\u65b0\u624b\u5728\u4f7f\u7528 std::vector \u6765\u5b9e\u73b0\u591a\u6001\u6027\u65f6\u5e38\u5e38\u9047\u5230\u7684\u95ee\u9898\u662f\u3002\u601d\u8003\u4e0b\u5217\u7a0b\u5e8f\uff1a #include <vector> int main () { std :: vector < Base > v {}; v . push_back ( Base { 5 }); // \u6dfb\u52a0\u4e00\u4e2a Base \u5bf9\u8c61\u5230vector v . push_back ( Derived { 6 }); // \u6dfb\u52a0\u4e00\u4e2a Derived \u5bf9\u8c61\u5230vector // \u6253\u5370\u6240\u6709vector\u4e2d\u7684\u5bf9\u8c61 for ( const auto & element : v ) std :: cout << \"I am a \" << element . getName () << \" with value \" << element . getValue () << '\\n' ; return 0 ; } \u7a0b\u5e8f\u7f16\u8bd1\u6ca1\u95ee\u9898\uff0c\u4f1a\u6253\u5370\uff1a I am a Base with value 5 I am a Base with value 6 \u548c\u4e4b\u524d\u7684\u4f8b\u5b50\u76f8\u4f3c\uff0c\u56e0\u4e3a std::vector \u88ab\u58f0\u660e\u4e3a Base \u7c7b\u578b\uff0c\u5f53 Derived(6) \u6dfb\u52a0\u5230vector\u65f6\uff0c\u5b83\u5df2\u7ecf\u88ab\u5207\u5272\u4e86\u3002 \u4fee\u590d\u8fd9\u4e2a\u95ee\u9898\u6709\u4e00\u4e9b\u56f0\u96be\uff0c\u5f88\u591a\u65b0\u624b\u7a0b\u5e8f\u5458\u5c1d\u8bd5\u521b\u5efa\u4e00\u4e2a \u5f15\u7528\u7c7b\u578b\u7684 std::vector \u50cf\u8fd9\u6837\u3002 std :: vector < Base &> v {}; \u4e0d\u5e78\u7684\u662f\uff0c\u8fd9\u5c06\u4e0d\u4f1a\u7f16\u8bd1\uff0c std::vector \u7684\u5bf9\u8c61\u5fc5\u987b\u662f\u53ef\u8d4b\u503c\u7684\uff0c\u7136\u800c\u5f15\u7528\u4e0d\u80fd\u88ab\u8d4b\u503c\uff08\u53ea\u6709\u5728\u521d\u59cb\u5316\u65f6\u5f15\u7528\u80fd\u88ab\u8d4b\u503c\uff09 \u89e3\u51b3\u8fd9\u4e2a\u8fd9\u4e2a\u95ee\u9898\u7684\u4e00\u4e2a\u65b9\u5f0f\u5c31\u662f\u521b\u5efa\u6307\u9488\u7c7b\u578b\u7684 std::vector # include <iostream> # include <vector> int main () { std :: vector < Base *> v {}; Base b { 5 }; // b and d \u4e0d\u80fd\u662f\u533f\u540d\u5bf9\u8c61\uff0c\u5fc5\u987b\u5148\u5b9e\u4f8b\u5316\u51fa\u6765 Derived d { 6 }; v . push_back ( & b ); // \u6dfb\u52a0\u4e00\u4e2a Base \u5bf9\u8c61\u5230 vector v . push_back ( & d ); // \u6dfb\u52a0\u4e00\u4e2a Derived \u5bf9\u8c61\u5230 vector // \u6253\u5370\u6240\u6709 for ( const auto * element : v ) std :: cout << \"I am a \" << element -> getName () << \" with value \" << element -> getValue () << '\\n' ; return 0 ; } \u8fd9\u4f1a\u6253\u5370\uff1a I am a Base with value 5 I am a Derived with value 6 \u5b83\u5de5\u4f5c\u4e86\uff01\u8fd9\u91cc\u8bf4\u4e00\u4e9b\u5173\u4e8e\u8fd9\u4e2a\u4f8b\u5b50\u7684\u4e00\u4e9b\u8bf4\u660e\uff0c \u7b2c\u4e00 \uff0cnullpter \u73b0\u5728\u662f\u4e00\u4e2a\u5408\u6cd5\u7684\u9009\u9879\uff0c\u4e5f\u8bb8\u6216\u4e5f\u8bb8\u4e0d\u5408\u4f60\u7684\u4f7f\u7528\u573a\u666f\u3002 \u7b2c\u4e8c \uff0c\u4f60\u73b0\u5728\u4e0d\u5f97\u4e0d\u8fdb\u884c\u6307\u9488\u64cd\u4f5c\uff0c\u53ef\u80fd\u662f\u7b28\u91cd(awkward)\u7684\u3002\u4f46\u662f\u4ece\u597d\u7684\u65b9\u9762\u6765\u8bf4\uff0c\u8fd9\u4e5f\u5141\u8bb8\u52a8\u6001\u5206\u914d\u5185\u5b58\u7684\u53ef\u80fd\u6027\uff0c\u5982\u679c\u4f60\u7684\u5bf9\u8c61\u8d85\u51fa\u8303\u56f4\u90a3\u5c06\u662f\u975e\u5e38\u6709\u7528\u7684\u3002(But on the upside, this also allows the possibility of dynamic memory allocation, which is useful if your objects might otherwise go out of scope.) The Frankenobject \u00b6 \u5728\u4e0a\u65b9\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u770b\u5230\u4e86\u5bf9\u8c61\u5207\u5272\u7531\u4e8e\u6d3e\u751f\u7c7b\u90e8\u5206\u88ab\u5207\u9664\u9020\u6210\u7684\u4e00\u4e9b\u5751\u3002\u73b0\u5728\u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u5f53\u6d3e\u751f\u5bf9\u8c61\u4ecd\u7136\u5b58\u5728\u7684\u53e6\u4e00\u4e2a\u5371\u9669\u60c5\u51b5\uff01 \u601d\u8003\u5982\u4e0b\u4ee3\u7801\uff1a int main () { Derived d1 { 5 }; Derived d2 { 6 }; Base & b { d2 }; b = d1 ; // \u8fd9\u884c\u5c31\u662f\u95ee\u9898\u6240\u5728 return 0 ; } \u5f00\u59cb\u4e09\u884c\u5f88\u7b80\u5355\u76f4\u63a5\uff0c\u521b\u5efa\u4e24\u4e2a\u5bf9\u8c61\uff0c\u5e76\u4e14\u521b\u5efa\u4e00\u4e2a\u5f15\u7528\u5230 d2 \u7b2c\u56db\u884c\u5c31\u662f\u5bfc\u81f4\u9519\u8bef\u7684\u4e00\u884c\uff0c\u5f53 b \u6307\u5411 d2 \u65f6\uff0c\u6211\u4eec\u8d4b\u503c d1 \u7ed9 b , \u4f60\u53ef\u80fd\u8ba4\u4e3a\u7ed3\u679c\u5c31\u662f d1 \u88ab\u62f7\u8d1d\u5230\u4e86d2 \u2014\u2014 \u5982\u679c b \u662f \u4e00\u4e2aDerived \u5bf9\u8c61\uff0c\u90a3\u4e48\u7ed3\u679c\u662f\u8fd9\u6837\u7684\u3002\u4f46\u662f b \u662f\u4e00\u4e2a Base \u5bf9\u8c61\uff0c\u5e76\u4e14 c++ \u63d0\u4f9b\u7684\u64cd\u4f5c\u7b26 = \u5e76\u4e0d\u662f\u865a\u51fd\u6570\u3002\u56e0\u6b64\uff0c\u53ea\u6709 d1 \u7684Base \u90e8\u5206\u88ab\u62f7\u8d1d\u5230\u4e86 d2 \u3002 \u7ed3\u679c\uff0c\u4f60\u4f1a\u53d1\u73b0 d2 \u73b0\u5728\u6709 d1 \u7684 Base \u90e8\u5206\u548c d2 \u7684 Derived \u90e8\u5206\u3002\u5728\u8fd9\u4e2a\u7279\u5b9a\u7684\u4f8b\u5b50\u4e2d\uff0c\u51fa\u73b0\u8fd9\u4e2a\u60c5\u51b5\u5e76\u6ca1\u6709\u95ee\u9898\u3002\uff08\u56e0\u4e3a Derived \u7c7b\u5e76\u6ca1\u6709\u5b83\u81ea\u5df1\u7684\u6570\u636e\uff09\uff0c\u4f46\u662f\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u4f60\u5c06\u4f1a\u521b\u5efa\u4e00\u4e2a Frankenobject \u2014\u2014 \u7531\u591a\u4e2a\u4e0d\u540c\u7684\u5bf9\u8c61\u7684\u4e0d\u540c\u90e8\u5206\u7ec4\u6210\u7684\u5bf9\u8c61\u3002\u66f4\u7cdf\u7cd5\u7684\u662f\uff0c\u6ca1\u6709\u5bb9\u6613\u7684\u65b9\u6cd5\u6765\u963b\u6b62\u8fd9\u4e2a\u60c5\u51b5\u7684\u53d1\u751f\u3002\uff08\u9664\u4e86\u5c3d\u53ef\u80fd\u907f\u514d\u50cf\u8fd9\u6837\u7684\u8d4b\u503c\u64cd\u4f5c\uff09 \u7ed3\u8bba \u00b6 \u5c3d\u7ba1 C++ \u652f\u6301\u5c06 base \u5bf9\u8c61\u8d4b\u503c\u7ed9 derived \u5bf9\u8c61\uff0c\u901a\u8fc7\u5bf9\u8c61\u5207\u5272\uff0c\u4f46\u662f\u901a\u5e38\u8fd9\u5f88\u53ef\u80fd\u4f1a\u6ca1\u5565\u5e2e\u52a9\uff0c\u9664\u4e86\u8ba9\u4f60\u5934\u75bc\u4e4b\u5916\uff0c\u4f60\u5e73\u65f6\u5e94\u8be5\u907f\u514d\u5bf9\u8c61\u5207\u5272\u7684\u53d1\u751f\u3002\u786e\u4fdd\u4f60\u7684\u51fd\u6570\u53c2\u6570\u662f\u5f15\u7528\uff08\u6216\u6307\u9488\uff09\u5e76\u4e14\u5c1d\u8bd5\u907f\u514d\u4efb\u4f55\u7c7b\u578b\u7684\u503c\u4f20\u53c2\uff0c\u5f53\u4f7f\u7528\u6d3e\u751f\u7c7b\u7684\u65f6\u5019\u3002","title":"12.8 \u5bf9\u8c61\u5207\u5272"},{"location":"12-virtual-functions/12.8-object-slicing/#128","text":"","title":"12.8 \u5bf9\u8c61\u5207\u5272"},{"location":"12-virtual-functions/12.8-object-slicing/#_1","text":"\u8ba9\u6211\u4eec\u56de\u5230\u4e4b\u524d\u7684\u4e00\u4e2a\u4f8b\u5b50 class Base { protected : int m_value {}; public : Base ( int value ) : m_value { value } { } virtual const char * getName () const { return \"Base\" ; } int getValue () const { return m_value ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () const { return \"Derived\" ; } }; int main () { Derived derived { 5 }; std :: cout << \"derived is a \" << derived . getName () << \" and has value \" << derived . getValue () << '\\n' ; Base & ref { derived }; std :: cout << \"ref is a \" << ref . getName () << \" and has value \" << ref . getValue () << '\\n' ; Base * ptr { & derived }; std :: cout << \"ptr is a \" << ptr -> getName () << \" and has value \" << ptr -> getValue () << '\\n' ; return 0 ; } \u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0cref \u5f15\u7528\u548c ptr \u6307\u9488 \u6307\u5411\u4e86\u5177\u6709 Base \u90e8\u5206\u548c\u884d\u751f\u90e8\u5206\u7684\u5bf9\u8c61\u3002\u56e0\u4e3a ref \u548c ptr \u7684\u7c7b\u578b\u662f Base\uff0cref \u548c ptr \u53ea\u80fd\u770b\u5230(access)\u6d3e\u751f\u7684\u57fa\u90e8\u5206\u2014\u2014\u6d3e\u751f\u7684\u6d3e\u751f\u90e8\u5206\u4ecd\u7136\u5b58\u5728\uff0c\u4f46\u4e0d\u80fd\u901a\u8fc7 ref \u6216 ptr \u770b\u5230\u3002\u4f46\u662f\uff0c\u901a\u8fc7\u4f7f\u7528\u865a\u51fd\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u8bbf\u95ee\u51fd\u6570\u7684\u6700\u6d3e\u751f\u7248\u672c\u3002\u56e0\u6b64\uff0c\u4e0a\u8ff0\u7a0b\u5e8f\u6253\u5370\uff1a derived is a Derived and has value 5 ref is a Derived and has value 5 ptr is a Derived and has value 5 \u4f46\u662f\u5982\u679c\u4e0d\u8bbe\u7f6e\u5f15\u7528\u6216\u8005\u6307\u9488\uff0c\u6211\u4eec\u76f4\u63a5\u628a Derived \u5bf9\u8c61\u8d4b\u503c\u7ed9\u57fa Base \u5bf9\u8c61\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f int main () { Derived derived { 5 }; Base base { derived }; // what happens here? std :: cout << \"base is a \" << base . getName () << \" and has value \" << base . getValue () << '\\n' ; return 0 ; } \u8bb0\u4f4f\u6d3e\u751f\u5bf9\u8c61\u6709\u4e00\u4e2a\u57fa\u90e8\u5206\u548c\u4e00\u4e2a\u6d3e\u751f\u90e8\u5206\uff0c\u5f53\u6211\u4eec\u8d4b\u503cDerived\u5bf9\u8c61\u5230\u57fa\u5bf9\u8c61\uff0c\u53ea\u6709 Base \u90e8\u5206\u4f1a\u88ab\u590d\u5236\uff0cDerived \u90e8\u5206\u5219\u4e0d\u4f1a\u3002\u5728\u4e0a\u65b9\u7684\u4f8b\u5b50\u4e2d\uff0c\u57fa\u5bf9\u8c61\u63a5\u6536\u4e86\u4e00\u4e2a Derived \u5bf9\u8c61\u7684 Base \u90e8\u5206\u7684copy\uff0c\u4f46\u662f\u5ffd\u7565\u4e86 Derived \u90e8\u5206\u3002\u6d3e\u751f\u90e8\u5206\u88ab\u5207\u6389 (sliced off)\u4e86\u3002 \u56e0\u6b64\uff0c\u8fd9\u79cd\u5bf9\u6d3e\u751f\u5bf9\u8c61\u5230\u57fa\u5bf9\u8c61\u7684\u8d4b\u503c\u53eb\u505a\uff0c\u5bf9\u8c61\u5207\u5272\u3002 \u56e0\u4e3a Base \u6ca1\u6709\u5305\u542b Derived \u90e8\u5206\uff0c\u56e0\u6b64 base.getName() \u4f1a\u51b3\u5b9a\u8c03\u7528 Base::getName() \u3002 \u4ee5\u4e0a\u4f8b\u5b50\u4f1a\u6253\u5370\uff1a base is a Base and has value 5 \u7528\u7684\u4ed4\u7ec6\uff0c\u5207\u5272\u4f1a\u662f\u4e00\u79cd\u4f18\u79c0\u7684\u64cd\u4f5c\u3002\u7136\u800c\u82e5\u7c97\u5fc3\u4f7f\u7528\u4f1a\u917f\u6210\u5927\u7978\uff0c\u5207\u5272\u4f1a\u9020\u6210\u4e0d\u53ef\u9884\u6599\u7684\u7ed3\u679c\uff0c\u4ee5\u5f88\u591a\u4e0d\u540c\u7684\u65b9\u5f0f\uff0c\u8ba9\u6211\u4eec\u6765\u9a8c\u8bc1\u8fd9\u4e9b\u4f8b\u5b50\u3002","title":"\u4ec0\u4e48\u662f\u5bf9\u8c61\u5207\u5272"},{"location":"12-virtual-functions/12.8-object-slicing/#_2","text":"","title":"\u7cdf\u7cd5\u7684\u7528\u6cd5"},{"location":"12-virtual-functions/12.8-object-slicing/#slicing-and-functions","text":"\u73b0\u5728\u4f60\u53ef\u80fd\u8ba4\u4e3a\u4e0a\u65b9\u7684\u4f8b\u5b50\u6709\u70b9\u8822\uff0c\u6bd5\u7adf\uff0c\u4e3a\u4ec0\u4e48\u4f1a\u50cf\u90a3\u6837\u628a\u6d3e\u751f\u7c7b\u8d4b\u503c\u5230\u57fa\u7c7b\u5462\uff1f\u4f60\u53ef\u80fd\u4e0d\u4f1a\u90a3\u4e48\u505a\uff0c\u7136\u800c\u5207\u5272\u5e38\u5e38\u610f\u5916\u7684\u53d1\u751f\uff0c\u5f53\u914d\u5408\u51fd\u6570\u98df\u7528\u65f6\u3002 \u601d\u8003\u4e0b\u9762\u7684\u51fd\u6570 void printName ( const Base base ) // note: base \u901a\u8fc7\u503c\u4f20\u53c2\uff0c\u800c\u4e0d\u662f\u5f15\u7528 { std :: cout << \"I am a \" << base . getName () << '\\n' ; } \u8fd9\u662f\u4e00\u4e2a\u76f8\u5f53\u7b80\u5355\u7684\u5e26\u6709\u5e38\u91cf\u57fa\u5bf9\u8c61\u53c2\u6570\uff0c\u5e76\u4e14\u901a\u8fc7\u503c\u4f20\u53c2\uff0c\u5982\u679c\u6211\u4eec\u50cf\u8fd9\u6837\u8c03\u7528\u8fd9\u4e2a\u51fd\u6570\uff1a int main () { Derived d { 5 }; printName ( d ); // oops, \u6ca1\u6709\u610f\u8bc6\u5230\u8fd9\u662f\u901a\u8fc7\u503c\u4f20\u53c2\u3002 return 0 ; } \u5f53\u4f60\u5199\u4e0b\u8fd9\u4e2a\u7a0b\u5e8f\u7684\u65f6\u5019\uff0c\u4f60\u53ef\u80fd\u6ca1\u610f\u8bc6\u5230 base \u662f\u4e00\u4e2a\u503c\u53c2\u6570\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a\u5f15\u7528\u3002\u56e0\u6b64\u5f53\u6211\u4eec\u8c03\u7528 printName(d) \u65f6\uff0c\u6211\u4eec\u4e5f\u8bb8\u4f1a\u671f\u5f85 base.getName() \u6765\u8c03\u7528\u865a\u51fd\u6570 getName() \u5e76\u4e14\u6253\u5370 \"I am a Derived\"\uff0c\u4f46\u662f\u90a3\u4e0d\u4f1a\u53d1\u751f\u3002\u76f8\u53cd\uff0cDerived \u7684\u5bf9\u8c61 d \u4f1a\u88ab\u5207\u5272\uff0c\u53ea\u6709 Base \u90e8\u5206\u88ab\u62f7\u8d1d\u4f5c\u4e3a base \u53c2\u6570\u3002\u5f53 base.getName() \u6267\u884c\u65f6\uff0c\u5c3d\u7ba1 getName() \u51fd\u6570\u662f\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u4f46\u662f\u8fd9\u4e2a\u5bf9\u8c61\u6ca1\u6709\u6d3e\u751f\u90e8\u5206\u6765\u89e3\u6790\uff0c\u56e0\u6b64\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u4f1a\u6253\u5370\u5982\u4e0b\uff1a I am a Base \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u663e\u800c\u6613\u89c1\u53d1\u751f\u4e86\u4ec0\u4e48\uff0c\u4f46\u662f\u5982\u679c\u4f60\u7684\u51fd\u6570\u5b9e\u9645\u4e0a\u6ca1\u6709\u6253\u5370\u4efb\u4f55\u8fd9\u6837\u7684\u8bc6\u522b\u4fe1\u606f\uff0c\u5dee\u9519\u5c06\u53d8\u5f97\u975e\u5e38\u6709\u6311\u6218\u3002 \u5f53\u7136\uff0c\u8fd9\u91cc\u53d1\u751f\u7684\u5207\u5272\uff0c\u53ef\u4ee5\u5f88\u5bb9\u6613\u7684\u901a\u8fc7\u8bbe\u7f6e\u51fd\u6570\u53c2\u6570\u4e3a\u5f15\u7528\u6765\u907f\u514d\uff0c\u800c\u4e0d\u662f\u4f20\u503c\u3002\uff08\u53e6\u4e00\u4e2a\u539f\u56e0\u4e3a\u4ec0\u4e48\u5efa\u8bae\u4f20\u5f15\u7528\u7684good idea\uff09\u3002 void printName ( const Base & base ) // note: base \u901a\u8fc7\u5f15\u7528\u4f20\u53c2 { std :: cout << \"I am a \" << base . getName () << '\\n' ; } int main () { Derived d { 5 }; printName ( d ); return 0 ; } \u8fd9\u5c06\u6253\u5370 I am a Derived","title":"Slicing and functions"},{"location":"12-virtual-functions/12.8-object-slicing/#vector-slicing-vectors","text":"Yet another area where new programmers run into trouble with slicing is trying to implement polymorphism with std::vector. Consider the following program: \u53e6\u4e00\u4e2a\u7a0b\u5e8f\u65b0\u624b\u5728\u4f7f\u7528 std::vector \u6765\u5b9e\u73b0\u591a\u6001\u6027\u65f6\u5e38\u5e38\u9047\u5230\u7684\u95ee\u9898\u662f\u3002\u601d\u8003\u4e0b\u5217\u7a0b\u5e8f\uff1a #include <vector> int main () { std :: vector < Base > v {}; v . push_back ( Base { 5 }); // \u6dfb\u52a0\u4e00\u4e2a Base \u5bf9\u8c61\u5230vector v . push_back ( Derived { 6 }); // \u6dfb\u52a0\u4e00\u4e2a Derived \u5bf9\u8c61\u5230vector // \u6253\u5370\u6240\u6709vector\u4e2d\u7684\u5bf9\u8c61 for ( const auto & element : v ) std :: cout << \"I am a \" << element . getName () << \" with value \" << element . getValue () << '\\n' ; return 0 ; } \u7a0b\u5e8f\u7f16\u8bd1\u6ca1\u95ee\u9898\uff0c\u4f1a\u6253\u5370\uff1a I am a Base with value 5 I am a Base with value 6 \u548c\u4e4b\u524d\u7684\u4f8b\u5b50\u76f8\u4f3c\uff0c\u56e0\u4e3a std::vector \u88ab\u58f0\u660e\u4e3a Base \u7c7b\u578b\uff0c\u5f53 Derived(6) \u6dfb\u52a0\u5230vector\u65f6\uff0c\u5b83\u5df2\u7ecf\u88ab\u5207\u5272\u4e86\u3002 \u4fee\u590d\u8fd9\u4e2a\u95ee\u9898\u6709\u4e00\u4e9b\u56f0\u96be\uff0c\u5f88\u591a\u65b0\u624b\u7a0b\u5e8f\u5458\u5c1d\u8bd5\u521b\u5efa\u4e00\u4e2a \u5f15\u7528\u7c7b\u578b\u7684 std::vector \u50cf\u8fd9\u6837\u3002 std :: vector < Base &> v {}; \u4e0d\u5e78\u7684\u662f\uff0c\u8fd9\u5c06\u4e0d\u4f1a\u7f16\u8bd1\uff0c std::vector \u7684\u5bf9\u8c61\u5fc5\u987b\u662f\u53ef\u8d4b\u503c\u7684\uff0c\u7136\u800c\u5f15\u7528\u4e0d\u80fd\u88ab\u8d4b\u503c\uff08\u53ea\u6709\u5728\u521d\u59cb\u5316\u65f6\u5f15\u7528\u80fd\u88ab\u8d4b\u503c\uff09 \u89e3\u51b3\u8fd9\u4e2a\u8fd9\u4e2a\u95ee\u9898\u7684\u4e00\u4e2a\u65b9\u5f0f\u5c31\u662f\u521b\u5efa\u6307\u9488\u7c7b\u578b\u7684 std::vector # include <iostream> # include <vector> int main () { std :: vector < Base *> v {}; Base b { 5 }; // b and d \u4e0d\u80fd\u662f\u533f\u540d\u5bf9\u8c61\uff0c\u5fc5\u987b\u5148\u5b9e\u4f8b\u5316\u51fa\u6765 Derived d { 6 }; v . push_back ( & b ); // \u6dfb\u52a0\u4e00\u4e2a Base \u5bf9\u8c61\u5230 vector v . push_back ( & d ); // \u6dfb\u52a0\u4e00\u4e2a Derived \u5bf9\u8c61\u5230 vector // \u6253\u5370\u6240\u6709 for ( const auto * element : v ) std :: cout << \"I am a \" << element -> getName () << \" with value \" << element -> getValue () << '\\n' ; return 0 ; } \u8fd9\u4f1a\u6253\u5370\uff1a I am a Base with value 5 I am a Derived with value 6 \u5b83\u5de5\u4f5c\u4e86\uff01\u8fd9\u91cc\u8bf4\u4e00\u4e9b\u5173\u4e8e\u8fd9\u4e2a\u4f8b\u5b50\u7684\u4e00\u4e9b\u8bf4\u660e\uff0c \u7b2c\u4e00 \uff0cnullpter \u73b0\u5728\u662f\u4e00\u4e2a\u5408\u6cd5\u7684\u9009\u9879\uff0c\u4e5f\u8bb8\u6216\u4e5f\u8bb8\u4e0d\u5408\u4f60\u7684\u4f7f\u7528\u573a\u666f\u3002 \u7b2c\u4e8c \uff0c\u4f60\u73b0\u5728\u4e0d\u5f97\u4e0d\u8fdb\u884c\u6307\u9488\u64cd\u4f5c\uff0c\u53ef\u80fd\u662f\u7b28\u91cd(awkward)\u7684\u3002\u4f46\u662f\u4ece\u597d\u7684\u65b9\u9762\u6765\u8bf4\uff0c\u8fd9\u4e5f\u5141\u8bb8\u52a8\u6001\u5206\u914d\u5185\u5b58\u7684\u53ef\u80fd\u6027\uff0c\u5982\u679c\u4f60\u7684\u5bf9\u8c61\u8d85\u51fa\u8303\u56f4\u90a3\u5c06\u662f\u975e\u5e38\u6709\u7528\u7684\u3002(But on the upside, this also allows the possibility of dynamic memory allocation, which is useful if your objects might otherwise go out of scope.)","title":"\u5207\u5272Vector (Slicing vectors)"},{"location":"12-virtual-functions/12.8-object-slicing/#the-frankenobject","text":"\u5728\u4e0a\u65b9\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u770b\u5230\u4e86\u5bf9\u8c61\u5207\u5272\u7531\u4e8e\u6d3e\u751f\u7c7b\u90e8\u5206\u88ab\u5207\u9664\u9020\u6210\u7684\u4e00\u4e9b\u5751\u3002\u73b0\u5728\u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u5f53\u6d3e\u751f\u5bf9\u8c61\u4ecd\u7136\u5b58\u5728\u7684\u53e6\u4e00\u4e2a\u5371\u9669\u60c5\u51b5\uff01 \u601d\u8003\u5982\u4e0b\u4ee3\u7801\uff1a int main () { Derived d1 { 5 }; Derived d2 { 6 }; Base & b { d2 }; b = d1 ; // \u8fd9\u884c\u5c31\u662f\u95ee\u9898\u6240\u5728 return 0 ; } \u5f00\u59cb\u4e09\u884c\u5f88\u7b80\u5355\u76f4\u63a5\uff0c\u521b\u5efa\u4e24\u4e2a\u5bf9\u8c61\uff0c\u5e76\u4e14\u521b\u5efa\u4e00\u4e2a\u5f15\u7528\u5230 d2 \u7b2c\u56db\u884c\u5c31\u662f\u5bfc\u81f4\u9519\u8bef\u7684\u4e00\u884c\uff0c\u5f53 b \u6307\u5411 d2 \u65f6\uff0c\u6211\u4eec\u8d4b\u503c d1 \u7ed9 b , \u4f60\u53ef\u80fd\u8ba4\u4e3a\u7ed3\u679c\u5c31\u662f d1 \u88ab\u62f7\u8d1d\u5230\u4e86d2 \u2014\u2014 \u5982\u679c b \u662f \u4e00\u4e2aDerived \u5bf9\u8c61\uff0c\u90a3\u4e48\u7ed3\u679c\u662f\u8fd9\u6837\u7684\u3002\u4f46\u662f b \u662f\u4e00\u4e2a Base \u5bf9\u8c61\uff0c\u5e76\u4e14 c++ \u63d0\u4f9b\u7684\u64cd\u4f5c\u7b26 = \u5e76\u4e0d\u662f\u865a\u51fd\u6570\u3002\u56e0\u6b64\uff0c\u53ea\u6709 d1 \u7684Base \u90e8\u5206\u88ab\u62f7\u8d1d\u5230\u4e86 d2 \u3002 \u7ed3\u679c\uff0c\u4f60\u4f1a\u53d1\u73b0 d2 \u73b0\u5728\u6709 d1 \u7684 Base \u90e8\u5206\u548c d2 \u7684 Derived \u90e8\u5206\u3002\u5728\u8fd9\u4e2a\u7279\u5b9a\u7684\u4f8b\u5b50\u4e2d\uff0c\u51fa\u73b0\u8fd9\u4e2a\u60c5\u51b5\u5e76\u6ca1\u6709\u95ee\u9898\u3002\uff08\u56e0\u4e3a Derived \u7c7b\u5e76\u6ca1\u6709\u5b83\u81ea\u5df1\u7684\u6570\u636e\uff09\uff0c\u4f46\u662f\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u4f60\u5c06\u4f1a\u521b\u5efa\u4e00\u4e2a Frankenobject \u2014\u2014 \u7531\u591a\u4e2a\u4e0d\u540c\u7684\u5bf9\u8c61\u7684\u4e0d\u540c\u90e8\u5206\u7ec4\u6210\u7684\u5bf9\u8c61\u3002\u66f4\u7cdf\u7cd5\u7684\u662f\uff0c\u6ca1\u6709\u5bb9\u6613\u7684\u65b9\u6cd5\u6765\u963b\u6b62\u8fd9\u4e2a\u60c5\u51b5\u7684\u53d1\u751f\u3002\uff08\u9664\u4e86\u5c3d\u53ef\u80fd\u907f\u514d\u50cf\u8fd9\u6837\u7684\u8d4b\u503c\u64cd\u4f5c\uff09","title":"The Frankenobject"},{"location":"12-virtual-functions/12.8-object-slicing/#_3","text":"\u5c3d\u7ba1 C++ \u652f\u6301\u5c06 base \u5bf9\u8c61\u8d4b\u503c\u7ed9 derived \u5bf9\u8c61\uff0c\u901a\u8fc7\u5bf9\u8c61\u5207\u5272\uff0c\u4f46\u662f\u901a\u5e38\u8fd9\u5f88\u53ef\u80fd\u4f1a\u6ca1\u5565\u5e2e\u52a9\uff0c\u9664\u4e86\u8ba9\u4f60\u5934\u75bc\u4e4b\u5916\uff0c\u4f60\u5e73\u65f6\u5e94\u8be5\u907f\u514d\u5bf9\u8c61\u5207\u5272\u7684\u53d1\u751f\u3002\u786e\u4fdd\u4f60\u7684\u51fd\u6570\u53c2\u6570\u662f\u5f15\u7528\uff08\u6216\u6307\u9488\uff09\u5e76\u4e14\u5c1d\u8bd5\u907f\u514d\u4efb\u4f55\u7c7b\u578b\u7684\u503c\u4f20\u53c2\uff0c\u5f53\u4f7f\u7528\u6d3e\u751f\u7c7b\u7684\u65f6\u5019\u3002","title":"\u7ed3\u8bba"},{"location":"12-virtual-functions/12.9-dynamic-casting/","text":"12.9\u52a8\u6001\u7c7b\u578b\u8f6c\u6362 \u00b6 \u65e9\u5728 \u7b2c6.16\u8bfe\u2014\u2014\u663e\u5f0f\u7c7b\u578b\u8f6c\u6362\uff08casting\uff09\u548cstatic_cast \u4e2d\uff0c\u6211\u4eec\u7814\u7a76\u4e86 casting \u7684\u6982\u5ff5\uff0c\u4ee5\u53ca\u4f7f\u7528 static_cast \u5c06\u53d8\u91cf\u4ece\u4e00\u79cd\u7c7b\u578b\u8f6c\u6362\u4e3a\u53e6\u4e00\u79cd\u7c7b\u578b\u3002 \u5728\u672c\u8bfe\u4e2d\uff0c\u6211\u4eec\u5c06\u7ee7\u7eed\u7814\u7a76\u53e6\u4e00\u79cd\u7c7b\u578b\u7684\u5f3a\u5236\u8f6c\u6362\uff1a\u52a8\u6001\u7c7b\u578b\u8f6c\u6362 (Dynamic cast) \u4f55\u65f6\u9700\u8981\u8fdb\u884c\u52a8\u6001\u7c7b\u578b\u8f6c\u6362 \u00b6 \u5728\u5904\u7406\u591a\u6001\u6027\u65f6\uff0c\u60a8\u7ecf\u5e38\u4f1a\u9047\u5230\u8fd9\u6837\u7684\u60c5\u51b5\uff1a\u4f60\u6709\u4e00\u4e2a\u6307\u5411\u57fa\u7c7b\u7684\u6307\u9488\uff0c\u4f46\u4f60\u5e0c\u671b\u8bbf\u95ee\u4ec5\u5b58\u5728\u4e8e\u6d3e\u751f\u7c7b\u4e2d\u7684\u67d0\u4e9b\u4fe1\u606f\u3002 \u601d\u8003\u4e0b\u5217\u8fd9\u4e2a\uff08\u4e0d\u592a\u81ea\u7136\u7684\uff09\u4f8b\u5b50 # include <iostream> # include <string> class Base { protected : int m_value ; public : Base ( int value ) : m_value ( value ) { } virtual ~ Base () {} }; class Derived : public Base { protected : std :: string m_name ; public : Derived ( int value , std :: string name ) : Base ( value ), m_name ( name ) { } const std :: string & getName () const { return m_name ; } }; Base * getObject ( bool bReturnDerived ) { if ( bReturnDerived ) return new Derived ( 1 , \"Apple\" ); else return new Base ( 2 ); } int main () { Base * b = getObject ( true ); // \u6211\u4eec\u5e94\u8be5\u5982\u4f55\u6253\u5370\u6d3e\u751f\u7c7b\u5bf9\u8c61\u7684\u540d\u5b57\uff1f\u53ea\u6709\u57fa\u7c7b\u6307\u9488 delete b ; return 0 ; } \u5728\u8fd9\u4e2a\u7a0b\u5e8f\u4e2d\uff0c\u51fd\u6570 getObject() \u603b\u662f\u8fd4\u56de\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\uff0c\u4f46\u662f\u8fd9\u4e2a\u6307\u9488\u53ef\u80fd\u6307\u5411\u4e00\u4e2a\u57fa\u7c7b\u4e5f\u53ef\u80fd\u6307\u5411\u4e00\u4e2a\u6d3e\u751f\u7c7b\u3002\u5728\u4f8b\u5b50\u4e2d\u7684 Base \u6307\u9488 b \u5b9e\u9645\u6307\u5411\u7684\u662f\u6d3e\u751f\u7c7b\u7684\u5bf9\u8c61\uff0c\u6211\u4eec\u5e94\u8be5\u5982\u4f55\u8c03\u7528 Derived::getName() \uff1f \u4e00\u4e2a\u65b9\u6cd5\u4f1a\u662f\u6dfb\u52a0\u4e00\u4e2a\u865a\u51fd\u6570\u5230 Base \u7c7b\uff0c\u53eb getName() \uff08\u8fd9\u6837\u505a\u6211\u4eec\u53ef\u4ee5\u8c03\u7528\u5b83\uff0c\u901a\u8fc7 Base \u7684\u6307\u9488\u6216\u5f15\u7528\uff0c\u5b83\u90fd\u4f1a\u52a8\u6001\u5b9a\u5411\u5230 Derived::getName() \uff09\u3002\u4f46\u662f\u5982\u679c\u4f60\u8c03\u7528\u7684\u5bf9\u8c61\u662f\u4e00\u4e2a Base \u7c7b\u7684\u6307\u9488\u4f1a\u5f15\u7528\uff0c\u6307\u5411\u4e00\u4e2a Base \u5bf9\u8c61\uff0c\u90a3\u5c06\u4f1a\u8fd4\u56de\u4ec0\u4e48\uff1f\u6ca1\u6709\u4efb\u4f55\u503c\u771f\u6b63\u6709\u4ef7\u503c\u3002\u6b64\u5916\uff0c\u6211\u4eec\u5c06\u4f1a\u7528\u4e00\u4e9b\u4e1c\u897f\u6c61\u67d3\u6211\u4eec\u7684 Base \u7c7b\uff0c\u8fd9\u4e9b\u7684\u4e1c\u897f\u672c\u6765\u5e94\u8be5\u53ea\u5728\u6d3e\u751f\u7c7b\u4e2d\u5b58\u5728\u3002 \u6211\u4eec\u90fd\u77e5\u9053\uff0c C++ \u5c06\u4f1a\u9690\u5f0f\u7684\u8ba9\u4f60\u8f6c\u5316\u4e00\u4e2a\u6d3e\u751f\u7c7b\u6307\u9488\u4e3a\u4e00\u4e2a\u57fa\u7c7b\u6307\u6b63\u3002\uff08\u4e8b\u5b9e\u4e0a\uff0c getObjectt() \u5c31\u505a\u4e86\u90a3\u6837\u7684\u4e8b\u60c5\uff09\u3002\u8fd9\u79cd\u8fc7\u7a0b\u6709\u65f6\u5019\u88ab\u53eb\u505a\u5411\u4e0a\u8f6c\u5316\u3002\u7136\u800c\uff0c\u5982\u679c\u6709\u4e00\u4e2a\u65b9\u6cd5\u628a Base \u6307\u9488\u8f6c\u6362\u56de Derived \u6307\u9488\u4f1a\u600e\u4e48\u6837\uff1f\u7136\u540e\u6211\u4eec\u80fd\u591f\u76f4\u63a5\u901a\u8fc7\u90a3\u4e2a\u6307\u9488\u6765\u8c03\u7528 Derived::getName() \uff0c\u8fd9\u6837\u5c31\u6839\u672c\u4e0d\u7528\u5173\u5fc3\u865a\u51fd\u6570\u89e3\u6790\u3002 \u52a8\u6001\u7c7b\u578b\u8f6c\u5316 (Dynamic Cast) \u00b6 C++ \u63d0\u4f9b\u4e86\u4e00\u4e2a\u8f6c\u6362\u64cd\u4f5c\u7b26\uff0c\u53eb\u505a\u52a8\u6001\u8f6c\u5316\uff0c\u5c31\u53ef\u4ee5\u5728\u8fd9\u4e2a\u6761\u4ef6\u4e0b\u4f7f\u7528\u3002\u5c3d\u7ba1\u52a8\u6001\u8f6c\u5316\u6709\u5f88\u591a\u4e0d\u540c\u7684\u80fd\u529b\uff0c\u76ee\u524d\u4e3a\u6b62\u6211\u4eec\u6700\u5e38\u89c1\u7684\u4f7f\u7528\u573a\u666f\u5c31\u662f\u4e3a\u4e86\u8f6c\u5316\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\u6210\u4e00\u4e2a\u6d3e\u751f\u7c7b\u6307\u9488\u3002\u8fd9\u4e2a\u8fc7\u7a0b\u53eb\u505a\u5411\u4e0b\u7c7b\u578b\u8f6c\u6362\u3002 Using dynamic_cast works just like static_cast. Here\u2019s our example main() from above, using a dynamic_cast to convert our Base pointer back into a Derived pointer: \u52a8\u6001\u7c7b\u578b\u8f6c\u6362\u5c31\u50cf\u9759\u6001\u7c7b\u578b\u8f6c\u6362\u4e00\u6837\u3002\u8fd9\u662f\u6211\u4eec\u4e0a\u9762\u7684 main() \u51fd\u6570\u7684\u4f8b\u5b50\uff0c\u4f7f\u7528\u52a8\u6001\u7c7b\u578b\u8f6c\u5316\uff0c\u5c06 Base \u6307\u9488\u7c7b\u578b\u8f6c\u5316\u6210 Derived \u6307\u9488\u3002 int main () { Base * b = getObject ( true ); Derived * d = dynamic_cast < Derived *> ( b ); // use dynamic cast to convert Base pointer into Derived pointer std :: cout << \"The name of the Derived is: \" << d -> getName () << '\\n' ; delete b ; return 0 ; } \u8fd9\u4e2a\u7528\u4f8b\u6253\u5370\u51fa\uff1a The name of the Derived is: Apple \u52a8\u6001\u7c7b\u578b\u8f6c\u6362\u5931\u8d25 (Dynamic Cast Failure) \u00b6 \u4e0a\u9762\u7684\u4f8b\u5b50\u80fd\u8fd0\u884c\u56e0\u4e3a b \u786e\u5b9e\u6307\u5411\u4e86\u4e00\u4e2a Derived \u5bf9\u8c61\uff0c\u56e0\u6b64\u8f6c\u5316 b \u6210\u4e3a\u4e00\u4e2a\u6d3e\u751f\u6307\u9488\u4f1a\u6210\u529f\u3002 \u7136\u800c\uff0c\u6211\u4eec\u505a\u4e86\u4e00\u4e2a\u76f8\u5f53\u5371\u9669\u7684\u5047\u8bbe\uff1a\u90a3\u5c31\u662f b \u786e\u5b9e\u662f\u6307\u5411\u4e86\u6d3e\u751f\u7c7b\u3002\u5982\u679c b \u4e0d\u662f\u6307\u5411\u6d3e\u751f\u5bf9\u8c61\u7684\uff0c\u5c06\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u8fd9\u5f88\u5bb9\u6613\u9a8c\u8bc1\uff0c\u5c06 getObject() \u7684\u53c2\u6570\u4ece true \u6539\u4e3a false \u3002\u5728\u90a3\u4e2a\u4f8b\u5b50\u91cc\uff0c getObject() \u5c06\u4f1a\u8fd4\u56de\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\u6307\u5411\u4e00\u4e2a\u57fa\u7c7b\u5bf9\u8c61\u3002\u5f53\u6211\u4eec\u5c1d\u8bd5\u4f7f\u7528\u52a8\u6001\u8f6c\u6362 dynamic_cast \u8f6c\u5316\u6210\u4e00\u4e2a\u6d3e\u751f\u5bf9\u8c61\u7684\u65f6\u5019\uff0c\u5c06\u4f1a\u5931\u8d25\uff0c\u56e0\u4e3a\u8f6c\u5316\u4e0d\u53ef\u80fd\u6210\u529f\u3002 \u5982\u679c\u52a8\u6001\u8f6c\u5316\u5931\u8d25\uff0c\u8f6c\u5316\u7ed3\u679c\u4f1a\u662f\u4e00\u4e2a null \u6307\u9488\u3002 \u56e0\u4e3a\u6211\u4eec\u6ca1\u6709\u68c0\u67e5\u7ed3\u679c\u662f\u5426\u662f\u7a7a\u6307\u9488\uff0c\u6211\u4eec\u8bbf\u95ee d->getName() \uff0c\u5c06\u4f1a\u5c1d\u8bd5\u95f4\u5740\u4e00\u4e2a\u7a7a\u6307\u9488\uff0c\u5c06\u4f1a\u5bfc\u81f4\u4e00\u4e2a\u672a\u5b9a\u4e49\u7684\u64cd\u4f5c\uff0c\u53ef\u80fd\u4f1a\u9020\u6210\u5d29\u6e83\u3002 \u4e3a\u4e86\u8ba9\u8fd9\u4e2a\u7a0b\u5e8f\u5b89\u5168\u8fd0\u884c\uff0c\u6211\u4eec\u9700\u8981\u53bb\u786e\u8ba4\u52a8\u6001\u8f6c\u6362\u786e\u5b9e\u6210\u529f\u4e86\u3002 int main () { Base * b = getObject ( true ); Derived * d = dynamic_cast < Derived *> ( b ); // use dynamic cast to convert Base pointer into Derived pointer if ( d ){ // make sure d is non-null std :: cout << \"The name of the Derived is: \" << d -> getName () << '\\n' ; } delete b ; return 0 ; } \u89c4\u5219\uff1a \u603b\u662f\u901a\u8fc7\u68c0\u67e5\u7a7a\u6307\u9488\u6765\u786e\u4fdd\u7684\u52a8\u6001\u8f6c\u6362\u6210\u529f\u4e86\u3002 \u6ce8\u610f\u5230\u56e0\u4e3a\u52a8\u6001\u8f6c\u6362\u5728\u8fd0\u884c\u65f6\u505a\u4e86\u4e00\u4e9b\u4e00\u81f4\u6027(consisitency)\u68c0\u67e5\uff08\u6765\u786e\u4fdd\u8f6c\u6362\u662f\u53ef\u884c\u7684\uff09\uff0c\u4f7f\u7528\u52a8\u6001\u8f6c\u6362\u4f1a\u5f15\u8d77\u4e00\u4e9b\u6027\u80fd\u635f\u5931(performance penalty). \u4e5f\u8bf7\u6ce8\u610f\uff0c\u5728\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0c\u4f7f\u7528\u52a8\u6001\u8f6c\u6362 (dynamic_cast) \u8fdb\u884c\u5411\u4e0b\u8f6c\u6362 (downcasting)\u65f6\u5c06\u65e0\u6cd5\u5de5\u4f5c\uff1a 1\uff09\u4f7f\u7528 protected \u6216\u8005 private \u7ee7\u627f\u7684\u3002 2\uff09\u6ca1\u6709\u7533\u660e\u6216\u8005\u7ee7\u627f\u4efb\u4f55\u865a\u51fd\u6570\u7684\uff08\u5e76\u4e14\u56e0\u6b64\u6ca1\u6709\u865a\u8868\uff09\u3002 3\uff09\u5728\u7279\u5b9a\u7684\u4f8b\u5b50\u4e0b\u8bbe\u8ba1\u865a\u57fa\u7c7b\u7684\u8f6c\u5316\u3002\uff08\u770b\u8fd9\u9875\u7684\u4f8b\u5b50\u4e2d\u4f7f\u7528\u7684\u8fd9\u4e9b\u7c7b\uff0c\u548c\u5982\u4f55 resove \u4ed6\u4eec\uff09\u3002 \u4f7f\u7528\u9759\u6001\u7c7b\u578b\u8f6c\u6362\u8fdb\u884c\u5411\u4e0b\u8f6c\u5316 (Downcasting with static_cast) \u00b6 \u4e8b\u5b9e\u8bc1\u660e\uff0c\u5411\u4e0b\u8f6c\u6362\u4e5f\u53ef\u4ee5\u7531\u9759\u6001\u8f6c\u6362 static_cast \u6765\u5b8c\u6210\u3002\u5b83\u4eec\u4e8c\u8005\u7684\u4e3b\u8981\u7684\u533a\u522b\u5c31\u662f static_cast \u4e0d\u505a\u8fd0\u884c\u65f6\u7c7b\u578b\u68c0\u67e5\u6765\u786e\u4fdd\u4f60\u6240\u505a\u7684\u4e8b\u6709\u610f\u4e49\u3002\u8fd9\u4f7f\u5f97\u4f7f\u7528 static_cast \u66f4\u5feb\uff0c\u4f46\u662f\u66f4\u5371\u9669\uff0c\u5982\u679c\u4f60\u5c1d\u8bd5\u8f6c\u5316 Base* \u6210\u4e00\u4e2a Derived* \uff0c\u53ef\u80fd\u4f1a\u201c\u6210\u529f\u201d\u5373\u4f7f Base \u6307\u9488\u5e76\u6ca1\u6709\u6307\u5411 Derived \u5bf9\u8c61\u3002\u8fd9\u4f1a\u9020\u6210\u672a\u77e5\u7684\u884c\u4e3a\uff0c\u5f53\u4f60\u5c1d\u8bd5\u8bbf\u95ee\u8f6c\u5316\u7ed3\u679c\u65f6\u3002\uff08\u6307\u9488\u4ecd\u7136\u6307\u5411 Base \u5bf9\u8c61\uff09\u3002 \u5982\u679c\u4f60\u5f88\u660e\u786e\u4f60\u6240\u4f7f\u7528\u7684\u6307\u9488\u5411\u4e0b\u8f6c\u6362\u5c06\u4f1a\u6210\u529f\uff0c\u76f4\u63a5\u4f7f\u7528 static_cast \u662f\u53ef\u4ee5\u63a5\u53d7\u7684\u3002\u552f\u4e00\u80fd\u786e\u4fdd\u4f60\u77e5\u9053\u6307\u9488\u6307\u5411\u7684\u7c7b\u578b\u7684\u65b9\u6cd5\uff0c\u5c31\u662f\u4f7f\u7528\u4e00\u4e2a\u865a\u51fd\u6570\u3002\u8fd9\u91cc\u6709\u4e00\u4e2a\uff08\u4e0d\u662f\u5f88\u597d\uff0c\u4f7f\u7528\u4e86\u5168\u5c40\u53d8\u91cf\uff09\u7684\u65b9\u6cd5\u6765\u505a\u8fd9\u4ef6\u4e8b\u3002 # include <iostream> # include <string> // Class identifier enum ClassID { BASE , DERIVED // Others can be added here later }; class Base { protected : int m_value ; public : Base ( int value ) : m_value ( value ) { } virtual ~ Base () {} virtual ClassID getClassID () const { return BASE ; } }; class Derived : public Base { protected : std :: string m_name ; public : Derived ( int value , std :: string name ) : Base ( value ), m_name ( name ) { } const std :: string & getName () const { return m_name ; } virtual ClassID getClassID () const { return DERIVED ; } }; Base * getObject ( bool bReturnDerived ) { if ( bReturnDerived ) return new Derived ( 1 , \"Apple\" ); else return new Base ( 2 ); } int main () { Base * b = getObject ( true ); if ( b -> getClassID () == DERIVED ) { // \u6211\u4eec\u65e9\u5c31\u8bc1\u660e\u4e86 b \u662f\u4e00\u4e2a\u6307\u5411\u6d3e\u751f\u7c7b\u5bf9\u8c61\uff0c\u6240\u4ee5\u8fd9\u4e2a\u603b\u662f\u6210\u529f\u3002 Derived * d = static_cast < Derived *> ( b ); std :: cout << \"The name of the Derived is: \" << d -> getName () << '\\n' ; } delete b ; return 0 ; } \u4f46\u662f\u5982\u679c\u4f60\u60f3\u7ecf\u5386\u6240\u6709\u9ebb\u70e6\u6765\u5b9e\u73b0\u8fd9\u4e2a\uff08\u5e76\u4e14\u82b1\u8d39\u8c03\u7528\u865a\u51fd\u6570\u5e76\u4e14\u5904\u7406\u7ed3\u679c\u7684\u7cbe\u529b\uff09\uff0c\u6211\u60f3\u4f60\u8fd8\u662f\u5c31\u7528\u52a8\u6001\u8f6c\u6362 (dynamic_cast) \u6bd4\u8f83\u597d\u3002 \u52a8\u6001\u8f6c\u5316\u548c\u5f15\u7528 (dynamic_cast and references) \u00b6 \u5c3d\u7ba1\u6240\u6709\u4ee5\u4e0a\u7684\u4f8b\u5b50\u90fd\u63cf\u8ff0\u4e86\u52a8\u6001\u8f6c\u5316\u6307\u9488\uff08\u8fd9\u5f88\u5e38\u7528\uff09\uff0c\u52a8\u6001\u8f6c\u5316\u4e5f\u53ef\u4ee5\u88ab\u7528\u5728\u5f15\u7528\u4e0a\u3002\u8fd9\u4e2a\u7684\u7528\u6cd5\u548c\u7528\u5728\u6307\u9488\u4e0a\u5dee\u4e0d\u591a\u3002 # include <iostream> # include <string> class Base { protected : int m_value ; public : Base ( int value ) : m_value ( value ) { } virtual ~ Base () {} }; class Derived : public Base { protected : std :: string m_name ; public : Derived ( int value , std :: string name ) : Base ( value ), m_name ( name ) { } const std :: string & getName () const { return m_name ; } }; int main () { Derived apple ( 1 , \"Apple\" ); // create an apple Base & b = apple ; // set base reference to object Derived & d = dynamic_cast < Derived &> ( b ); // dynamic cast using a reference instead of a pointer std :: cout << \"The name of the Derived is: \" << d . getName () << '\\n' ; // we can access Derived::getName through d return 0 ; } \u56e0\u4e3a C++ \u6ca1\u6709\u201c\u7a7a\u5f15\u7528\u201d\u7684\u8bf4\u6cd5\uff0c\u52a8\u6001\u8f6c\u5316\u4e0d\u53ef\u80fd\u8fd4\u56de\u4e00\u4e2a\u7a7a\u5f15\u7528\u5982\u679c\u906d\u9047\u5931\u8d25\u3002\u76f8\u53cd\u7684\uff0c\u5982\u679c\u52a8\u6001\u8f6c\u5316\u4e00\u4e2a\u5f15\u7528\u5931\u8d25\u4e86\uff0c\u4e00\u4e2a\u5f02\u5e38 std::bad_cast \u5c06\u4f1a\u629b\u51fa\u3002\u6211\u4eec\u4f1a\u5728\u4e4b\u540e\u7684\u6559\u7a0b\u8ba8\u8bba\u5f02\u5e38\u3002 \u52a8\u9759\u6001\u8f6c\u5316\u7684\u5bf9\u6bd4 (dynamic_cast vs static_cast) \u00b6 \u65b0\u7684\u7a0b\u5e8f\u5458\u6709\u65f6\u5019\u5f88\u8ff7\u60d1\u5565\u65f6\u5019\u7528\u52a8\u6001\u8f6c\u6362\uff0c\u5565\u65f6\u5019\u7528\u9759\u6001\u8f6c\u6362\u3002\u7b54\u6848\u975e\u5e38\u7b80\u5355\uff1a\u4f7f\u7528 static_cast \u9664\u975e\u4f60\u6b63\u5728\u5411\u4e0b\u8f6c\u6362\uff0c\u8fd9\u662f\u4f7f\u7528 dynamic_cast \u901a\u5e38\u662f\u4e00\u4e2a\u66f4\u597d\u7684\u9009\u62e9\u3002\u7136\u800c\uff0c\u4f60\u4e5f\u5c05\u4e00\u8003\u8651\u907f\u514d\u8f6c\u6362\uff0c\u5c31\u662f\u7528\u865a\u51fd\u6570\u3002 \u5411\u4e0b\u8f6c\u6362\u548c\u865a\u51fd\u6570\u7684\u5bf9\u6bd4 \u00b6 \u6709\u4e9b\u5f00\u53d1\u8005\u76f8\u4fe1\u52a8\u6001\u8f6c\u6362\u662f\u6076\u9b54\ud83d\udc7f\u5e76\u4e14\u662f\u574f\u7684\u7c7b\u578b\u8bbe\u8ba1\uff0c\u8fd9\u4e9b\u7a0b\u5e8f\u5458\u8bf4\u6c38\u8fdc\u5e94\u8be5\u4f7f\u7528\u865a\u51fd\u6570\u3002 \u5927\u4f53\u4e0a\uff0c\u4f7f\u7528\u865a\u51fd\u6570\u5e94\u8be5\u66f4\u53d7\u6b22\u8fce\u6bd4\u8d77\u5411\u4e0b\u8f6c\u6362\u3002\u7136\u800c\uff0c\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0c\u4f7f\u7528\u5411\u4e0b\u8f6c\u6362\u662f\u4e00\u4e2a\u66f4\u597d\u7684\u9009\u62e9\uff1a \u5f53\u4f60\u4e0d\u80fd\u4fee\u6539\u57fa\u7c7b\u6765\u6dfb\u52a0\u4e00\u4e2a\u865a\u51fd\u6570\u65f6\uff08\u4f8b\u5982\uff1a\u56e0\u4e3a\u57fa\u7c7b\u662f\u6807\u51c6\u5e93\u4e2d\u7684\u4e00\u79cd\uff09 \u5f53\u4f60\u4ecd\u7136\u9700\u8981\u8bbf\u95ee\u4e00\u4e9b\u53ea\u6709\u6d3e\u751f\u7c7b\u72ec\u6709\u7684\u4e1c\u897f\u65f6\uff08\u4f8b\u5982\uff1a\u67d0\u4e2a\u8bbf\u95ee\u51fd\u6570\u53ea\u5b58\u5728\u4e8e\u6d3e\u751f\u7c7b\uff09 \u5f53\u6dfb\u52a0\u4e00\u4e2a\u865a\u51fd\u6570\u5230\u4f60\u7684\u57fa\u7c7b\u6beb\u65e0\u610f\u4e49\u65f6\uff08\u4f8b\u5982\uff1a\u6ca1\u6709\u4e00\u4e2a\u5408\u9002\u7684\u503c\u8ba9\u57fa\u7c7b\u8fd4\u56de\uff09\u4f7f\u7528\u7eaf\u865a\u51fd\u6570\u4e5f\u8bb8\u53ef\u4ee5\u7eb3\u5165\u8003\u8651\uff0c\u5982\u679c\u4f60\u4e0d\u8981\u5b9e\u4f8b\u5316\u57fa\u7c7b\u3002 \u4e00\u4e2a\u6709\u5173\u52a8\u6001\u7c7b\u578b\u8f6c\u6362\u548cRTTI\u7684\u8b66\u544a (A warning about dynamic_cast and RTTI) \u00b6 \u8fd0\u884c\u65f6\u7c7b\u578b\u4fe1\u606f\uff08RTTI\uff09\u662f\u4e00\u4e2a C++ \u7684\u7279\u6027\uff0c\u7528\u4e8e\u5728\u8fd0\u884c\u65f6\u66b4\u9732\u4e00\u4e2a\u5bf9\u8c61\u7684\u6570\u636e\u7c7b\u578b\u3002\u8fd9\u8fd9\u4e2a\u80fd\u529b dynamic_cast \u8d4b\u4e88\u7684\u3002\u56e0\u4e3a\u8fd0\u884c\u65f6\u6709\u76f8\u5f53\u53ef\u89c2\u7684\u7a7a\u95f4\u6027\u80fd\u6210\u672c\uff0c\u4e00\u4e9b\u7f16\u8bd1\u5668\u5141\u8bb8\u4f60\u5173\u95ed RTTI \u6765\u505a\u4e3a\u4e00\u4e2a\u4f18\u5316\uff0c\u4e0d\u7528\u8bf4\uff0c\u5982\u679c\u4f60\u90a3\u4e48\u505a\uff0c\u52a8\u6001\u7c7b\u578b\u8f6c\u6362\u5c06\u4e0d\u4f1a\u6b63\u5e38\u5de5\u4f5c\u3002","title":"12.9\u52a8\u6001\u7c7b\u578b\u8f6c\u6362"},{"location":"12-virtual-functions/12.9-dynamic-casting/#129","text":"\u65e9\u5728 \u7b2c6.16\u8bfe\u2014\u2014\u663e\u5f0f\u7c7b\u578b\u8f6c\u6362\uff08casting\uff09\u548cstatic_cast \u4e2d\uff0c\u6211\u4eec\u7814\u7a76\u4e86 casting \u7684\u6982\u5ff5\uff0c\u4ee5\u53ca\u4f7f\u7528 static_cast \u5c06\u53d8\u91cf\u4ece\u4e00\u79cd\u7c7b\u578b\u8f6c\u6362\u4e3a\u53e6\u4e00\u79cd\u7c7b\u578b\u3002 \u5728\u672c\u8bfe\u4e2d\uff0c\u6211\u4eec\u5c06\u7ee7\u7eed\u7814\u7a76\u53e6\u4e00\u79cd\u7c7b\u578b\u7684\u5f3a\u5236\u8f6c\u6362\uff1a\u52a8\u6001\u7c7b\u578b\u8f6c\u6362 (Dynamic cast)","title":"12.9\u52a8\u6001\u7c7b\u578b\u8f6c\u6362"},{"location":"12-virtual-functions/12.9-dynamic-casting/#_1","text":"\u5728\u5904\u7406\u591a\u6001\u6027\u65f6\uff0c\u60a8\u7ecf\u5e38\u4f1a\u9047\u5230\u8fd9\u6837\u7684\u60c5\u51b5\uff1a\u4f60\u6709\u4e00\u4e2a\u6307\u5411\u57fa\u7c7b\u7684\u6307\u9488\uff0c\u4f46\u4f60\u5e0c\u671b\u8bbf\u95ee\u4ec5\u5b58\u5728\u4e8e\u6d3e\u751f\u7c7b\u4e2d\u7684\u67d0\u4e9b\u4fe1\u606f\u3002 \u601d\u8003\u4e0b\u5217\u8fd9\u4e2a\uff08\u4e0d\u592a\u81ea\u7136\u7684\uff09\u4f8b\u5b50 # include <iostream> # include <string> class Base { protected : int m_value ; public : Base ( int value ) : m_value ( value ) { } virtual ~ Base () {} }; class Derived : public Base { protected : std :: string m_name ; public : Derived ( int value , std :: string name ) : Base ( value ), m_name ( name ) { } const std :: string & getName () const { return m_name ; } }; Base * getObject ( bool bReturnDerived ) { if ( bReturnDerived ) return new Derived ( 1 , \"Apple\" ); else return new Base ( 2 ); } int main () { Base * b = getObject ( true ); // \u6211\u4eec\u5e94\u8be5\u5982\u4f55\u6253\u5370\u6d3e\u751f\u7c7b\u5bf9\u8c61\u7684\u540d\u5b57\uff1f\u53ea\u6709\u57fa\u7c7b\u6307\u9488 delete b ; return 0 ; } \u5728\u8fd9\u4e2a\u7a0b\u5e8f\u4e2d\uff0c\u51fd\u6570 getObject() \u603b\u662f\u8fd4\u56de\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\uff0c\u4f46\u662f\u8fd9\u4e2a\u6307\u9488\u53ef\u80fd\u6307\u5411\u4e00\u4e2a\u57fa\u7c7b\u4e5f\u53ef\u80fd\u6307\u5411\u4e00\u4e2a\u6d3e\u751f\u7c7b\u3002\u5728\u4f8b\u5b50\u4e2d\u7684 Base \u6307\u9488 b \u5b9e\u9645\u6307\u5411\u7684\u662f\u6d3e\u751f\u7c7b\u7684\u5bf9\u8c61\uff0c\u6211\u4eec\u5e94\u8be5\u5982\u4f55\u8c03\u7528 Derived::getName() \uff1f \u4e00\u4e2a\u65b9\u6cd5\u4f1a\u662f\u6dfb\u52a0\u4e00\u4e2a\u865a\u51fd\u6570\u5230 Base \u7c7b\uff0c\u53eb getName() \uff08\u8fd9\u6837\u505a\u6211\u4eec\u53ef\u4ee5\u8c03\u7528\u5b83\uff0c\u901a\u8fc7 Base \u7684\u6307\u9488\u6216\u5f15\u7528\uff0c\u5b83\u90fd\u4f1a\u52a8\u6001\u5b9a\u5411\u5230 Derived::getName() \uff09\u3002\u4f46\u662f\u5982\u679c\u4f60\u8c03\u7528\u7684\u5bf9\u8c61\u662f\u4e00\u4e2a Base \u7c7b\u7684\u6307\u9488\u4f1a\u5f15\u7528\uff0c\u6307\u5411\u4e00\u4e2a Base \u5bf9\u8c61\uff0c\u90a3\u5c06\u4f1a\u8fd4\u56de\u4ec0\u4e48\uff1f\u6ca1\u6709\u4efb\u4f55\u503c\u771f\u6b63\u6709\u4ef7\u503c\u3002\u6b64\u5916\uff0c\u6211\u4eec\u5c06\u4f1a\u7528\u4e00\u4e9b\u4e1c\u897f\u6c61\u67d3\u6211\u4eec\u7684 Base \u7c7b\uff0c\u8fd9\u4e9b\u7684\u4e1c\u897f\u672c\u6765\u5e94\u8be5\u53ea\u5728\u6d3e\u751f\u7c7b\u4e2d\u5b58\u5728\u3002 \u6211\u4eec\u90fd\u77e5\u9053\uff0c C++ \u5c06\u4f1a\u9690\u5f0f\u7684\u8ba9\u4f60\u8f6c\u5316\u4e00\u4e2a\u6d3e\u751f\u7c7b\u6307\u9488\u4e3a\u4e00\u4e2a\u57fa\u7c7b\u6307\u6b63\u3002\uff08\u4e8b\u5b9e\u4e0a\uff0c getObjectt() \u5c31\u505a\u4e86\u90a3\u6837\u7684\u4e8b\u60c5\uff09\u3002\u8fd9\u79cd\u8fc7\u7a0b\u6709\u65f6\u5019\u88ab\u53eb\u505a\u5411\u4e0a\u8f6c\u5316\u3002\u7136\u800c\uff0c\u5982\u679c\u6709\u4e00\u4e2a\u65b9\u6cd5\u628a Base \u6307\u9488\u8f6c\u6362\u56de Derived \u6307\u9488\u4f1a\u600e\u4e48\u6837\uff1f\u7136\u540e\u6211\u4eec\u80fd\u591f\u76f4\u63a5\u901a\u8fc7\u90a3\u4e2a\u6307\u9488\u6765\u8c03\u7528 Derived::getName() \uff0c\u8fd9\u6837\u5c31\u6839\u672c\u4e0d\u7528\u5173\u5fc3\u865a\u51fd\u6570\u89e3\u6790\u3002","title":"\u4f55\u65f6\u9700\u8981\u8fdb\u884c\u52a8\u6001\u7c7b\u578b\u8f6c\u6362"},{"location":"12-virtual-functions/12.9-dynamic-casting/#dynamic-cast","text":"C++ \u63d0\u4f9b\u4e86\u4e00\u4e2a\u8f6c\u6362\u64cd\u4f5c\u7b26\uff0c\u53eb\u505a\u52a8\u6001\u8f6c\u5316\uff0c\u5c31\u53ef\u4ee5\u5728\u8fd9\u4e2a\u6761\u4ef6\u4e0b\u4f7f\u7528\u3002\u5c3d\u7ba1\u52a8\u6001\u8f6c\u5316\u6709\u5f88\u591a\u4e0d\u540c\u7684\u80fd\u529b\uff0c\u76ee\u524d\u4e3a\u6b62\u6211\u4eec\u6700\u5e38\u89c1\u7684\u4f7f\u7528\u573a\u666f\u5c31\u662f\u4e3a\u4e86\u8f6c\u5316\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\u6210\u4e00\u4e2a\u6d3e\u751f\u7c7b\u6307\u9488\u3002\u8fd9\u4e2a\u8fc7\u7a0b\u53eb\u505a\u5411\u4e0b\u7c7b\u578b\u8f6c\u6362\u3002 Using dynamic_cast works just like static_cast. Here\u2019s our example main() from above, using a dynamic_cast to convert our Base pointer back into a Derived pointer: \u52a8\u6001\u7c7b\u578b\u8f6c\u6362\u5c31\u50cf\u9759\u6001\u7c7b\u578b\u8f6c\u6362\u4e00\u6837\u3002\u8fd9\u662f\u6211\u4eec\u4e0a\u9762\u7684 main() \u51fd\u6570\u7684\u4f8b\u5b50\uff0c\u4f7f\u7528\u52a8\u6001\u7c7b\u578b\u8f6c\u5316\uff0c\u5c06 Base \u6307\u9488\u7c7b\u578b\u8f6c\u5316\u6210 Derived \u6307\u9488\u3002 int main () { Base * b = getObject ( true ); Derived * d = dynamic_cast < Derived *> ( b ); // use dynamic cast to convert Base pointer into Derived pointer std :: cout << \"The name of the Derived is: \" << d -> getName () << '\\n' ; delete b ; return 0 ; } \u8fd9\u4e2a\u7528\u4f8b\u6253\u5370\u51fa\uff1a The name of the Derived is: Apple","title":"\u52a8\u6001\u7c7b\u578b\u8f6c\u5316 (Dynamic Cast)"},{"location":"12-virtual-functions/12.9-dynamic-casting/#dynamic-cast-failure","text":"\u4e0a\u9762\u7684\u4f8b\u5b50\u80fd\u8fd0\u884c\u56e0\u4e3a b \u786e\u5b9e\u6307\u5411\u4e86\u4e00\u4e2a Derived \u5bf9\u8c61\uff0c\u56e0\u6b64\u8f6c\u5316 b \u6210\u4e3a\u4e00\u4e2a\u6d3e\u751f\u6307\u9488\u4f1a\u6210\u529f\u3002 \u7136\u800c\uff0c\u6211\u4eec\u505a\u4e86\u4e00\u4e2a\u76f8\u5f53\u5371\u9669\u7684\u5047\u8bbe\uff1a\u90a3\u5c31\u662f b \u786e\u5b9e\u662f\u6307\u5411\u4e86\u6d3e\u751f\u7c7b\u3002\u5982\u679c b \u4e0d\u662f\u6307\u5411\u6d3e\u751f\u5bf9\u8c61\u7684\uff0c\u5c06\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u8fd9\u5f88\u5bb9\u6613\u9a8c\u8bc1\uff0c\u5c06 getObject() \u7684\u53c2\u6570\u4ece true \u6539\u4e3a false \u3002\u5728\u90a3\u4e2a\u4f8b\u5b50\u91cc\uff0c getObject() \u5c06\u4f1a\u8fd4\u56de\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\u6307\u5411\u4e00\u4e2a\u57fa\u7c7b\u5bf9\u8c61\u3002\u5f53\u6211\u4eec\u5c1d\u8bd5\u4f7f\u7528\u52a8\u6001\u8f6c\u6362 dynamic_cast \u8f6c\u5316\u6210\u4e00\u4e2a\u6d3e\u751f\u5bf9\u8c61\u7684\u65f6\u5019\uff0c\u5c06\u4f1a\u5931\u8d25\uff0c\u56e0\u4e3a\u8f6c\u5316\u4e0d\u53ef\u80fd\u6210\u529f\u3002 \u5982\u679c\u52a8\u6001\u8f6c\u5316\u5931\u8d25\uff0c\u8f6c\u5316\u7ed3\u679c\u4f1a\u662f\u4e00\u4e2a null \u6307\u9488\u3002 \u56e0\u4e3a\u6211\u4eec\u6ca1\u6709\u68c0\u67e5\u7ed3\u679c\u662f\u5426\u662f\u7a7a\u6307\u9488\uff0c\u6211\u4eec\u8bbf\u95ee d->getName() \uff0c\u5c06\u4f1a\u5c1d\u8bd5\u95f4\u5740\u4e00\u4e2a\u7a7a\u6307\u9488\uff0c\u5c06\u4f1a\u5bfc\u81f4\u4e00\u4e2a\u672a\u5b9a\u4e49\u7684\u64cd\u4f5c\uff0c\u53ef\u80fd\u4f1a\u9020\u6210\u5d29\u6e83\u3002 \u4e3a\u4e86\u8ba9\u8fd9\u4e2a\u7a0b\u5e8f\u5b89\u5168\u8fd0\u884c\uff0c\u6211\u4eec\u9700\u8981\u53bb\u786e\u8ba4\u52a8\u6001\u8f6c\u6362\u786e\u5b9e\u6210\u529f\u4e86\u3002 int main () { Base * b = getObject ( true ); Derived * d = dynamic_cast < Derived *> ( b ); // use dynamic cast to convert Base pointer into Derived pointer if ( d ){ // make sure d is non-null std :: cout << \"The name of the Derived is: \" << d -> getName () << '\\n' ; } delete b ; return 0 ; } \u89c4\u5219\uff1a \u603b\u662f\u901a\u8fc7\u68c0\u67e5\u7a7a\u6307\u9488\u6765\u786e\u4fdd\u7684\u52a8\u6001\u8f6c\u6362\u6210\u529f\u4e86\u3002 \u6ce8\u610f\u5230\u56e0\u4e3a\u52a8\u6001\u8f6c\u6362\u5728\u8fd0\u884c\u65f6\u505a\u4e86\u4e00\u4e9b\u4e00\u81f4\u6027(consisitency)\u68c0\u67e5\uff08\u6765\u786e\u4fdd\u8f6c\u6362\u662f\u53ef\u884c\u7684\uff09\uff0c\u4f7f\u7528\u52a8\u6001\u8f6c\u6362\u4f1a\u5f15\u8d77\u4e00\u4e9b\u6027\u80fd\u635f\u5931(performance penalty). \u4e5f\u8bf7\u6ce8\u610f\uff0c\u5728\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0c\u4f7f\u7528\u52a8\u6001\u8f6c\u6362 (dynamic_cast) \u8fdb\u884c\u5411\u4e0b\u8f6c\u6362 (downcasting)\u65f6\u5c06\u65e0\u6cd5\u5de5\u4f5c\uff1a 1\uff09\u4f7f\u7528 protected \u6216\u8005 private \u7ee7\u627f\u7684\u3002 2\uff09\u6ca1\u6709\u7533\u660e\u6216\u8005\u7ee7\u627f\u4efb\u4f55\u865a\u51fd\u6570\u7684\uff08\u5e76\u4e14\u56e0\u6b64\u6ca1\u6709\u865a\u8868\uff09\u3002 3\uff09\u5728\u7279\u5b9a\u7684\u4f8b\u5b50\u4e0b\u8bbe\u8ba1\u865a\u57fa\u7c7b\u7684\u8f6c\u5316\u3002\uff08\u770b\u8fd9\u9875\u7684\u4f8b\u5b50\u4e2d\u4f7f\u7528\u7684\u8fd9\u4e9b\u7c7b\uff0c\u548c\u5982\u4f55 resove \u4ed6\u4eec\uff09\u3002","title":"\u52a8\u6001\u7c7b\u578b\u8f6c\u6362\u5931\u8d25 (Dynamic Cast Failure)"},{"location":"12-virtual-functions/12.9-dynamic-casting/#downcasting-with-static_cast","text":"\u4e8b\u5b9e\u8bc1\u660e\uff0c\u5411\u4e0b\u8f6c\u6362\u4e5f\u53ef\u4ee5\u7531\u9759\u6001\u8f6c\u6362 static_cast \u6765\u5b8c\u6210\u3002\u5b83\u4eec\u4e8c\u8005\u7684\u4e3b\u8981\u7684\u533a\u522b\u5c31\u662f static_cast \u4e0d\u505a\u8fd0\u884c\u65f6\u7c7b\u578b\u68c0\u67e5\u6765\u786e\u4fdd\u4f60\u6240\u505a\u7684\u4e8b\u6709\u610f\u4e49\u3002\u8fd9\u4f7f\u5f97\u4f7f\u7528 static_cast \u66f4\u5feb\uff0c\u4f46\u662f\u66f4\u5371\u9669\uff0c\u5982\u679c\u4f60\u5c1d\u8bd5\u8f6c\u5316 Base* \u6210\u4e00\u4e2a Derived* \uff0c\u53ef\u80fd\u4f1a\u201c\u6210\u529f\u201d\u5373\u4f7f Base \u6307\u9488\u5e76\u6ca1\u6709\u6307\u5411 Derived \u5bf9\u8c61\u3002\u8fd9\u4f1a\u9020\u6210\u672a\u77e5\u7684\u884c\u4e3a\uff0c\u5f53\u4f60\u5c1d\u8bd5\u8bbf\u95ee\u8f6c\u5316\u7ed3\u679c\u65f6\u3002\uff08\u6307\u9488\u4ecd\u7136\u6307\u5411 Base \u5bf9\u8c61\uff09\u3002 \u5982\u679c\u4f60\u5f88\u660e\u786e\u4f60\u6240\u4f7f\u7528\u7684\u6307\u9488\u5411\u4e0b\u8f6c\u6362\u5c06\u4f1a\u6210\u529f\uff0c\u76f4\u63a5\u4f7f\u7528 static_cast \u662f\u53ef\u4ee5\u63a5\u53d7\u7684\u3002\u552f\u4e00\u80fd\u786e\u4fdd\u4f60\u77e5\u9053\u6307\u9488\u6307\u5411\u7684\u7c7b\u578b\u7684\u65b9\u6cd5\uff0c\u5c31\u662f\u4f7f\u7528\u4e00\u4e2a\u865a\u51fd\u6570\u3002\u8fd9\u91cc\u6709\u4e00\u4e2a\uff08\u4e0d\u662f\u5f88\u597d\uff0c\u4f7f\u7528\u4e86\u5168\u5c40\u53d8\u91cf\uff09\u7684\u65b9\u6cd5\u6765\u505a\u8fd9\u4ef6\u4e8b\u3002 # include <iostream> # include <string> // Class identifier enum ClassID { BASE , DERIVED // Others can be added here later }; class Base { protected : int m_value ; public : Base ( int value ) : m_value ( value ) { } virtual ~ Base () {} virtual ClassID getClassID () const { return BASE ; } }; class Derived : public Base { protected : std :: string m_name ; public : Derived ( int value , std :: string name ) : Base ( value ), m_name ( name ) { } const std :: string & getName () const { return m_name ; } virtual ClassID getClassID () const { return DERIVED ; } }; Base * getObject ( bool bReturnDerived ) { if ( bReturnDerived ) return new Derived ( 1 , \"Apple\" ); else return new Base ( 2 ); } int main () { Base * b = getObject ( true ); if ( b -> getClassID () == DERIVED ) { // \u6211\u4eec\u65e9\u5c31\u8bc1\u660e\u4e86 b \u662f\u4e00\u4e2a\u6307\u5411\u6d3e\u751f\u7c7b\u5bf9\u8c61\uff0c\u6240\u4ee5\u8fd9\u4e2a\u603b\u662f\u6210\u529f\u3002 Derived * d = static_cast < Derived *> ( b ); std :: cout << \"The name of the Derived is: \" << d -> getName () << '\\n' ; } delete b ; return 0 ; } \u4f46\u662f\u5982\u679c\u4f60\u60f3\u7ecf\u5386\u6240\u6709\u9ebb\u70e6\u6765\u5b9e\u73b0\u8fd9\u4e2a\uff08\u5e76\u4e14\u82b1\u8d39\u8c03\u7528\u865a\u51fd\u6570\u5e76\u4e14\u5904\u7406\u7ed3\u679c\u7684\u7cbe\u529b\uff09\uff0c\u6211\u60f3\u4f60\u8fd8\u662f\u5c31\u7528\u52a8\u6001\u8f6c\u6362 (dynamic_cast) \u6bd4\u8f83\u597d\u3002","title":"\u4f7f\u7528\u9759\u6001\u7c7b\u578b\u8f6c\u6362\u8fdb\u884c\u5411\u4e0b\u8f6c\u5316 (Downcasting with static_cast)"},{"location":"12-virtual-functions/12.9-dynamic-casting/#dynamic_cast-and-references","text":"\u5c3d\u7ba1\u6240\u6709\u4ee5\u4e0a\u7684\u4f8b\u5b50\u90fd\u63cf\u8ff0\u4e86\u52a8\u6001\u8f6c\u5316\u6307\u9488\uff08\u8fd9\u5f88\u5e38\u7528\uff09\uff0c\u52a8\u6001\u8f6c\u5316\u4e5f\u53ef\u4ee5\u88ab\u7528\u5728\u5f15\u7528\u4e0a\u3002\u8fd9\u4e2a\u7684\u7528\u6cd5\u548c\u7528\u5728\u6307\u9488\u4e0a\u5dee\u4e0d\u591a\u3002 # include <iostream> # include <string> class Base { protected : int m_value ; public : Base ( int value ) : m_value ( value ) { } virtual ~ Base () {} }; class Derived : public Base { protected : std :: string m_name ; public : Derived ( int value , std :: string name ) : Base ( value ), m_name ( name ) { } const std :: string & getName () const { return m_name ; } }; int main () { Derived apple ( 1 , \"Apple\" ); // create an apple Base & b = apple ; // set base reference to object Derived & d = dynamic_cast < Derived &> ( b ); // dynamic cast using a reference instead of a pointer std :: cout << \"The name of the Derived is: \" << d . getName () << '\\n' ; // we can access Derived::getName through d return 0 ; } \u56e0\u4e3a C++ \u6ca1\u6709\u201c\u7a7a\u5f15\u7528\u201d\u7684\u8bf4\u6cd5\uff0c\u52a8\u6001\u8f6c\u5316\u4e0d\u53ef\u80fd\u8fd4\u56de\u4e00\u4e2a\u7a7a\u5f15\u7528\u5982\u679c\u906d\u9047\u5931\u8d25\u3002\u76f8\u53cd\u7684\uff0c\u5982\u679c\u52a8\u6001\u8f6c\u5316\u4e00\u4e2a\u5f15\u7528\u5931\u8d25\u4e86\uff0c\u4e00\u4e2a\u5f02\u5e38 std::bad_cast \u5c06\u4f1a\u629b\u51fa\u3002\u6211\u4eec\u4f1a\u5728\u4e4b\u540e\u7684\u6559\u7a0b\u8ba8\u8bba\u5f02\u5e38\u3002","title":"\u52a8\u6001\u8f6c\u5316\u548c\u5f15\u7528 (dynamic_cast and references)"},{"location":"12-virtual-functions/12.9-dynamic-casting/#dynamic_cast-vs-static_cast","text":"\u65b0\u7684\u7a0b\u5e8f\u5458\u6709\u65f6\u5019\u5f88\u8ff7\u60d1\u5565\u65f6\u5019\u7528\u52a8\u6001\u8f6c\u6362\uff0c\u5565\u65f6\u5019\u7528\u9759\u6001\u8f6c\u6362\u3002\u7b54\u6848\u975e\u5e38\u7b80\u5355\uff1a\u4f7f\u7528 static_cast \u9664\u975e\u4f60\u6b63\u5728\u5411\u4e0b\u8f6c\u6362\uff0c\u8fd9\u662f\u4f7f\u7528 dynamic_cast \u901a\u5e38\u662f\u4e00\u4e2a\u66f4\u597d\u7684\u9009\u62e9\u3002\u7136\u800c\uff0c\u4f60\u4e5f\u5c05\u4e00\u8003\u8651\u907f\u514d\u8f6c\u6362\uff0c\u5c31\u662f\u7528\u865a\u51fd\u6570\u3002","title":"\u52a8\u9759\u6001\u8f6c\u5316\u7684\u5bf9\u6bd4 (dynamic_cast vs static_cast)"},{"location":"12-virtual-functions/12.9-dynamic-casting/#_2","text":"\u6709\u4e9b\u5f00\u53d1\u8005\u76f8\u4fe1\u52a8\u6001\u8f6c\u6362\u662f\u6076\u9b54\ud83d\udc7f\u5e76\u4e14\u662f\u574f\u7684\u7c7b\u578b\u8bbe\u8ba1\uff0c\u8fd9\u4e9b\u7a0b\u5e8f\u5458\u8bf4\u6c38\u8fdc\u5e94\u8be5\u4f7f\u7528\u865a\u51fd\u6570\u3002 \u5927\u4f53\u4e0a\uff0c\u4f7f\u7528\u865a\u51fd\u6570\u5e94\u8be5\u66f4\u53d7\u6b22\u8fce\u6bd4\u8d77\u5411\u4e0b\u8f6c\u6362\u3002\u7136\u800c\uff0c\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0c\u4f7f\u7528\u5411\u4e0b\u8f6c\u6362\u662f\u4e00\u4e2a\u66f4\u597d\u7684\u9009\u62e9\uff1a \u5f53\u4f60\u4e0d\u80fd\u4fee\u6539\u57fa\u7c7b\u6765\u6dfb\u52a0\u4e00\u4e2a\u865a\u51fd\u6570\u65f6\uff08\u4f8b\u5982\uff1a\u56e0\u4e3a\u57fa\u7c7b\u662f\u6807\u51c6\u5e93\u4e2d\u7684\u4e00\u79cd\uff09 \u5f53\u4f60\u4ecd\u7136\u9700\u8981\u8bbf\u95ee\u4e00\u4e9b\u53ea\u6709\u6d3e\u751f\u7c7b\u72ec\u6709\u7684\u4e1c\u897f\u65f6\uff08\u4f8b\u5982\uff1a\u67d0\u4e2a\u8bbf\u95ee\u51fd\u6570\u53ea\u5b58\u5728\u4e8e\u6d3e\u751f\u7c7b\uff09 \u5f53\u6dfb\u52a0\u4e00\u4e2a\u865a\u51fd\u6570\u5230\u4f60\u7684\u57fa\u7c7b\u6beb\u65e0\u610f\u4e49\u65f6\uff08\u4f8b\u5982\uff1a\u6ca1\u6709\u4e00\u4e2a\u5408\u9002\u7684\u503c\u8ba9\u57fa\u7c7b\u8fd4\u56de\uff09\u4f7f\u7528\u7eaf\u865a\u51fd\u6570\u4e5f\u8bb8\u53ef\u4ee5\u7eb3\u5165\u8003\u8651\uff0c\u5982\u679c\u4f60\u4e0d\u8981\u5b9e\u4f8b\u5316\u57fa\u7c7b\u3002","title":"\u5411\u4e0b\u8f6c\u6362\u548c\u865a\u51fd\u6570\u7684\u5bf9\u6bd4"},{"location":"12-virtual-functions/12.9-dynamic-casting/#rtti-a-warning-about-dynamic_cast-and-rtti","text":"\u8fd0\u884c\u65f6\u7c7b\u578b\u4fe1\u606f\uff08RTTI\uff09\u662f\u4e00\u4e2a C++ \u7684\u7279\u6027\uff0c\u7528\u4e8e\u5728\u8fd0\u884c\u65f6\u66b4\u9732\u4e00\u4e2a\u5bf9\u8c61\u7684\u6570\u636e\u7c7b\u578b\u3002\u8fd9\u8fd9\u4e2a\u80fd\u529b dynamic_cast \u8d4b\u4e88\u7684\u3002\u56e0\u4e3a\u8fd0\u884c\u65f6\u6709\u76f8\u5f53\u53ef\u89c2\u7684\u7a7a\u95f4\u6027\u80fd\u6210\u672c\uff0c\u4e00\u4e9b\u7f16\u8bd1\u5668\u5141\u8bb8\u4f60\u5173\u95ed RTTI \u6765\u505a\u4e3a\u4e00\u4e2a\u4f18\u5316\uff0c\u4e0d\u7528\u8bf4\uff0c\u5982\u679c\u4f60\u90a3\u4e48\u505a\uff0c\u52a8\u6001\u7c7b\u578b\u8f6c\u6362\u5c06\u4e0d\u4f1a\u6b63\u5e38\u5de5\u4f5c\u3002","title":"\u4e00\u4e2a\u6709\u5173\u52a8\u6001\u7c7b\u578b\u8f6c\u6362\u548cRTTI\u7684\u8b66\u544a (A warning about dynamic_cast and RTTI)"},{"location":"12-virtual-functions/12.x%20chapter-12-comprehensice-quiz/","text":"12.x \u5341\u4e8c\u7ae0\u7406\u89e3\u548c\u7ec3\u4e60 \u00b6 \u6211\u4eec\u7684 C++ \u65c5\u7a0b\u5728\u7ee7\u627f\u548c\u865a\u51fd\u6570\u8fd9\u5757\u5df2\u7ecf\u7ed3\u675f\u4e86\u3002\u4e0d\u8981\u62c5\u5fc3\uff0c\u4eb2\u7231\u7684\u8bfb\u8005\uff0c\u56e0\u4e3a\u8fd8\u6709\u5927\u91cf\u5176\u4ed6 C++ \u7684\u9886\u57df\u7b49\u5f85\u6211\u4eec\u524d\u8fdb\uff0c\u63a2\u7d22\uff01 \u7ae0\u8282\u603b\u7ed3 \u00b6 C++ \u5141\u8bb8\u4f60\u8bbe\u7f6e\u57fa\u7c7b\u6307\u9488\u548c\u5f15\u7528\u5230\u6d3e\u751f\u5bf9\u8c61\u3002\u8fd9\u662f\u5f88\u6709\u7528\u7684\uff0c\u5f53\u6211\u4eec\u60f3\u8981\u5199\u4e00\u4e2a\u51fd\u6570\u6216\u8005\u6570\u7ec4\uff0c\u53ef\u4ee5\u548c\u4efb\u4f55\u7c7b\u578b\u7684\u4ece\u57fa\u7c7b\u6d3e\u751f\u7684\u5bf9\u8c61\u642d\u914d\u3002\uff08This is useful when we want to write a function or array that can work with any type of object derived from a base class.\uff09 \u5982\u679c\u6ca1\u6709\u865a\u51fd\u6570\uff0c\u57fa\u7c7b\u6307\u5411\u6d3e\u751f\u7c7b\u7684\u6307\u9488\u548c\u5f15\u7528\u5c06\u4f1a\u53ea\u80fd\u8bbf\u95ee\u57fa\u7c7b\u6210\u5458\uff0c\u548c\u51fd\u6570\u3002 \u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u662f\u4e00\u4e2a\u7279\u6b8a\u7c7b\u578b\u7684\u51fd\u6570\u80fd\u89e3\u6790\u5230\u7ee7\u627f\u672b\u7aef\u7248\u672c\u7684\u51fd\u6570\uff08\u53eb\u505a\u91cd\u5199\uff09\u5b58\u5728\u4e8e\u57fa\u7c7b\u548c\u6d3e\u751f\u7c7b\u4e4b\u95f4\u3002\u60f3\u8981\u88ab\u8ba4\u4e3a\u662f\u4e00\u4e2a\u91cd\u5199\uff0c\u6d3e\u751f\u7c7b\u5fc5\u987b\u548c\u57fa\u7c7b\u865a\u51fd\u6570\u6709\u540c\u6837\u7684\u7b7e\u540d\u548c\u8fd4\u56de\u7c7b\u578b\u3002\u4e00\u4e2a\u4f8b\u5916\u5c31\u662f covariant return types \uff0c\u80fd\u591f\u5141\u8bb8\u4e00\u4e2a\u91cd\u5199\u8fd4\u56de\u4e00\u4e2a\u6307\u6d3e\u751f\u7c7b\u7684\u9488\u6216\u5f15\u7528\u5982\u679c\u57fa\u7c7b\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u57fa\u7c7b\u7684\u6307\u9488\u6216\u5f15\u7528\u3002 \u4e00\u4e2a\u51fd\u6570\u51fd\u6570\u60f3\u8981\u88ab\u91cd\u5199\uff0c\u5e94\u8be5\u6dfb\u52a0\u91cd\u5199\u6307\u793a\u7b26\u6765\u786e\u4fdd\u5b83\u786e\u5b9e\u91cd\u5199\u4e86\u3002 final \u6307\u793a\u7b26\u80fd\u591f\u88ab\u7528\u4f5c\u963b\u6b62\u4ece\u4e00\u4e2a\u8be5\u7c7b\u7684\u51fd\u6570\u88ab\u91cd\u5199\u3002 \u5982\u679c\u4f60\u60f3\u8981\u4f7f\u7528\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u4f60\u5e94\u8be5\u4f7f\u4f60\u7684\u6790\u6784\u51fd\u6570\u4e3a\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u5982\u679c\u4f60\u5220\u9664\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\uff0c\u8fd9\u6837\u505a\u53ef\u4ee5\u4f7f\u5408\u9002\u7684\u6790\u6784\u51fd\u6570\u88ab\u8c03\u7528\u3002 \u4f60\u53ef\u4ee5\u5ffd\u7565\u4e00\u4e2a\u865a\u51fd\u6570\u89e3\u6790\u901a\u8fc7\u4f7f\u7528 scope resolution opearator \u6765\u76f4\u63a5\u6307\u5b9a\u90a3\u4e2a\u7c7b\u7684\u51fd\u6570\u4f60\u60f3\u8981\u8c03\u7528\uff1a\u4f8b\u5982 base.Base::getName() Early binding \u65e9\u7ed1\u5b9a\u53d1\u751f\u5728\u7f16\u8bd1\u65f6\u76f4\u63a5\u68c0\u6d4b\u5230\u51fd\u6570\u8c03\u7528\uff0c\u7f16\u8bd1\u5668\u6216\u8005\u8fde\u63a5\u5668\u53ef\u4ee5\u76f4\u63a5\u89e3\u6790\u8fd9\u4e9b\u51fd\u6570\u8c03\u7528\u3002 Late binding \u53d1\u751f\u5728\u5f53\u4e00\u4e2a\u51fd\u6570\u6307\u9488\u88ab\u8c03\u7528\u662f\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u54ea\u4e2a\u51fd\u6570\u5c06\u4f1a\u88ab\u8c03\u7528\u4e0d\u53ef\u80fd\u5728\u8fd0\u884c\u4e4b\u524d\u786e\u5b9a\u3002\u865a\u51fd\u6570\u4f7f\u7528\u4e86 late binding \u548c\u4e00\u4e2a\u865a\u8868\u6765\u51b3\u5b9a\u54ea\u4e2a\u7248\u672c\u7684\u51fd\u6570\u5c06\u88ab\u8c03\u7528\u3002 \u4f7f\u7528\u865a\u51fd\u6570\u6709\u4e00\u5b9a\u7684\u82b1\u8d39\uff0c\u865a\u51fd\u6570\u7684\u8c03\u7528\u5c06\u82b1\u8d39\u66f4\u591a\u65f6\u95f4\uff0c\u5e76\u4e14\u865a\u8868\u4f1a\u5360\u7528\u4e00\u5b9a\u7684\u7a7a\u95f4\uff0c\u5728\u6bcf\u4e2a\u5305\u542b\u865a\u51fd\u6570\u7684\u5bf9\u8c61\u4e2d\u589e\u52a0\u4e86\u4e00\u4e2a\u6307\u9488\u3002 \u4e00\u4e2a\u865a\u51fd\u6570\u53ef\u4ee5\u88ab\u5b9a\u4e49\u4e3a\u7eaf\u865a\u51fd\u6570\uff08\u62bd\u8c61\u51fd\u6570\uff09\u901a\u8fc7\u6dfb\u52a0 =0 \u5728\u865a\u51fd\u6570\u7684\u5b9a\u4e49\u540e\u65b9\u3002\u5305\u542b\u7eaf\u865a\u51fd\u6570\u7684\u7c7b\u88ab\u53eb\u505a\u62bd\u8c61\u7c7b\uff0c\u8fd9\u79cd\u7c7b\u4e0d\u80fd\u88ab\u5b9e\u4f8b\u5316\u3002\u4e00\u4e2a\u7c7b\u7ee7\u627f\u4e8e\u62bd\u8c61\u7c7b\uff0c\u90a3\u4e48\u7eaf\u865a\u51fd\u6570\u5fc5\u987b\u88ab\u6b63\u786e\u7684\u5b9a\u4e49\uff0c\u5426\u5219\u8be5\u7c7b\u4e5f\u5c06\u88ab\u8ba4\u4e3a\u662f\u62bd\u8c61\u7c7b\u3002\u7eaf\u865a\u51fd\u6570\u4e5f\u53ef\u4ee5\u6709\u4e00\u4e2a\u51fd\u6570\u4f53\uff0c\u4f46\u662f\u4ed6\u4eec\u4ecd\u7136\u88ab\u8ba4\u4e3a\u662f\u62bd\u8c61\u7684\u3002 \u63a5\u53e3\u7c7b\u662f\u4e00\u4e2a\u6ca1\u6709\u6210\u5458\u53d8\u91cf\u5e76\u4e14\u5168\u662f\u7eaf\u865a\u51fd\u6570\u7684\u7c7b\u3002\u8fd9\u6837\u7684\u7c7b\u7684\u540d\u79f0\u901a\u5e38\u4ee5\u5927\u5199\u7684 I \u5f00\u5934\u3002 \u4e00\u4e2a\u865a\u57fa\u7c7b\u5728\u4e00\u4e2a\u5bf9\u8c61\u4e2d\u53ea\u80fd\u88ab\u5305\u542b\u4e00\u6b21\uff0c\u65e0\u8bba\u88ab\u4e00\u4e2a\u7c7b\u7ee7\u627f\u4e86\u591a\u5c11\u6b21\u3002 \u5f53\u4e00\u4e2a\u6d3e\u751f\u7c7b\u88ab\u8d4b\u503c\u5230\u57fa\u7c7b\u5bf9\u8c61\u65f6\uff0c\u57fa\u7c7b\u53ea\u80fd\u63a5\u6536\u5230\u6d3e\u751f\u7c7b\u4e2d\u57fa\u7c7b\u90e8\u5206\u7684\u62f7\u8d1d\u3002\u8fd9\u88ab\u53eb\u505a\u5bf9\u8c61\u5207\u5272\u3002 \u52a8\u6001\u8f6c\u6362\u53ef\u4ee5\u88ab\u7528\u6765\u8f6c\u6362\u4e00\u4e2a\u6307\u5411\u57fa\u7c7b\u7684\u6307\u9488\u6210\u4e3a\u4e00\u4e2a\u6307\u5411\u6d3e\u751f\u7c7b\u7684\u6307\u9488\uff0c\u8fd9\u88ab\u53eb\u505a\u5411\u4e0b\u8f6c\u6362 (downcasting)\u3002\u4e00\u4e2a\u5931\u8d25\u7684\u8f6c\u6362\u4f1a\u8fd4\u56de\u4e00\u4e2a\u7a7a\u6307\u9488\u3002 \u6d3e\u751f\u7c7b\u6700\u7b80\u5355\u7684\u91cd\u8f7d << \u8fd0\u7b97\u7b26\u7684\u65b9\u5f0f\u662f\u5199\u4e00\u4e2a\u91cd\u8f7d << \u4e3a\u6700\u9876\u90e8\u7684\u57fa\u7c7b\uff0c\u7136\u540e\u6dfb\u52a0\u4e00\u4e2a\u865a\u6210\u5458\u51fd\u6570\u6765\u6253\u5370\u3002 // \u8bd1\u8005\u6dfb\u52a0\u7684\u4ee3\u7801\u7247\u6bb5\uff1a virtual std :: ostream & print ( std :: ostream & in ) const = 0 ; friend std :: ostream & operator << ( std :: ostream & out , const Base & b ) { return b . print ( out ); } // \u7ee7\u627f\u5bf9\u8c61\u90fd\u53ea\u9700\u8981\u91cd\u5199print\u5373\u53ef\u3002 Quiz time \u00b6 Quiz1 \u00b6 \u4ee5\u4e0b\u7684\u6bcf\u4e2a\u7a0b\u5e8f\u90fd\u6709\u4e00\u4e9b\u7f3a\u9677\uff0c\u68c0\u67e5\u6bcf\u4e2a\u7a0b\u5e8f\uff08\u7528\u773c\u775b\u68c0\u67e5\uff0c\u4e0d\u8981\u7f16\u8bd1\uff09\u5e76\u4e14\u8bca\u65ad\u51fa\u8fd9\u4e2a\u7a0b\u5e8f\u6709\u4ec0\u4e48\u95ee\u9898\u3002\u6bcf\u4e2a\u7a0b\u5e8f\u7684\u8f93\u51fa\u90fd\u5e94\u8be5\u662f Derived \u3002 \u8bd1\u8005\u6ce8\uff1a\u539f\u7f51\u7ad9\u662f\u54cd\u5e94\u5f0f\u7684\u9690\u85cf\uff0c\u6298\u53e0\u4e86\u7b54\u6848\uff0c\u672c\u7f51\u7ad9\u65e0\u6cd5\u505a\u5230\uff0c\u56e0\u6b64\u8bf7\u5148\u5b8c\u6210\u4ee3\u7801\u9605\u8bfb\u518d\u5f80\u4e0b\u770b\u7b54\u6848\u63cf\u8ff0\uff0c\u6bcf\u4e2a\u9898\u7684\u7b54\u6848\u90fd\u5728\u4ee3\u7801\u63cf\u8ff0\u4e0b\u65b9\u3002 1a) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } const char * getName () const { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } const char * getName () const { return \"Derived\" ; } }; int main () { Derived d { 5 }; Base & b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481a Base::getName() \u4e0d\u662f\u865a\u51fd\u6570\uff0c \u56e0\u6b64 b.getName() \u4e0d\u4f1a\u89e3\u6790\u5e76\u8c03\u7528 Derived::getName(). 1b) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () const { return \"Derived\" ; } }; int main () { Derived d { 5 }; Base & b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481b Base::geetName() \u5e76\u6ca1\u6709\u5b9a\u4e49\u4e3aconst\uff0c\u800c Derived::getName() \u662f\u4e00\u4e2aconst\u51fd\u6570\uff0c\u56e0\u6b64 Derived::getName() \u4e0d\u662f\u4e00\u4e2a\u91cd\u5199(override) 1c) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () override { return \"Derived\" ; } }; int main () { Derived d { 5 }; Base b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481c d \u662f\u503c\u8d4b\u503c\u5230 b \uff0c\u5bfc\u81f4 d \u88ab\u5207\u5272\u3002 1d) #include <iostream> class Base final { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () override { return \"Derived\" ; } }; int main () { Derived d { 5 }; Base & b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481d Base \u88ab\u5b9a\u4e49\u4e3a final \uff0c\u56e0\u6b64 Derived \u4e0d\u80fd\u4ece\u5b83\u7ee7\u627f\u3002\u8fd9\u5c06\u4f1a\u9020\u6210\u7f16\u8bd1\u9519\u8bef\u3002 1e) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () = 0 ; }; const char * Derived :: getName () { return \"Derived\" ; } int main () { Derived d { 5 }; Base & b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481e Derived::getName() \u662f\u4e00\u4e2a\u7eaf\u865a\u51fd\u6570\uff08\u65e0\u51fd\u6570\u4f53\uff09\uff0c\u5e76\u4e14\u56e0\u6b64 Derived \u662f\u4e00\u4e2a\u62bd\u8c61\u7c7b (abstract class) \u56e0\u6b64\u4e0d\u80fd\u88ab\u5b9e\u4f8b\u5316\u3002 1f) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base ( value ) { } virtual const char * getName () { return \"Derived\" ; } }; int main () { auto * d { new Derived ( 5 ) }; Base * b { d }; std :: cout << b -> getName () << '\\n' ; delete b ; return 0 ; } \u7b54\u68481f \u8fd9\u4e2a\u7a0b\u5e8f\u5b9e\u9645\u4e0a\u7684\u786e\u53ef\u4ee5\u5f97\u5230\u6b63\u786e\u7684\u8f93\u51fa\uff0c\u4f46\u662f\u53c8\u4e0d\u540c\u7684\u7684\u95ee\u9898\u3002\u5f53\u6211\u4eec delete b \u662f\uff0c b \u662f\u4e00\u4e2a Base \u6307\u9488\uff0c\u4f46\u662f\u4ece\u6765\u6ca1\u6dfb\u52a0\u4e00\u4e2a\u865a\u6790\u6784\u51fd\u6570 (virtual destructor) \u5230\u57fa\u7c7b\u3002\u56e0\u6b64\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u5220\u9664\u4e86 Derived \u5bf9\u8c61\u4e2d\u7684 Base \u90e8\u5206\uff0c\u5e76\u4e14 Derived \u90e8\u5206\u7559\u5728\u5185\u5b58\u4e2d\uff08\u6cc4\u9732\uff09\u3002 Quiz2 \u00b6 2a) \u521b\u5efa\u4e00\u4e2a\u53eb\u505a\u5f62\u72b6\u7684\u62bd\u8c61\u7c7b\uff0c\u8fd9\u4e2a\u7c7b\u5e94\u8be5\u6709\u4e09\u4e2a\u51fd\u6570\uff1a\u4e00\u4e2a\u7eaf\u865a\u51fd\u6570 print \u4f20\u5165\u5e76\u4e14\u8fd4\u56de\u4e00\u4e2a std::ostream \uff0c\u91cd\u8f7d <<\u64cd\u4f5c\u7b26 operator<< \u548c\u4e00\u4e2a\u865a\u6790\u6784\u51fd\u6570\u3002 \u7b54\u6848 class Shape { public : // virtual const char* getShapeName() const = 0; virtual std :: ostream & print ( std :: ostream & out ) const = 0 ; friend std :: ostream & operator << ( std :: ostream & out , const Shape & p ) { return p . print ( out ); } virtual ~ Shape () {} }; 2b) \u4ece Shape \u6d3e\u751f\u4e24\u4e2a\u7c7b\uff1a\u4e00\u4e2a Triangle \u548c\u4e00\u4e2a Circle \u3002 Triangle \u5e94\u8be5\u6709\u4e09\u4e2a Point \u4f5c\u4e3a\u6210\u5458\u3002 Circle \u5e94\u8be5\u6709\u4e00\u4e2a Point \u5706\u5fc3\uff0c\u548c\u4e00\u4e2a\u6574\u6570\u534a\u5f84 radius \uff0c\u91cd\u8f7d print() \u51fd\u6570\u4f7f\u5f97\u4ee5\u4e0b\u7a0b\u5e8f\u80fd\u591f\u8fd0\u884c\u3002 int main () { Circle c { Point { 1 , 2 , 3 }, 7 }; std :: cout << c << '\\n' ; Triangle t { Point { 1 , 2 , 3 }, Point { 4 , 5 , 6 }, Point { 7 , 8 , 9 }}; std :: cout << t << '\\n' ; return 0 ; } \u6837\u4f8b\u5e94\u8be5\u6253\u5370\uff1a Circle(Point(1, 2, 3), radius 7) Triangle(Point(1, 2, 3), Point(4, 5, 6), Point(7, 8, 9)) \u8fd9\u662f Point \u7c7b\uff1a class Point { private : int m_x { 0 }; int m_y { 0 }; int m_z { 0 }; public : Point ( int x , int y , int z ) : m_x { x }, m_y { y }, m_z { z } { } friend std :: ostream & operator << ( std :: ostream & out , const Point & p ) { out << \"Point(\" << p . m_x << \", \" << p . m_y << \", \" << p . m_z << ')' ; return out ; } }; \u7b54\u6848\uff1a #include <iostream> class Point { private : int m_x { 0 }; int m_y { 0 }; int m_z { 0 }; public : Point ( int x , int y , int z ) : m_x { x }, m_y { y }, m_z { z } { } friend std :: ostream & operator << ( std :: ostream & out , const Point & p ) { out << \"Point(\" << p . m_x << \", \" << p . m_y << \", \" << p . m_z << ')' ; return out ; } }; class Shape { public : virtual std :: ostream & print ( std :: ostream & out ) const = 0 ; friend std :: ostream & operator << ( std :: ostream & out , const Shape & p ) { return p . print ( out ); } virtual ~ Shape () = default ; }; class Triangle : public Shape { private : Point m_p1 {}; Point m_p2 {}; Point m_p3 {}; public : Triangle ( const Point & p1 , const Point & p2 , const Point & p3 ) : m_p1 { p1 }, m_p2 { p2 }, m_p3 { p3 } { } virtual std :: ostream & print ( std :: ostream & out ) const override { out << \"Triangle(\" << m_p1 << \", \" << m_p2 << \", \" << m_p3 << ')' ; return out ; } }; class Circle : public Shape { private : Point m_center ; int m_radius ; public : Circle ( const Point & center , int radius ) : m_center { center }, m_radius { radius } { } virtual std :: ostream & print ( std :: ostream & out ) const override { out << \"Circle(\" << m_center << \", radius \" << m_radius << ')' ; return out ; } }; int main () { Circle c { Point { 1 , 2 , 3 }, 7 }; std :: cout << c << '\\n' ; Triangle t { Point { 1 , 2 , 3 }, Point { 4 , 5 , 6 }, Point { 7 , 8 , 9 }}; std :: cout << t << '\\n' ; return 0 ; } 2c) \u5728\u4ee5\u4e0a\u7c7b( Point, Shape, Circle and Triangle )\u7684\u57fa\u7840\u4e0a\uff0c\u5b8c\u6210\u4ee5\u4e0b\u7a0b\u5e8f\uff1a #include <vector> #include <iostream> int main () { std :: vector < Shape *> v { new Circle { Point { 1 , 2 , 3 }, 7 }, new Triangle { Point { 1 , 2 , 3 }, Point { 4 , 5 , 6 }, Point { 7 , 8 , 9 }}, new Circle { Point { 4 , 5 , 6 }, 3 } }; // \u6253\u5370 vector \u4e2d\u7684\u6bcf\u4e2a `Shape` \uff0c\u5728\u8fd9\u91cc\u3002 std :: cout << \"The largest radius is: \" << getLargestRadius ( v ) << '\\n' ; // write this function // \u5220\u9664\u6bcf\u4e2avector\u4e2d\u7684\u5bf9\u8c61\uff0c\u5728\u8fd9\u91cc\u3002 return 0 ; } \u63d0\u793a\uff1a\u4f60\u5c06\u4f1a\u9700\u8981\u6dfb\u52a0\u4e00\u4e2a getRadius() \u51fd\u6570\u5230 Circle \u7c7b\uff0c\u5e76\u4e14\u5411\u4e0b\u8f6c\u5316 Shape* \u6210\u4e3a\u4e00\u4e2a Circle* \u6765\u8bbf\u95ee\u5b83\u3002 \u7b54\u6848\uff1a #include <vector> #include <iostream> class Point { private : int m_x {}; int m_y {}; int m_z {}; public : Point ( int x , int y , int z ) : m_x { x }, m_y { y }, m_z { z } { } friend std :: ostream & operator << ( std :: ostream & out , const Point & p ) { out << \"Point(\" << p . m_x << \", \" << p . m_y << \", \" << p . m_z << ')' ; return out ; } }; class Shape { public : virtual std :: ostream & print ( std :: ostream & out ) const = 0 ; friend std :: ostream & operator << ( std :: ostream & out , const Shape & p ) { return p . print ( out ); } virtual ~ Shape () = default ; }; class Triangle : public Shape { private : Point m_p1 {}; Point m_p2 {}; Point m_p3 {}; public : Triangle ( const Point & p1 , const Point & p2 , const Point & p3 ) : m_p1 { p1 }, m_p2 { p2 }, m_p3 { p3 } { } virtual std :: ostream & print ( std :: ostream & out ) const override { out << \"Triangle(\" << m_p1 << \", \" << m_p2 << \", \" << m_p3 << ')' ; return out ; } }; class Circle : public Shape { private : Point m_center {}; int m_radius {}; public : Circle ( const Point & center , int radius ) : m_center { center }, m_radius { radius } { } virtual std :: ostream & print ( std :: ostream & out ) const override { out << \"Circle(\" << m_center << \", radius \" << m_radius << ')' ; return out ; } int getRadius () const { return m_radius ; } }; // h/t to reader Olivier for this updated solution int getLargestRadius ( const std :: vector < Shape *> & v ) { int largestRadius { 0 }; // Loop through all the shapes in the vector for ( const auto * element : v ) { // // Ensure the dynamic cast succeeds by checking for a null pointer result if ( auto * c { dynamic_cast < Circle *> ( element ) }) { if ( c -> getRadius () > largestRadius ) largestRadius = c -> getRadius (); } } return largestRadius ; } int main () { std :: vector < Shape *> v { new Circle { Point { 1 , 2 , 3 }, 7 }, new Triangle { Point { 1 , 2 , 3 }, Point { 4 , 5 , 6 }, Point { 7 , 8 , 9 }}, new Circle { Point { 4 , 5 , 6 }, 3 } }; for ( const auto * element : v ) // element will be a Shape* std :: cout << * element << '\\n' ; std :: cout << \"The largest radius is: \" << getLargestRadius ( v ) << '\\n' ; for ( const auto * element : v ) delete element ; return 0 ; } -> 13.1-Function templates <- 12.10-Printing inherited classes using operator<<","title":"12.x \u5341\u4e8c\u7ae0\u7406\u89e3\u548c\u7ec3\u4e60"},{"location":"12-virtual-functions/12.x%20chapter-12-comprehensice-quiz/#12x","text":"\u6211\u4eec\u7684 C++ \u65c5\u7a0b\u5728\u7ee7\u627f\u548c\u865a\u51fd\u6570\u8fd9\u5757\u5df2\u7ecf\u7ed3\u675f\u4e86\u3002\u4e0d\u8981\u62c5\u5fc3\uff0c\u4eb2\u7231\u7684\u8bfb\u8005\uff0c\u56e0\u4e3a\u8fd8\u6709\u5927\u91cf\u5176\u4ed6 C++ \u7684\u9886\u57df\u7b49\u5f85\u6211\u4eec\u524d\u8fdb\uff0c\u63a2\u7d22\uff01","title":"12.x \u5341\u4e8c\u7ae0\u7406\u89e3\u548c\u7ec3\u4e60"},{"location":"12-virtual-functions/12.x%20chapter-12-comprehensice-quiz/#_1","text":"C++ \u5141\u8bb8\u4f60\u8bbe\u7f6e\u57fa\u7c7b\u6307\u9488\u548c\u5f15\u7528\u5230\u6d3e\u751f\u5bf9\u8c61\u3002\u8fd9\u662f\u5f88\u6709\u7528\u7684\uff0c\u5f53\u6211\u4eec\u60f3\u8981\u5199\u4e00\u4e2a\u51fd\u6570\u6216\u8005\u6570\u7ec4\uff0c\u53ef\u4ee5\u548c\u4efb\u4f55\u7c7b\u578b\u7684\u4ece\u57fa\u7c7b\u6d3e\u751f\u7684\u5bf9\u8c61\u642d\u914d\u3002\uff08This is useful when we want to write a function or array that can work with any type of object derived from a base class.\uff09 \u5982\u679c\u6ca1\u6709\u865a\u51fd\u6570\uff0c\u57fa\u7c7b\u6307\u5411\u6d3e\u751f\u7c7b\u7684\u6307\u9488\u548c\u5f15\u7528\u5c06\u4f1a\u53ea\u80fd\u8bbf\u95ee\u57fa\u7c7b\u6210\u5458\uff0c\u548c\u51fd\u6570\u3002 \u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u662f\u4e00\u4e2a\u7279\u6b8a\u7c7b\u578b\u7684\u51fd\u6570\u80fd\u89e3\u6790\u5230\u7ee7\u627f\u672b\u7aef\u7248\u672c\u7684\u51fd\u6570\uff08\u53eb\u505a\u91cd\u5199\uff09\u5b58\u5728\u4e8e\u57fa\u7c7b\u548c\u6d3e\u751f\u7c7b\u4e4b\u95f4\u3002\u60f3\u8981\u88ab\u8ba4\u4e3a\u662f\u4e00\u4e2a\u91cd\u5199\uff0c\u6d3e\u751f\u7c7b\u5fc5\u987b\u548c\u57fa\u7c7b\u865a\u51fd\u6570\u6709\u540c\u6837\u7684\u7b7e\u540d\u548c\u8fd4\u56de\u7c7b\u578b\u3002\u4e00\u4e2a\u4f8b\u5916\u5c31\u662f covariant return types \uff0c\u80fd\u591f\u5141\u8bb8\u4e00\u4e2a\u91cd\u5199\u8fd4\u56de\u4e00\u4e2a\u6307\u6d3e\u751f\u7c7b\u7684\u9488\u6216\u5f15\u7528\u5982\u679c\u57fa\u7c7b\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u57fa\u7c7b\u7684\u6307\u9488\u6216\u5f15\u7528\u3002 \u4e00\u4e2a\u51fd\u6570\u51fd\u6570\u60f3\u8981\u88ab\u91cd\u5199\uff0c\u5e94\u8be5\u6dfb\u52a0\u91cd\u5199\u6307\u793a\u7b26\u6765\u786e\u4fdd\u5b83\u786e\u5b9e\u91cd\u5199\u4e86\u3002 final \u6307\u793a\u7b26\u80fd\u591f\u88ab\u7528\u4f5c\u963b\u6b62\u4ece\u4e00\u4e2a\u8be5\u7c7b\u7684\u51fd\u6570\u88ab\u91cd\u5199\u3002 \u5982\u679c\u4f60\u60f3\u8981\u4f7f\u7528\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u4f60\u5e94\u8be5\u4f7f\u4f60\u7684\u6790\u6784\u51fd\u6570\u4e3a\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u5982\u679c\u4f60\u5220\u9664\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\uff0c\u8fd9\u6837\u505a\u53ef\u4ee5\u4f7f\u5408\u9002\u7684\u6790\u6784\u51fd\u6570\u88ab\u8c03\u7528\u3002 \u4f60\u53ef\u4ee5\u5ffd\u7565\u4e00\u4e2a\u865a\u51fd\u6570\u89e3\u6790\u901a\u8fc7\u4f7f\u7528 scope resolution opearator \u6765\u76f4\u63a5\u6307\u5b9a\u90a3\u4e2a\u7c7b\u7684\u51fd\u6570\u4f60\u60f3\u8981\u8c03\u7528\uff1a\u4f8b\u5982 base.Base::getName() Early binding \u65e9\u7ed1\u5b9a\u53d1\u751f\u5728\u7f16\u8bd1\u65f6\u76f4\u63a5\u68c0\u6d4b\u5230\u51fd\u6570\u8c03\u7528\uff0c\u7f16\u8bd1\u5668\u6216\u8005\u8fde\u63a5\u5668\u53ef\u4ee5\u76f4\u63a5\u89e3\u6790\u8fd9\u4e9b\u51fd\u6570\u8c03\u7528\u3002 Late binding \u53d1\u751f\u5728\u5f53\u4e00\u4e2a\u51fd\u6570\u6307\u9488\u88ab\u8c03\u7528\u662f\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u54ea\u4e2a\u51fd\u6570\u5c06\u4f1a\u88ab\u8c03\u7528\u4e0d\u53ef\u80fd\u5728\u8fd0\u884c\u4e4b\u524d\u786e\u5b9a\u3002\u865a\u51fd\u6570\u4f7f\u7528\u4e86 late binding \u548c\u4e00\u4e2a\u865a\u8868\u6765\u51b3\u5b9a\u54ea\u4e2a\u7248\u672c\u7684\u51fd\u6570\u5c06\u88ab\u8c03\u7528\u3002 \u4f7f\u7528\u865a\u51fd\u6570\u6709\u4e00\u5b9a\u7684\u82b1\u8d39\uff0c\u865a\u51fd\u6570\u7684\u8c03\u7528\u5c06\u82b1\u8d39\u66f4\u591a\u65f6\u95f4\uff0c\u5e76\u4e14\u865a\u8868\u4f1a\u5360\u7528\u4e00\u5b9a\u7684\u7a7a\u95f4\uff0c\u5728\u6bcf\u4e2a\u5305\u542b\u865a\u51fd\u6570\u7684\u5bf9\u8c61\u4e2d\u589e\u52a0\u4e86\u4e00\u4e2a\u6307\u9488\u3002 \u4e00\u4e2a\u865a\u51fd\u6570\u53ef\u4ee5\u88ab\u5b9a\u4e49\u4e3a\u7eaf\u865a\u51fd\u6570\uff08\u62bd\u8c61\u51fd\u6570\uff09\u901a\u8fc7\u6dfb\u52a0 =0 \u5728\u865a\u51fd\u6570\u7684\u5b9a\u4e49\u540e\u65b9\u3002\u5305\u542b\u7eaf\u865a\u51fd\u6570\u7684\u7c7b\u88ab\u53eb\u505a\u62bd\u8c61\u7c7b\uff0c\u8fd9\u79cd\u7c7b\u4e0d\u80fd\u88ab\u5b9e\u4f8b\u5316\u3002\u4e00\u4e2a\u7c7b\u7ee7\u627f\u4e8e\u62bd\u8c61\u7c7b\uff0c\u90a3\u4e48\u7eaf\u865a\u51fd\u6570\u5fc5\u987b\u88ab\u6b63\u786e\u7684\u5b9a\u4e49\uff0c\u5426\u5219\u8be5\u7c7b\u4e5f\u5c06\u88ab\u8ba4\u4e3a\u662f\u62bd\u8c61\u7c7b\u3002\u7eaf\u865a\u51fd\u6570\u4e5f\u53ef\u4ee5\u6709\u4e00\u4e2a\u51fd\u6570\u4f53\uff0c\u4f46\u662f\u4ed6\u4eec\u4ecd\u7136\u88ab\u8ba4\u4e3a\u662f\u62bd\u8c61\u7684\u3002 \u63a5\u53e3\u7c7b\u662f\u4e00\u4e2a\u6ca1\u6709\u6210\u5458\u53d8\u91cf\u5e76\u4e14\u5168\u662f\u7eaf\u865a\u51fd\u6570\u7684\u7c7b\u3002\u8fd9\u6837\u7684\u7c7b\u7684\u540d\u79f0\u901a\u5e38\u4ee5\u5927\u5199\u7684 I \u5f00\u5934\u3002 \u4e00\u4e2a\u865a\u57fa\u7c7b\u5728\u4e00\u4e2a\u5bf9\u8c61\u4e2d\u53ea\u80fd\u88ab\u5305\u542b\u4e00\u6b21\uff0c\u65e0\u8bba\u88ab\u4e00\u4e2a\u7c7b\u7ee7\u627f\u4e86\u591a\u5c11\u6b21\u3002 \u5f53\u4e00\u4e2a\u6d3e\u751f\u7c7b\u88ab\u8d4b\u503c\u5230\u57fa\u7c7b\u5bf9\u8c61\u65f6\uff0c\u57fa\u7c7b\u53ea\u80fd\u63a5\u6536\u5230\u6d3e\u751f\u7c7b\u4e2d\u57fa\u7c7b\u90e8\u5206\u7684\u62f7\u8d1d\u3002\u8fd9\u88ab\u53eb\u505a\u5bf9\u8c61\u5207\u5272\u3002 \u52a8\u6001\u8f6c\u6362\u53ef\u4ee5\u88ab\u7528\u6765\u8f6c\u6362\u4e00\u4e2a\u6307\u5411\u57fa\u7c7b\u7684\u6307\u9488\u6210\u4e3a\u4e00\u4e2a\u6307\u5411\u6d3e\u751f\u7c7b\u7684\u6307\u9488\uff0c\u8fd9\u88ab\u53eb\u505a\u5411\u4e0b\u8f6c\u6362 (downcasting)\u3002\u4e00\u4e2a\u5931\u8d25\u7684\u8f6c\u6362\u4f1a\u8fd4\u56de\u4e00\u4e2a\u7a7a\u6307\u9488\u3002 \u6d3e\u751f\u7c7b\u6700\u7b80\u5355\u7684\u91cd\u8f7d << \u8fd0\u7b97\u7b26\u7684\u65b9\u5f0f\u662f\u5199\u4e00\u4e2a\u91cd\u8f7d << \u4e3a\u6700\u9876\u90e8\u7684\u57fa\u7c7b\uff0c\u7136\u540e\u6dfb\u52a0\u4e00\u4e2a\u865a\u6210\u5458\u51fd\u6570\u6765\u6253\u5370\u3002 // \u8bd1\u8005\u6dfb\u52a0\u7684\u4ee3\u7801\u7247\u6bb5\uff1a virtual std :: ostream & print ( std :: ostream & in ) const = 0 ; friend std :: ostream & operator << ( std :: ostream & out , const Base & b ) { return b . print ( out ); } // \u7ee7\u627f\u5bf9\u8c61\u90fd\u53ea\u9700\u8981\u91cd\u5199print\u5373\u53ef\u3002","title":"\u7ae0\u8282\u603b\u7ed3"},{"location":"12-virtual-functions/12.x%20chapter-12-comprehensice-quiz/#quiz-time","text":"","title":"Quiz time"},{"location":"12-virtual-functions/12.x%20chapter-12-comprehensice-quiz/#quiz1","text":"\u4ee5\u4e0b\u7684\u6bcf\u4e2a\u7a0b\u5e8f\u90fd\u6709\u4e00\u4e9b\u7f3a\u9677\uff0c\u68c0\u67e5\u6bcf\u4e2a\u7a0b\u5e8f\uff08\u7528\u773c\u775b\u68c0\u67e5\uff0c\u4e0d\u8981\u7f16\u8bd1\uff09\u5e76\u4e14\u8bca\u65ad\u51fa\u8fd9\u4e2a\u7a0b\u5e8f\u6709\u4ec0\u4e48\u95ee\u9898\u3002\u6bcf\u4e2a\u7a0b\u5e8f\u7684\u8f93\u51fa\u90fd\u5e94\u8be5\u662f Derived \u3002 \u8bd1\u8005\u6ce8\uff1a\u539f\u7f51\u7ad9\u662f\u54cd\u5e94\u5f0f\u7684\u9690\u85cf\uff0c\u6298\u53e0\u4e86\u7b54\u6848\uff0c\u672c\u7f51\u7ad9\u65e0\u6cd5\u505a\u5230\uff0c\u56e0\u6b64\u8bf7\u5148\u5b8c\u6210\u4ee3\u7801\u9605\u8bfb\u518d\u5f80\u4e0b\u770b\u7b54\u6848\u63cf\u8ff0\uff0c\u6bcf\u4e2a\u9898\u7684\u7b54\u6848\u90fd\u5728\u4ee3\u7801\u63cf\u8ff0\u4e0b\u65b9\u3002 1a) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } const char * getName () const { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } const char * getName () const { return \"Derived\" ; } }; int main () { Derived d { 5 }; Base & b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481a Base::getName() \u4e0d\u662f\u865a\u51fd\u6570\uff0c \u56e0\u6b64 b.getName() \u4e0d\u4f1a\u89e3\u6790\u5e76\u8c03\u7528 Derived::getName(). 1b) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () const { return \"Derived\" ; } }; int main () { Derived d { 5 }; Base & b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481b Base::geetName() \u5e76\u6ca1\u6709\u5b9a\u4e49\u4e3aconst\uff0c\u800c Derived::getName() \u662f\u4e00\u4e2aconst\u51fd\u6570\uff0c\u56e0\u6b64 Derived::getName() \u4e0d\u662f\u4e00\u4e2a\u91cd\u5199(override) 1c) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () override { return \"Derived\" ; } }; int main () { Derived d { 5 }; Base b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481c d \u662f\u503c\u8d4b\u503c\u5230 b \uff0c\u5bfc\u81f4 d \u88ab\u5207\u5272\u3002 1d) #include <iostream> class Base final { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () override { return \"Derived\" ; } }; int main () { Derived d { 5 }; Base & b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481d Base \u88ab\u5b9a\u4e49\u4e3a final \uff0c\u56e0\u6b64 Derived \u4e0d\u80fd\u4ece\u5b83\u7ee7\u627f\u3002\u8fd9\u5c06\u4f1a\u9020\u6210\u7f16\u8bd1\u9519\u8bef\u3002 1e) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () = 0 ; }; const char * Derived :: getName () { return \"Derived\" ; } int main () { Derived d { 5 }; Base & b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481e Derived::getName() \u662f\u4e00\u4e2a\u7eaf\u865a\u51fd\u6570\uff08\u65e0\u51fd\u6570\u4f53\uff09\uff0c\u5e76\u4e14\u56e0\u6b64 Derived \u662f\u4e00\u4e2a\u62bd\u8c61\u7c7b (abstract class) \u56e0\u6b64\u4e0d\u80fd\u88ab\u5b9e\u4f8b\u5316\u3002 1f) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base ( value ) { } virtual const char * getName () { return \"Derived\" ; } }; int main () { auto * d { new Derived ( 5 ) }; Base * b { d }; std :: cout << b -> getName () << '\\n' ; delete b ; return 0 ; } \u7b54\u68481f \u8fd9\u4e2a\u7a0b\u5e8f\u5b9e\u9645\u4e0a\u7684\u786e\u53ef\u4ee5\u5f97\u5230\u6b63\u786e\u7684\u8f93\u51fa\uff0c\u4f46\u662f\u53c8\u4e0d\u540c\u7684\u7684\u95ee\u9898\u3002\u5f53\u6211\u4eec delete b \u662f\uff0c b \u662f\u4e00\u4e2a Base \u6307\u9488\uff0c\u4f46\u662f\u4ece\u6765\u6ca1\u6dfb\u52a0\u4e00\u4e2a\u865a\u6790\u6784\u51fd\u6570 (virtual destructor) \u5230\u57fa\u7c7b\u3002\u56e0\u6b64\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u5220\u9664\u4e86 Derived \u5bf9\u8c61\u4e2d\u7684 Base \u90e8\u5206\uff0c\u5e76\u4e14 Derived \u90e8\u5206\u7559\u5728\u5185\u5b58\u4e2d\uff08\u6cc4\u9732\uff09\u3002","title":"Quiz1"},{"location":"12-virtual-functions/12.x%20chapter-12-comprehensice-quiz/#quiz2","text":"2a) \u521b\u5efa\u4e00\u4e2a\u53eb\u505a\u5f62\u72b6\u7684\u62bd\u8c61\u7c7b\uff0c\u8fd9\u4e2a\u7c7b\u5e94\u8be5\u6709\u4e09\u4e2a\u51fd\u6570\uff1a\u4e00\u4e2a\u7eaf\u865a\u51fd\u6570 print \u4f20\u5165\u5e76\u4e14\u8fd4\u56de\u4e00\u4e2a std::ostream \uff0c\u91cd\u8f7d <<\u64cd\u4f5c\u7b26 operator<< \u548c\u4e00\u4e2a\u865a\u6790\u6784\u51fd\u6570\u3002 \u7b54\u6848 class Shape { public : // virtual const char* getShapeName() const = 0; virtual std :: ostream & print ( std :: ostream & out ) const = 0 ; friend std :: ostream & operator << ( std :: ostream & out , const Shape & p ) { return p . print ( out ); } virtual ~ Shape () {} }; 2b) \u4ece Shape \u6d3e\u751f\u4e24\u4e2a\u7c7b\uff1a\u4e00\u4e2a Triangle \u548c\u4e00\u4e2a Circle \u3002 Triangle \u5e94\u8be5\u6709\u4e09\u4e2a Point \u4f5c\u4e3a\u6210\u5458\u3002 Circle \u5e94\u8be5\u6709\u4e00\u4e2a Point \u5706\u5fc3\uff0c\u548c\u4e00\u4e2a\u6574\u6570\u534a\u5f84 radius \uff0c\u91cd\u8f7d print() \u51fd\u6570\u4f7f\u5f97\u4ee5\u4e0b\u7a0b\u5e8f\u80fd\u591f\u8fd0\u884c\u3002 int main () { Circle c { Point { 1 , 2 , 3 }, 7 }; std :: cout << c << '\\n' ; Triangle t { Point { 1 , 2 , 3 }, Point { 4 , 5 , 6 }, Point { 7 , 8 , 9 }}; std :: cout << t << '\\n' ; return 0 ; } \u6837\u4f8b\u5e94\u8be5\u6253\u5370\uff1a Circle(Point(1, 2, 3), radius 7) Triangle(Point(1, 2, 3), Point(4, 5, 6), Point(7, 8, 9)) \u8fd9\u662f Point \u7c7b\uff1a class Point { private : int m_x { 0 }; int m_y { 0 }; int m_z { 0 }; public : Point ( int x , int y , int z ) : m_x { x }, m_y { y }, m_z { z } { } friend std :: ostream & operator << ( std :: ostream & out , const Point & p ) { out << \"Point(\" << p . m_x << \", \" << p . m_y << \", \" << p . m_z << ')' ; return out ; } }; \u7b54\u6848\uff1a #include <iostream> class Point { private : int m_x { 0 }; int m_y { 0 }; int m_z { 0 }; public : Point ( int x , int y , int z ) : m_x { x }, m_y { y }, m_z { z } { } friend std :: ostream & operator << ( std :: ostream & out , const Point & p ) { out << \"Point(\" << p . m_x << \", \" << p . m_y << \", \" << p . m_z << ')' ; return out ; } }; class Shape { public : virtual std :: ostream & print ( std :: ostream & out ) const = 0 ; friend std :: ostream & operator << ( std :: ostream & out , const Shape & p ) { return p . print ( out ); } virtual ~ Shape () = default ; }; class Triangle : public Shape { private : Point m_p1 {}; Point m_p2 {}; Point m_p3 {}; public : Triangle ( const Point & p1 , const Point & p2 , const Point & p3 ) : m_p1 { p1 }, m_p2 { p2 }, m_p3 { p3 } { } virtual std :: ostream & print ( std :: ostream & out ) const override { out << \"Triangle(\" << m_p1 << \", \" << m_p2 << \", \" << m_p3 << ')' ; return out ; } }; class Circle : public Shape { private : Point m_center ; int m_radius ; public : Circle ( const Point & center , int radius ) : m_center { center }, m_radius { radius } { } virtual std :: ostream & print ( std :: ostream & out ) const override { out << \"Circle(\" << m_center << \", radius \" << m_radius << ')' ; return out ; } }; int main () { Circle c { Point { 1 , 2 , 3 }, 7 }; std :: cout << c << '\\n' ; Triangle t { Point { 1 , 2 , 3 }, Point { 4 , 5 , 6 }, Point { 7 , 8 , 9 }}; std :: cout << t << '\\n' ; return 0 ; } 2c) \u5728\u4ee5\u4e0a\u7c7b( Point, Shape, Circle and Triangle )\u7684\u57fa\u7840\u4e0a\uff0c\u5b8c\u6210\u4ee5\u4e0b\u7a0b\u5e8f\uff1a #include <vector> #include <iostream> int main () { std :: vector < Shape *> v { new Circle { Point { 1 , 2 , 3 }, 7 }, new Triangle { Point { 1 , 2 , 3 }, Point { 4 , 5 , 6 }, Point { 7 , 8 , 9 }}, new Circle { Point { 4 , 5 , 6 }, 3 } }; // \u6253\u5370 vector \u4e2d\u7684\u6bcf\u4e2a `Shape` \uff0c\u5728\u8fd9\u91cc\u3002 std :: cout << \"The largest radius is: \" << getLargestRadius ( v ) << '\\n' ; // write this function // \u5220\u9664\u6bcf\u4e2avector\u4e2d\u7684\u5bf9\u8c61\uff0c\u5728\u8fd9\u91cc\u3002 return 0 ; } \u63d0\u793a\uff1a\u4f60\u5c06\u4f1a\u9700\u8981\u6dfb\u52a0\u4e00\u4e2a getRadius() \u51fd\u6570\u5230 Circle \u7c7b\uff0c\u5e76\u4e14\u5411\u4e0b\u8f6c\u5316 Shape* \u6210\u4e3a\u4e00\u4e2a Circle* \u6765\u8bbf\u95ee\u5b83\u3002 \u7b54\u6848\uff1a #include <vector> #include <iostream> class Point { private : int m_x {}; int m_y {}; int m_z {}; public : Point ( int x , int y , int z ) : m_x { x }, m_y { y }, m_z { z } { } friend std :: ostream & operator << ( std :: ostream & out , const Point & p ) { out << \"Point(\" << p . m_x << \", \" << p . m_y << \", \" << p . m_z << ')' ; return out ; } }; class Shape { public : virtual std :: ostream & print ( std :: ostream & out ) const = 0 ; friend std :: ostream & operator << ( std :: ostream & out , const Shape & p ) { return p . print ( out ); } virtual ~ Shape () = default ; }; class Triangle : public Shape { private : Point m_p1 {}; Point m_p2 {}; Point m_p3 {}; public : Triangle ( const Point & p1 , const Point & p2 , const Point & p3 ) : m_p1 { p1 }, m_p2 { p2 }, m_p3 { p3 } { } virtual std :: ostream & print ( std :: ostream & out ) const override { out << \"Triangle(\" << m_p1 << \", \" << m_p2 << \", \" << m_p3 << ')' ; return out ; } }; class Circle : public Shape { private : Point m_center {}; int m_radius {}; public : Circle ( const Point & center , int radius ) : m_center { center }, m_radius { radius } { } virtual std :: ostream & print ( std :: ostream & out ) const override { out << \"Circle(\" << m_center << \", radius \" << m_radius << ')' ; return out ; } int getRadius () const { return m_radius ; } }; // h/t to reader Olivier for this updated solution int getLargestRadius ( const std :: vector < Shape *> & v ) { int largestRadius { 0 }; // Loop through all the shapes in the vector for ( const auto * element : v ) { // // Ensure the dynamic cast succeeds by checking for a null pointer result if ( auto * c { dynamic_cast < Circle *> ( element ) }) { if ( c -> getRadius () > largestRadius ) largestRadius = c -> getRadius (); } } return largestRadius ; } int main () { std :: vector < Shape *> v { new Circle { Point { 1 , 2 , 3 }, 7 }, new Triangle { Point { 1 , 2 , 3 }, Point { 4 , 5 , 6 }, Point { 7 , 8 , 9 }}, new Circle { Point { 4 , 5 , 6 }, 3 } }; for ( const auto * element : v ) // element will be a Shape* std :: cout << * element << '\\n' ; std :: cout << \"The largest radius is: \" << getLargestRadius ( v ) << '\\n' ; for ( const auto * element : v ) delete element ; return 0 ; } -> 13.1-Function templates <- 12.10-Printing inherited classes using operator<<","title":"Quiz2"},{"location":"13-templates/","text":"\u5341\u4e09\u7ae0 \u6a21\u677f \u00b6 13.1 Function Templates","title":"\u5341\u4e09\u7ae0 \u6a21\u677f"},{"location":"13-templates/#_1","text":"13.1 Function Templates","title":"\u5341\u4e09\u7ae0 \u6a21\u677f"},{"location":"13-templates/13.1-function-templates/","text":"13.1 \u51fd\u6570\u6a21\u677f Function templates \u00b6 By Alex on April 18 th , 2008 | last modified by Alex on January 23 rd , 2020 | \u7ffb\u8bd1by dashjay 7\u670810\u65e5 \u4e3a\u4ec0\u4e48\u9700\u8981\u51fd\u6570\u6a21\u677f \u00b6 \u5728\u4e4b\u524d\u7684\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u5b66\u5230\u4e86\u5982\u4f55\u5199\u51fd\u6570\u548c\u7c7b\uff0c\u8fd9\u4e9b\u53ef\u4ee5\u5e2e\u52a9\u6210\u5458\u4eec\u66f4\u5bb9\u6613\u548c\u66f4\u5b89\u5168\u7684\u5199\u4ee3\u7801\uff0c\u5199\u51fa\u66f4\u52a0\u6613\u4e8e\u7ef4\u62a4\u7684\u4ee3\u7801\u3002\u5bf9\u4e8e\u9ad8\u6548\u7f16\u7a0b\uff0c\u51fd\u6570\u548c\u7c7b\u90fd\u975e\u5e38\u5f3a\u5927\u548c\u65b9\u4fbf\u7684\u5de5\u5177\uff0c\u5728\u4e00\u4e9b\u7279\u6b8a\u7684\u60c5\u51b5\u4e0b\uff0c\u4ed6\u4eec\u53ef\u80fd\u4ecd\u7136\u6709\u70b9\u53d7\u9650\u5236\uff0c\u56e0\u4e3a C++ \u8981\u6c42\u4f60\u6307\u5b9a\u6240\u6709\u53c2\u6570\u7684\u7c7b\u578b\u3002 \u4f8b\u5982\uff0c\u5047\u5982\u4f60\u60f3\u5199\u4e00\u4e2a\u51fd\u6570\u6765\u8ba1\u7b97\u4e24\u4e2a\u6570\u4e2d\u7684\u6700\u5927\u503c\uff0c\u4f60\u53ef\u80fd\u4f1a\u50cf\u8fd9\u6837\u505a int max ( int x , int y ) { return ( x > y ) ? x : y ; } \u8fd9\u4e2a\u51fd\u6570\u5b8c\u7f8e\u80dc\u4efb\u5de5\u4f5c\u2014\u2014\u5bf9\u4e8e\u6574\u578b\u6765\u8bf4\u3002\u5982\u679c\u4e4b\u540e\u4f60\u60f3\u5b9e\u73b0\u4e00\u4e2a max() \u51fd\u6570\uff0c\u9700\u8981\u5728 doubles \u4e0b\u5de5\u4f5c\uff1f\u6839\u636e\u4f20\u7edf\uff0c\u7b54\u6848\u53ef\u80fd\u662f\u91cd\u8f7dmac\u51fd\u6570\uff0c\u5e76\u4e14\u521b\u9020\u4e00\u4e2a\u65b0\u7684 doubles \u7684\u7248\u672c\uff1a double max ( double x , double y ) { return ( x > y ) ? x : y ; } \u6211\u4eec\u6ce8\u610f\u5230 double \u7248\u672c\u7684 maximum() \u548c int \u7248\u672c\u5b8c\u5168\u76f8\u540c\uff01\u4e8b\u5b9e\u4e0a\uff0c\u8fd9\u4e2a\u5b9e\u73b0\u4f1a\u5728\u6240\u6709\u4e0d\u540c\u7c7b\u578b\u4e0b\u5de5\u4f5c\uff1achars\uff0cints\uff0cdoubles\uff0c\u5e76\u4e14\u5982\u679c\u4f60\u5df2\u7ecf\u91cd\u8f7d\u4e86 > \u8fd0\u7b97\u7b26\uff0c\u8fd9\u4e9b\u7c7b\u578b\u4e5f\u53ef\u4ee5\uff01\u7136\u800c\uff0c\u56e0\u4e3a C++ \u8981\u6c42\u4f60\u6307\u5b9a\u51fd\u6570\u7684\u53d8\u91cf\uff0c\u4f60\u5c31\u4f1a\u56f0\u5728\u7ed9\u6bcf\u4e00\u4e2a\u4f60\u8981\u7528\u5230\u7684\u7c7b\u578b\u5199\u4e00\u4e2a\u540c\u6837\u7684\u51fd\u6570\u3002 \u5b9e\u73b0\u4e00\u7cfb\u5217\u4e0d\u540c\u201c\u98ce\u5473\u201d\u7684\u76f8\u540c\u51fd\u6570\u2014\u2014\u4ec5\u4ec5\u53ea\u662f\u53c2\u6570\u7c7b\u578b\u4e0d\u540c\uff0c\u8fd9\u4ef6\u4e8b\u53ef\u80fd\u4f1a\u5728\u7ef4\u62a4\u4e0a\u4f1a\u975e\u5e38\u4ee4\u4eba\u5934\u75bc\uff0c\u4e5f\u5341\u5206\u6d6a\u8d39\u65f6\u95f4\uff0c\u8fd9\u4e5f\u8fdd\u53cd\u4e86\u901a\u5e38\u7f16\u7a0b\u7684\u7eb2\u8981\uff0c\u91cd\u590d\u7684\u4ee3\u7801\u5e94\u8be5\u88ab\u5c3d\u53ef\u80fd\u7684\u51cf\u5c0f\u3002\u5982\u679c\u80fd\u591f\u5199\u4e00\u4e2a\u51fd\u6570\u5c31\u5728\u4efb\u610f\u7c7b\u578b\u4e0b\u5de5\u4f5c\uff0c\u90a3\u4f1a\u4e0d\u4f1a\u5f88\u68d2\uff1f \u6b22\u8fce\u6765\u5230\u6a21\u677f\u7684\u4e16\u754c\u3002 \u4ec0\u4e48\u662f\u51fd\u6570\u6a21\u677f \u00b6 If you were to look up the word \u201ctemplate\u201d in the dictionary, you\u2019d find a definition that was similar to the following: \u201ca template is a model that serves as a pattern for creating similar objects\u201d. One type of template that is very easy to understand is that of a stencil. A stencil is an object (e.g. a piece of cardboard) with a shape cut out of it (eg. the letter J). By placing the stencil on top of another object, then spraying paint through the hole, you can very quickly produce stenciled patterns in many different colors! Note that you only need to create a given stencil once -- you can then use it as many times as you like, to create stenciled patterns in whatever color(s) you like. Even better, you don\u2019t have to decide the color of the stenciled pattern you want to create until you decide to actually use the stencil. \u5982\u679c\u4f60\u5728\u8bcd\u5178\u91cc\u67e5\u201c\u6a21\u677f\u201d\u8fd9\u4e2a\u8bfb\u5355\u8bcd\uff0c\u4f60\u4f1a\u53d1\u73b0\u5b83\u7684\u5b9a\u4e49\u4f1a\u50cf\u8fd9\u6837\uff1a\u201c\u201d In C++, function templates are functions that serve as a pattern for creating other similar functions. The basic idea behind function templates is to create a function without having to specify the exact type(s) of some or all of the variables. Instead, we define the function using placeholder types, called template type parameters. Once we have created a function using these placeholder types, we have effectively created a \u201cfunction stencil\u201d. When you call a template function, the compiler \u201cstencils\u201d out a copy of the template, replacing the placeholder types with the actual variable types from the parameters in your function call! Using this methodology, the compiler can create multiple \u201cflavors\u201d of a function from one template! We\u2019ll take a look at this process in more detail in the next lesson. Creating function templates in C++ At this point, you\u2019re probably wondering how to actually create function templates in C++. It turns out, it\u2019s not all that difficult. Let\u2019s take a look at the int version of max() again: int max ( int x , int y ) { return ( x > y ) ? x : y ; } Note that there are 3 places where specific types are used: parameters x, y, and the return value all specify that they must be integers. To create a function template, we\u2019re going to replace these specific types with placeholder types. In this case, because we have only one type that needs replacing (int), we only need one template type parameter. You can name your placeholder types almost anything you want, so long as it\u2019s not a reserved word. However, in C++, it\u2019s customary to name your template types the letter T (short for \u201cType\u201d). Here\u2019s our new function with a placeholder type: T max ( T x , T y ) { return ( x > y ) ? x : y ; } This is a good start -- however, it won\u2019t compile because the compiler doesn\u2019t know what \u201cT\u201d is! In order to make this work, we need to tell the compiler two things: First, that this is a template definition, and second, that T is a placeholder type. We can do both of those things in one line, using what is called a template parameter declaration: template < typename T > // this is the template parameter declaration T max ( T x , T y ) { return ( x > y ) ? x : y ; } Believe it or not, that\u2019s all we need. This will compile! Now, let\u2019s take a slightly closer look at the template parameter declaration. We start with the keyword template -- this tells the compiler that what follows is going to be a list of template parameters. We place all of our parameters inside angled brackets (<>). To create a template type parameter, use either the keyword typename or class. There is no difference between the two keywords in this context, so which you use is up to you. Note that if you use the class keyword, the type passed in does not actually have to be a class (it can be a fundamental variable, pointer, or anything else that matches). Then you name your type (usually \u201cT\u201d). If the template function uses multiple template type parameter, they can be separated by commas: template < typename T1 , typename T2 > // template function here For classes using more than one type, it\u2019s common to see them named \u201cT1\u201d and \u201cT2\u201d, or other single capital letter names, such as \u201cS\u201d. One final note: Because the function argument passed in for type T could be a class type, and it\u2019s generally not a good idea to pass classes by value, it would be better to make the parameters and return types of our templated function const references: template < typename T > const T & max ( const T & x , const T & y ) { return ( x > y ) ? x : y ; } Using function templates Using a function template is extremely straightforward -- you can use it just like any other function. Here\u2019s a full program using our template function: # include <iostream> template < typename T > const T & max ( const T & x , const T & y ) { return ( x > y ) ? x : y ; } int main () { int i = max ( 3 , 7 ); // returns 7 std :: cout << i << '\\n' ; double d = max ( 6.34 , 18.523 ); // returns 18.523 std :: cout << d << '\\n' ; char ch = max ( 'a' , '6' ); // returns 'a' std :: cout << ch << '\\n' ; return 0 ; } This will print: 7 18.523 a Note that all three of these calls to max() have parameters of different types! Because we\u2019ve called the function with 3 different types, the compiler will use the template definition to create 3 different versions of this function: one with int parameters (named max ), one with double parameters (named max ), and one with char parameters (named max ). Note that you don\u2019t need to explicitly specify the template type in the function name (e.g. the part of max ) so long as the compiler can deduce it from the parameter types. Summary As you can see, template functions can save a lot of time, because you only need to write one function, and it will work with many different types. Once you get used to writing function templates, you\u2019ll find they actually don\u2019t take any longer to write than functions with actual types. Template functions reduce code maintenance, because duplicate code is reduced significantly. And finally, template functions can be safer, because there is no need to copy functions and change types by hand whenever you need the function to work with a new type! Template functions do have a few drawbacks, and we would be remiss not to mention them. First, some older compilers do not have very good template support. However, this downside is no longer as much of a problem as it used to be. Second, template functions often produce crazy-looking error messages that are much harder to decipher than those of regular functions (we\u2019ll see an example of this in the next lesson). Third, template functions can increase your compile time and code size, as a single template might be \u201crealized\u201d and recompiled in many files (there are ways to work around this one). However, these drawbacks are fairly minor compared with the power and flexibility templates bring to your programming toolkit! Note: The standard library already comes with a templated max() function (in the algorithm header), so you don\u2019t have to write your own (unless you want to). If you do write your own, note the potential for naming conflicts if you use the statement \u201cusing namespace std;\u201d, as the compiler will be unable to tell whether you want your version of max() or std::max(). In the rest of this chapter, we\u2019ll continue to explore the topic of templates.","title":"13.1 \u51fd\u6570\u6a21\u677f Function templates"},{"location":"13-templates/13.1-function-templates/#131-function-templates","text":"By Alex on April 18 th , 2008 | last modified by Alex on January 23 rd , 2020 | \u7ffb\u8bd1by dashjay 7\u670810\u65e5","title":"13.1 \u51fd\u6570\u6a21\u677f Function templates"},{"location":"13-templates/13.1-function-templates/#_1","text":"\u5728\u4e4b\u524d\u7684\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u5b66\u5230\u4e86\u5982\u4f55\u5199\u51fd\u6570\u548c\u7c7b\uff0c\u8fd9\u4e9b\u53ef\u4ee5\u5e2e\u52a9\u6210\u5458\u4eec\u66f4\u5bb9\u6613\u548c\u66f4\u5b89\u5168\u7684\u5199\u4ee3\u7801\uff0c\u5199\u51fa\u66f4\u52a0\u6613\u4e8e\u7ef4\u62a4\u7684\u4ee3\u7801\u3002\u5bf9\u4e8e\u9ad8\u6548\u7f16\u7a0b\uff0c\u51fd\u6570\u548c\u7c7b\u90fd\u975e\u5e38\u5f3a\u5927\u548c\u65b9\u4fbf\u7684\u5de5\u5177\uff0c\u5728\u4e00\u4e9b\u7279\u6b8a\u7684\u60c5\u51b5\u4e0b\uff0c\u4ed6\u4eec\u53ef\u80fd\u4ecd\u7136\u6709\u70b9\u53d7\u9650\u5236\uff0c\u56e0\u4e3a C++ \u8981\u6c42\u4f60\u6307\u5b9a\u6240\u6709\u53c2\u6570\u7684\u7c7b\u578b\u3002 \u4f8b\u5982\uff0c\u5047\u5982\u4f60\u60f3\u5199\u4e00\u4e2a\u51fd\u6570\u6765\u8ba1\u7b97\u4e24\u4e2a\u6570\u4e2d\u7684\u6700\u5927\u503c\uff0c\u4f60\u53ef\u80fd\u4f1a\u50cf\u8fd9\u6837\u505a int max ( int x , int y ) { return ( x > y ) ? x : y ; } \u8fd9\u4e2a\u51fd\u6570\u5b8c\u7f8e\u80dc\u4efb\u5de5\u4f5c\u2014\u2014\u5bf9\u4e8e\u6574\u578b\u6765\u8bf4\u3002\u5982\u679c\u4e4b\u540e\u4f60\u60f3\u5b9e\u73b0\u4e00\u4e2a max() \u51fd\u6570\uff0c\u9700\u8981\u5728 doubles \u4e0b\u5de5\u4f5c\uff1f\u6839\u636e\u4f20\u7edf\uff0c\u7b54\u6848\u53ef\u80fd\u662f\u91cd\u8f7dmac\u51fd\u6570\uff0c\u5e76\u4e14\u521b\u9020\u4e00\u4e2a\u65b0\u7684 doubles \u7684\u7248\u672c\uff1a double max ( double x , double y ) { return ( x > y ) ? x : y ; } \u6211\u4eec\u6ce8\u610f\u5230 double \u7248\u672c\u7684 maximum() \u548c int \u7248\u672c\u5b8c\u5168\u76f8\u540c\uff01\u4e8b\u5b9e\u4e0a\uff0c\u8fd9\u4e2a\u5b9e\u73b0\u4f1a\u5728\u6240\u6709\u4e0d\u540c\u7c7b\u578b\u4e0b\u5de5\u4f5c\uff1achars\uff0cints\uff0cdoubles\uff0c\u5e76\u4e14\u5982\u679c\u4f60\u5df2\u7ecf\u91cd\u8f7d\u4e86 > \u8fd0\u7b97\u7b26\uff0c\u8fd9\u4e9b\u7c7b\u578b\u4e5f\u53ef\u4ee5\uff01\u7136\u800c\uff0c\u56e0\u4e3a C++ \u8981\u6c42\u4f60\u6307\u5b9a\u51fd\u6570\u7684\u53d8\u91cf\uff0c\u4f60\u5c31\u4f1a\u56f0\u5728\u7ed9\u6bcf\u4e00\u4e2a\u4f60\u8981\u7528\u5230\u7684\u7c7b\u578b\u5199\u4e00\u4e2a\u540c\u6837\u7684\u51fd\u6570\u3002 \u5b9e\u73b0\u4e00\u7cfb\u5217\u4e0d\u540c\u201c\u98ce\u5473\u201d\u7684\u76f8\u540c\u51fd\u6570\u2014\u2014\u4ec5\u4ec5\u53ea\u662f\u53c2\u6570\u7c7b\u578b\u4e0d\u540c\uff0c\u8fd9\u4ef6\u4e8b\u53ef\u80fd\u4f1a\u5728\u7ef4\u62a4\u4e0a\u4f1a\u975e\u5e38\u4ee4\u4eba\u5934\u75bc\uff0c\u4e5f\u5341\u5206\u6d6a\u8d39\u65f6\u95f4\uff0c\u8fd9\u4e5f\u8fdd\u53cd\u4e86\u901a\u5e38\u7f16\u7a0b\u7684\u7eb2\u8981\uff0c\u91cd\u590d\u7684\u4ee3\u7801\u5e94\u8be5\u88ab\u5c3d\u53ef\u80fd\u7684\u51cf\u5c0f\u3002\u5982\u679c\u80fd\u591f\u5199\u4e00\u4e2a\u51fd\u6570\u5c31\u5728\u4efb\u610f\u7c7b\u578b\u4e0b\u5de5\u4f5c\uff0c\u90a3\u4f1a\u4e0d\u4f1a\u5f88\u68d2\uff1f \u6b22\u8fce\u6765\u5230\u6a21\u677f\u7684\u4e16\u754c\u3002","title":"\u4e3a\u4ec0\u4e48\u9700\u8981\u51fd\u6570\u6a21\u677f"},{"location":"13-templates/13.1-function-templates/#_2","text":"If you were to look up the word \u201ctemplate\u201d in the dictionary, you\u2019d find a definition that was similar to the following: \u201ca template is a model that serves as a pattern for creating similar objects\u201d. One type of template that is very easy to understand is that of a stencil. A stencil is an object (e.g. a piece of cardboard) with a shape cut out of it (eg. the letter J). By placing the stencil on top of another object, then spraying paint through the hole, you can very quickly produce stenciled patterns in many different colors! Note that you only need to create a given stencil once -- you can then use it as many times as you like, to create stenciled patterns in whatever color(s) you like. Even better, you don\u2019t have to decide the color of the stenciled pattern you want to create until you decide to actually use the stencil. \u5982\u679c\u4f60\u5728\u8bcd\u5178\u91cc\u67e5\u201c\u6a21\u677f\u201d\u8fd9\u4e2a\u8bfb\u5355\u8bcd\uff0c\u4f60\u4f1a\u53d1\u73b0\u5b83\u7684\u5b9a\u4e49\u4f1a\u50cf\u8fd9\u6837\uff1a\u201c\u201d In C++, function templates are functions that serve as a pattern for creating other similar functions. The basic idea behind function templates is to create a function without having to specify the exact type(s) of some or all of the variables. Instead, we define the function using placeholder types, called template type parameters. Once we have created a function using these placeholder types, we have effectively created a \u201cfunction stencil\u201d. When you call a template function, the compiler \u201cstencils\u201d out a copy of the template, replacing the placeholder types with the actual variable types from the parameters in your function call! Using this methodology, the compiler can create multiple \u201cflavors\u201d of a function from one template! We\u2019ll take a look at this process in more detail in the next lesson. Creating function templates in C++ At this point, you\u2019re probably wondering how to actually create function templates in C++. It turns out, it\u2019s not all that difficult. Let\u2019s take a look at the int version of max() again: int max ( int x , int y ) { return ( x > y ) ? x : y ; } Note that there are 3 places where specific types are used: parameters x, y, and the return value all specify that they must be integers. To create a function template, we\u2019re going to replace these specific types with placeholder types. In this case, because we have only one type that needs replacing (int), we only need one template type parameter. You can name your placeholder types almost anything you want, so long as it\u2019s not a reserved word. However, in C++, it\u2019s customary to name your template types the letter T (short for \u201cType\u201d). Here\u2019s our new function with a placeholder type: T max ( T x , T y ) { return ( x > y ) ? x : y ; } This is a good start -- however, it won\u2019t compile because the compiler doesn\u2019t know what \u201cT\u201d is! In order to make this work, we need to tell the compiler two things: First, that this is a template definition, and second, that T is a placeholder type. We can do both of those things in one line, using what is called a template parameter declaration: template < typename T > // this is the template parameter declaration T max ( T x , T y ) { return ( x > y ) ? x : y ; } Believe it or not, that\u2019s all we need. This will compile! Now, let\u2019s take a slightly closer look at the template parameter declaration. We start with the keyword template -- this tells the compiler that what follows is going to be a list of template parameters. We place all of our parameters inside angled brackets (<>). To create a template type parameter, use either the keyword typename or class. There is no difference between the two keywords in this context, so which you use is up to you. Note that if you use the class keyword, the type passed in does not actually have to be a class (it can be a fundamental variable, pointer, or anything else that matches). Then you name your type (usually \u201cT\u201d). If the template function uses multiple template type parameter, they can be separated by commas: template < typename T1 , typename T2 > // template function here For classes using more than one type, it\u2019s common to see them named \u201cT1\u201d and \u201cT2\u201d, or other single capital letter names, such as \u201cS\u201d. One final note: Because the function argument passed in for type T could be a class type, and it\u2019s generally not a good idea to pass classes by value, it would be better to make the parameters and return types of our templated function const references: template < typename T > const T & max ( const T & x , const T & y ) { return ( x > y ) ? x : y ; } Using function templates Using a function template is extremely straightforward -- you can use it just like any other function. Here\u2019s a full program using our template function: # include <iostream> template < typename T > const T & max ( const T & x , const T & y ) { return ( x > y ) ? x : y ; } int main () { int i = max ( 3 , 7 ); // returns 7 std :: cout << i << '\\n' ; double d = max ( 6.34 , 18.523 ); // returns 18.523 std :: cout << d << '\\n' ; char ch = max ( 'a' , '6' ); // returns 'a' std :: cout << ch << '\\n' ; return 0 ; } This will print: 7 18.523 a Note that all three of these calls to max() have parameters of different types! Because we\u2019ve called the function with 3 different types, the compiler will use the template definition to create 3 different versions of this function: one with int parameters (named max ), one with double parameters (named max ), and one with char parameters (named max ). Note that you don\u2019t need to explicitly specify the template type in the function name (e.g. the part of max ) so long as the compiler can deduce it from the parameter types. Summary As you can see, template functions can save a lot of time, because you only need to write one function, and it will work with many different types. Once you get used to writing function templates, you\u2019ll find they actually don\u2019t take any longer to write than functions with actual types. Template functions reduce code maintenance, because duplicate code is reduced significantly. And finally, template functions can be safer, because there is no need to copy functions and change types by hand whenever you need the function to work with a new type! Template functions do have a few drawbacks, and we would be remiss not to mention them. First, some older compilers do not have very good template support. However, this downside is no longer as much of a problem as it used to be. Second, template functions often produce crazy-looking error messages that are much harder to decipher than those of regular functions (we\u2019ll see an example of this in the next lesson). Third, template functions can increase your compile time and code size, as a single template might be \u201crealized\u201d and recompiled in many files (there are ways to work around this one). However, these drawbacks are fairly minor compared with the power and flexibility templates bring to your programming toolkit! Note: The standard library already comes with a templated max() function (in the algorithm header), so you don\u2019t have to write your own (unless you want to). If you do write your own, note the potential for naming conflicts if you use the statement \u201cusing namespace std;\u201d, as the compiler will be unable to tell whether you want your version of max() or std::max(). In the rest of this chapter, we\u2019ll continue to explore the topic of templates.","title":"\u4ec0\u4e48\u662f\u51fd\u6570\u6a21\u677f"},{"location":"13-templates/13.2-function-template-instances/","text":"13.2 \u51fd\u6570\u6a21\u677f\u7684\u5b9e\u4f8b\u5316 \u00b6 It\u2019s worth taking a brief look at how template functions are implemented in C++, because future lessons will build off of some of these concepts. It turns out that C++ does not compile the template function directly. Instead, at compile time, when the compiler encounters a call to a template function, it replicates the template function and replaces the template type parameters with actual types. The function with actual types is called a function template instance. Let\u2019s take a look at an example of this process. First, we have a templated function: template < typename T > // this is the template parameter declaration const T & max ( const T & x , const T & y ) { return ( x > y ) ? x : y ; } When compiling your program, the compiler encounters a call to the templated function: int i { max ( 3 , 7 ) }; // calls max(int, int) The compiler says, \u201coh, we want to call max(int, int)\u201d. The compiler replicates the function template and creates the template instance max(int, int): const int & max ( const int & x , const int & y ) { return ( x > y ) ? x : y ; } This is now a \u201cnormal function\u201d that can be compiled into machine language. Now, let\u2019s say later in your code, you called max() again using a different type: double d { max ( 6.34 , 18.523 ) }; // calls max(double, double) C++ automatically creates a template instance for max(double, double): const double & max ( const double & x , const double & y ) { return ( x > y ) ? x : y ; } and then compiles it. The compiler is smart enough to know it only needs to create one template instance per set of unique type parameters (per file). It\u2019s also worth noting that if you create a template function but do not call it, no template instances will be created. Operators, function calls, and function templates Template functions will work with both built-in types (e.g. char, int, double, etc\u2026) and classes, with one caveat. When the compiler compiles the template instance, it compiles it just like a normal function. In a normal function, any operators or function calls that you use with your types must be defined, or you will get a compiler error. Similarly, any operators or function calls in your template function must be defined for any types the function template is instantiated for. Let\u2019s take a look at this in more detail. First, we\u2019ll create a simple class: class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } }; Now, let\u2019s see what happens when we try to call our templated max() function with the Cents class: template < typename T > // this is the template parameter declaration const T & max ( const T & x , const T & y ) { return ( x > y ) ? x : y ; } class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } }; int main () { Cents nickle { 5 }; Cents dime { 10 }; Cents bigger { max ( nickle , dime ) }; return 0 ; } C++ will create a template instance for max() that looks like this: const Cents & max ( const Cents & x , const Cents & y ) { return ( x > y ) ? x : y ; } And then it will try to compile this function. See the problem here? C++ can\u2019t evaluate x > y, because x and y are Cents class objects, and doesn\u2019t know how to compare them. Consequently, this will produce a fairly-tame looking compile error, like this: 1 >c: \\c onsoleapplication1 \\m ain.cpp ( 4 ) : error C2676: binary '>' : 'const Cents' does not define this operator or a conversion to a type acceptable to the predefined operator 1 > c: \\c onsoleapplication1 \\m ain.cpp ( 23 ) : note: see reference to function template instantiation 'const T &max(const T &,const T &)' being compiled 1 > with 1 > [ 1 > T = Cents 1 > ] The top error message points out the fact that there is no overloaded operator > for the Cents class. The bottom error points out the templated function call that spawned the error, along with the type of the templated parameter. To get around this problem, simply overload the > operator for any class we wish to use max() with: class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } friend bool operator > ( const Cents & c1 , const Cents & c2 ) { return ( c1 . m_cents > c2 . m_cents ); } }; Now C++ will know how to compare x > y when x and y are objects of the Cents class! As a result, our max() function will now work with two objects of type Cents. Another example Let\u2019s do one more example of a function template. The following function template will calculate the average of a number of objects in an array: template < class T > T average ( T * array , int length ) { T sum ( 0 ); for ( int count { 0 }; count < length ; ++ count ) sum += array [ count ]; sum /= length ; return sum ; } Now let \u2019 s see it in action : ``` c ++ #include <iostream> template < class T > T average ( T * array , int length ) { T sum ( 0 ); for ( int count { 0 }; count < length ; ++ count ) sum += array [ count ]; sum /= length ; return sum ; } int main () { int array1 []{ 5 , 3 , 2 , 1 , 4 }; std :: cout << average ( array1 , 5 ) << '\\n' ; double array2 []{ 3.12 , 3.45 , 9.23 , 6.34 }; std :: cout << average ( array2 , 4 ) << '\\n' ; return 0 ; } This produces the values : 3 5.535 As you can see , it works great for built - in types ! It is worth noting that because our return type is the same templated type as our array elements , doing an integer average will produce an integer result ( dropping any fractional value ). This is similar to how doing an integer division will produce an integer result . It \u2019 s not wrong that we \u2019 ve defined things to work that way , but it may be unexpected , so a good comment to users of the class wouldn \u2019 t be amiss here . Now let \u2019 s see what happens when we call this function on our Cents class : ``` c ++ #include <iostream> class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } friend bool operator > ( const Cents & c1 , const Cents & c2 ) { return ( c1 . m_cents > c2 . m_cents ); } }; template < class T > T average ( T * array , int length ) { T sum ( 0 ); for ( int count { 0 }; count < length ; ++ count ) sum += array [ count ]; sum /= length ; return sum ; } int main () { Cents array3 []{ Cents ( 5 ), Cents ( 10 ), Cents ( 15 ), Cents ( 14 ) }; std :: cout << average ( array3 , 4 ) << '\\n' ; return 0 ; } The compiler goes berserk and produces a ton of error messages ! example . cpp ``` bash ( 33 ) : error C2679 : binary ' << ' : no operator found which takes a right - hand operand of type 'T' ( or there is no acceptable conversion ) with [ T = Cents ] C : / data / msvc / 14.22.27905 / include \\ ostream ( 437 ) : note : could be ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( std :: basic_streambuf > * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 412 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( const void * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 394 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( long double ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 376 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( double ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 358 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( float ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 340 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( unsigned __int64 ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 322 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( __int64 ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 304 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( unsigned long ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 286 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( long ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 268 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( unsigned int ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 248 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( int ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 230 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( unsigned short ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 202 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( short ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 184 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( bool ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 179 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( std :: ios_base & ( __cdecl * )( std :: ios_base & )) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 174 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( std :: basic_ios > & ( __cdecl * )( std :: basic_ios > & )) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 169 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( std :: basic_ostream > & ( __cdecl * )( std :: basic_ostream > & )) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 613 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const char * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 658 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , char ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 694 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const char * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 739 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , char ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 858 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const signed char * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 864 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , signed char ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 870 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const unsigned char * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 876 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , unsigned char ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 931 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const std :: error_code & ) ' ( 33 ) : note : while trying to match the argument list ' ( std :: ostream , T ) ' with [ T = Cents ] Compiler returned: 2 Remember what I said about crazy error messages? We hit the motherlode! Despite looking intimidating, these are actually quite straightforward. The first line is telling you that it couldn\u2019t find an overloaded operator<< for the Cents class. All of the lines in the middle are all of the different functions it tried to match with but failed. The last error points out the function call that spawned this wall of errors. Remember that average() returns a Cents object, and we are trying to stream that object to std::cout using the << operator. However, we haven\u2019t defined the << operator for our Cents class yet. Let\u2019s do that: class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } friend bool operator > ( const Cents & c1 , const Cents & c2 ) { return ( c1 . m_cents > c2 . m_cents ); } friend std :: ostream & operator << ( std :: ostream & out , const Cents & cents ) { out << cents . m_cents << \" cents \" ; return out ; } }; If we compile again, we will get another error: c:test.cpp(14) : error C2676: binary '+=' : 'Cents' does not define this operator or a conversion to a type acceptable to the predefined operator This error is actually being caused by the function template instance created when we call average(Cents*, int). Remember that when we call a templated function, the compiler \u201cstencils\u201d out a copy of the function where the template type parameters (the placeholder types) have been replaced with the actual types in the function call. Here is the function template instance for average() when T is a Cents object: template < class T > Cents average ( Cents * array , int length ) { Cents sum ( 0 ); for ( int count { 0 }; count < length ; ++ count ) sum += array [ count ]; sum /= length ; return sum ; } The reason we are getting an error message is because of the following line : ``` c ++ sum += array [ count ]; In this case, sum is a Cents object, but we have not defined the += operator for Cents objects! We will need to define this function in order for average() to be able to work with Cents. Looking forward, we can see that average() also uses the /= operator, so we will go ahead and define that as well: class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } friend bool operator > ( const Cents & c1 , const Cents & c2 ) { return ( c1 . m_cents > c2 . m_cents ); } friend std :: ostream & operator << ( std :: ostream & out , const Cents & cents ) { out << cents . m_cents << \" cents \" ; return out ; } Cents & operator += ( const Cents & cents ) { m_cents += cents . m_cents ; return * this ; } Cents & operator /= ( int value ) { m_cents /= value ; return * this ; } }; Finally, our code will compile and run! Here is the result: 11 cents If this seems like a lot of work, that\u2019s really only because our Cents class was so bare-bones to start. The key point here is actually that we didn\u2019t have to modify average() at all to make it work with objects of type Cents (or any other type). We simply had to define the operators used to implement average() for the Cents class, and the compiler took care of the rest!","title":"13.2 \u51fd\u6570\u6a21\u677f\u7684\u5b9e\u4f8b\u5316"},{"location":"13-templates/13.2-function-template-instances/#132","text":"It\u2019s worth taking a brief look at how template functions are implemented in C++, because future lessons will build off of some of these concepts. It turns out that C++ does not compile the template function directly. Instead, at compile time, when the compiler encounters a call to a template function, it replicates the template function and replaces the template type parameters with actual types. The function with actual types is called a function template instance. Let\u2019s take a look at an example of this process. First, we have a templated function: template < typename T > // this is the template parameter declaration const T & max ( const T & x , const T & y ) { return ( x > y ) ? x : y ; } When compiling your program, the compiler encounters a call to the templated function: int i { max ( 3 , 7 ) }; // calls max(int, int) The compiler says, \u201coh, we want to call max(int, int)\u201d. The compiler replicates the function template and creates the template instance max(int, int): const int & max ( const int & x , const int & y ) { return ( x > y ) ? x : y ; } This is now a \u201cnormal function\u201d that can be compiled into machine language. Now, let\u2019s say later in your code, you called max() again using a different type: double d { max ( 6.34 , 18.523 ) }; // calls max(double, double) C++ automatically creates a template instance for max(double, double): const double & max ( const double & x , const double & y ) { return ( x > y ) ? x : y ; } and then compiles it. The compiler is smart enough to know it only needs to create one template instance per set of unique type parameters (per file). It\u2019s also worth noting that if you create a template function but do not call it, no template instances will be created. Operators, function calls, and function templates Template functions will work with both built-in types (e.g. char, int, double, etc\u2026) and classes, with one caveat. When the compiler compiles the template instance, it compiles it just like a normal function. In a normal function, any operators or function calls that you use with your types must be defined, or you will get a compiler error. Similarly, any operators or function calls in your template function must be defined for any types the function template is instantiated for. Let\u2019s take a look at this in more detail. First, we\u2019ll create a simple class: class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } }; Now, let\u2019s see what happens when we try to call our templated max() function with the Cents class: template < typename T > // this is the template parameter declaration const T & max ( const T & x , const T & y ) { return ( x > y ) ? x : y ; } class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } }; int main () { Cents nickle { 5 }; Cents dime { 10 }; Cents bigger { max ( nickle , dime ) }; return 0 ; } C++ will create a template instance for max() that looks like this: const Cents & max ( const Cents & x , const Cents & y ) { return ( x > y ) ? x : y ; } And then it will try to compile this function. See the problem here? C++ can\u2019t evaluate x > y, because x and y are Cents class objects, and doesn\u2019t know how to compare them. Consequently, this will produce a fairly-tame looking compile error, like this: 1 >c: \\c onsoleapplication1 \\m ain.cpp ( 4 ) : error C2676: binary '>' : 'const Cents' does not define this operator or a conversion to a type acceptable to the predefined operator 1 > c: \\c onsoleapplication1 \\m ain.cpp ( 23 ) : note: see reference to function template instantiation 'const T &max(const T &,const T &)' being compiled 1 > with 1 > [ 1 > T = Cents 1 > ] The top error message points out the fact that there is no overloaded operator > for the Cents class. The bottom error points out the templated function call that spawned the error, along with the type of the templated parameter. To get around this problem, simply overload the > operator for any class we wish to use max() with: class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } friend bool operator > ( const Cents & c1 , const Cents & c2 ) { return ( c1 . m_cents > c2 . m_cents ); } }; Now C++ will know how to compare x > y when x and y are objects of the Cents class! As a result, our max() function will now work with two objects of type Cents. Another example Let\u2019s do one more example of a function template. The following function template will calculate the average of a number of objects in an array: template < class T > T average ( T * array , int length ) { T sum ( 0 ); for ( int count { 0 }; count < length ; ++ count ) sum += array [ count ]; sum /= length ; return sum ; } Now let \u2019 s see it in action : ``` c ++ #include <iostream> template < class T > T average ( T * array , int length ) { T sum ( 0 ); for ( int count { 0 }; count < length ; ++ count ) sum += array [ count ]; sum /= length ; return sum ; } int main () { int array1 []{ 5 , 3 , 2 , 1 , 4 }; std :: cout << average ( array1 , 5 ) << '\\n' ; double array2 []{ 3.12 , 3.45 , 9.23 , 6.34 }; std :: cout << average ( array2 , 4 ) << '\\n' ; return 0 ; } This produces the values : 3 5.535 As you can see , it works great for built - in types ! It is worth noting that because our return type is the same templated type as our array elements , doing an integer average will produce an integer result ( dropping any fractional value ). This is similar to how doing an integer division will produce an integer result . It \u2019 s not wrong that we \u2019 ve defined things to work that way , but it may be unexpected , so a good comment to users of the class wouldn \u2019 t be amiss here . Now let \u2019 s see what happens when we call this function on our Cents class : ``` c ++ #include <iostream> class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } friend bool operator > ( const Cents & c1 , const Cents & c2 ) { return ( c1 . m_cents > c2 . m_cents ); } }; template < class T > T average ( T * array , int length ) { T sum ( 0 ); for ( int count { 0 }; count < length ; ++ count ) sum += array [ count ]; sum /= length ; return sum ; } int main () { Cents array3 []{ Cents ( 5 ), Cents ( 10 ), Cents ( 15 ), Cents ( 14 ) }; std :: cout << average ( array3 , 4 ) << '\\n' ; return 0 ; } The compiler goes berserk and produces a ton of error messages ! example . cpp ``` bash ( 33 ) : error C2679 : binary ' << ' : no operator found which takes a right - hand operand of type 'T' ( or there is no acceptable conversion ) with [ T = Cents ] C : / data / msvc / 14.22.27905 / include \\ ostream ( 437 ) : note : could be ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( std :: basic_streambuf > * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 412 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( const void * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 394 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( long double ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 376 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( double ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 358 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( float ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 340 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( unsigned __int64 ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 322 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( __int64 ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 304 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( unsigned long ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 286 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( long ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 268 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( unsigned int ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 248 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( int ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 230 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( unsigned short ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 202 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( short ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 184 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( bool ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 179 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( std :: ios_base & ( __cdecl * )( std :: ios_base & )) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 174 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( std :: basic_ios > & ( __cdecl * )( std :: basic_ios > & )) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 169 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( std :: basic_ostream > & ( __cdecl * )( std :: basic_ostream > & )) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 613 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const char * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 658 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , char ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 694 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const char * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 739 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , char ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 858 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const signed char * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 864 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , signed char ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 870 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const unsigned char * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 876 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , unsigned char ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 931 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const std :: error_code & ) ' ( 33 ) : note : while trying to match the argument list ' ( std :: ostream , T ) ' with [ T = Cents ] Compiler returned: 2 Remember what I said about crazy error messages? We hit the motherlode! Despite looking intimidating, these are actually quite straightforward. The first line is telling you that it couldn\u2019t find an overloaded operator<< for the Cents class. All of the lines in the middle are all of the different functions it tried to match with but failed. The last error points out the function call that spawned this wall of errors. Remember that average() returns a Cents object, and we are trying to stream that object to std::cout using the << operator. However, we haven\u2019t defined the << operator for our Cents class yet. Let\u2019s do that: class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } friend bool operator > ( const Cents & c1 , const Cents & c2 ) { return ( c1 . m_cents > c2 . m_cents ); } friend std :: ostream & operator << ( std :: ostream & out , const Cents & cents ) { out << cents . m_cents << \" cents \" ; return out ; } }; If we compile again, we will get another error: c:test.cpp(14) : error C2676: binary '+=' : 'Cents' does not define this operator or a conversion to a type acceptable to the predefined operator This error is actually being caused by the function template instance created when we call average(Cents*, int). Remember that when we call a templated function, the compiler \u201cstencils\u201d out a copy of the function where the template type parameters (the placeholder types) have been replaced with the actual types in the function call. Here is the function template instance for average() when T is a Cents object: template < class T > Cents average ( Cents * array , int length ) { Cents sum ( 0 ); for ( int count { 0 }; count < length ; ++ count ) sum += array [ count ]; sum /= length ; return sum ; } The reason we are getting an error message is because of the following line : ``` c ++ sum += array [ count ]; In this case, sum is a Cents object, but we have not defined the += operator for Cents objects! We will need to define this function in order for average() to be able to work with Cents. Looking forward, we can see that average() also uses the /= operator, so we will go ahead and define that as well: class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } friend bool operator > ( const Cents & c1 , const Cents & c2 ) { return ( c1 . m_cents > c2 . m_cents ); } friend std :: ostream & operator << ( std :: ostream & out , const Cents & cents ) { out << cents . m_cents << \" cents \" ; return out ; } Cents & operator += ( const Cents & cents ) { m_cents += cents . m_cents ; return * this ; } Cents & operator /= ( int value ) { m_cents /= value ; return * this ; } }; Finally, our code will compile and run! Here is the result: 11 cents If this seems like a lot of work, that\u2019s really only because our Cents class was so bare-bones to start. The key point here is actually that we didn\u2019t have to modify average() at all to make it work with objects of type Cents (or any other type). We simply had to define the operators used to implement average() for the Cents class, and the compiler took care of the rest!","title":"13.2 \u51fd\u6570\u6a21\u677f\u7684\u5b9e\u4f8b\u5316"},{"location":"13-templates/13.3-template-classes/","text":"13.3 \u6a21\u677f\u7c7b \u00b6 By Alex on June 16 th , 2008 | last modified by Alex on May 1 st , 2020 In the previous two lessons, you learn how 13.1 -- Function templates, which get instantiated into 13.2 -- Function template instances, allow us to generalize functions to work with many different data types. While this is a great start down the road to generalized programming, it doesn\u2019t solve all of our problems. Let\u2019s take a look at an example of one such problem, and see what templates can further do for us. Templates and container classes In the lesson on 10.6 -- Container classes, you learned how to use composition to implement classes that contained multiple instances of other classes. As one example of such a container, we took a look at the IntArray class. Here is a simplified example of that class: #ifndef INTARRAY_H #define INTARRAY_H #include <cassert> class IntArray { private : int m_length {}; int * m_data {}; public : IntArray ( int length ) { assert ( length > 0 ); m_data = new int [ length ]{}; m_length = length ; } // We don't want to allow copies of IntArray to be created. IntArray ( const IntArray & ) = delete ; IntArray & operator = ( const IntArray & ) = delete ; ~ IntArray () { delete [] m_data ; } void Erase () { delete [] m_data ; // We need to make sure we set m_data to 0 here, otherwise it will // be left pointing at deallocated memory! m_data = nullptr ; m_length = 0 ; } int & operator []( int index ) { assert ( index >= 0 && index < m_length ); return m_data [ index ]; } int getLength () const { return m_length ; } }; #endif While this class provides an easy way to create arrays of integers, what if we want to create an array of doubles? Using traditional programming methods, we\u2019d have to create an entirely new class! Here\u2019s an example of DoubleArray, an array class used to hold doubles. #ifndef DOUBLEARRAY_H #define DOUBLEARRAY_H #include <cassert> class DoubleArray { private : int m_length {}; double * m_data {}; public : DoubleArray ( int length ) { assert ( length > 0 ); m_data = new double [ length ]{}; m_length = length ; } DoubleArray ( const DoubleArray & ) = delete ; DoubleArray & operator = ( const DoubleArray & ) = delete ; ~ DoubleArray () { delete [] m_data ; } void Erase () { delete [] m_data ; // We need to make sure we set m_data to 0 here, otherwise it will // be left pointing at deallocated memory! m_data = nullptr ; m_length = 0 ; } double & operator []( int index ) { assert ( index >= 0 && index < m_length ); return m_data [ index ]; } int getLength () const { return m_length ; } }; #endif Although the code listings are lengthy, you\u2019ll note the two classes are almost identical! In fact, the only substantive difference is the contained data type (int vs double). As you likely have guessed, this is another area where templates can be put to good use, to free us from having to create classes that are bound to one specific data type. Creating template classes works pretty much identically to creating template functions, so we\u2019ll proceed by example. Here\u2019s our array class, templated version: // Array.h: #ifndef ARRAY_H #define ARRAY_H #include <cassert> template < class T > class Array { private : int m_length {}; T * m_data {}; public : Array ( int length ) { assert ( length > 0 ); m_data = new T [ length ]{}; m_length = length ; } Array ( const Array & ) = delete ; Array & operator = ( const Array & ) = delete ; ~ Array () { delete [] m_data ; } void Erase () { delete [] m_data ; // We need to make sure we set m_data to 0 here, otherwise it will // be left pointing at deallocated memory! m_data = nullptr ; m_length = 0 ; } T & operator []( int index ) { assert ( index >= 0 && index < m_length ); return m_data [ index ]; } // templated getLength() function defined below int getLength () const ; }; // member functions defined outside the class need their own template declaration template < class T > int Array < T >:: getLength () const // note class name is Array<T>, not Array { return m_length ; } #endif As you can see, this version is almost identical to the IntArray version, except we\u2019ve added the template declaration, and changed the contained data type from int to T. Note that we\u2019ve also defined the getLength() function outside of the class declaration. This isn\u2019t necessary, but new programmers typically stumble when trying to do this for the first time due to the syntax, so an example is instructive. Each templated member function declared outside the class declaration needs its own template declaration. Also, note that the name of the templated array class is Array , not Array -- Array would refer to a non-templated version of a class named Array. Here\u2019s a short example using the above templated array class: #include <iostream> #include \"Array.h\" int main () { Array < int > intArray ( 12 ); Array < double > doubleArray ( 12 ); for ( int count { 0 }; count < intArray . getLength (); ++ count ) { intArray [ count ] = count ; doubleArray [ count ] = count + 0.5 ; } for ( int count { intArray . getLength () - 1 }; count >= 0 ; -- count ) std :: cout << intArray [ count ] << '\\t' << doubleArray [ count ] << '\\n' ; return 0 ; } This example prints the following: 11 11.5 10 10.5 9 9.5 8 8.5 7 7.5 6 6.5 5 5.5 4 4.5 3 3.5 2 2.5 1 1.5 0 0.5 Template classes are instanced in the same way template functions are -- the compiler stencils out a copy upon demand, with the template parameter replaced by the actual data type the user needs, and then compiles the copy. If you don\u2019t ever use a template class, the compiler won\u2019t even compile it. Template classes are ideal for implementing container classes, because it is highly desirable to have containers work across a wide variety of data types, and templates allow you to do so without duplicating code. Although the syntax is ugly, and the error messages can be cryptic, template classes are truly one of C++\u2019s best and most useful features. Template classes in the standard library Now that we\u2019ve covered template classes, you should understand what std::vector means now -- std::vector is actually a template class, and int is the type parameter to the template! The standard library is full of predefined template classes available for your use. We\u2019ll cover these in later chapters. Splitting up template classes A template is not a class or a function -- it is a stencil used to create classes or functions. As such, it does not work in quite the same way as normal functions or classes. In most cases, this isn\u2019t much of a issue. However, there is one area that commonly causes problems for developers. With non-template classes, the common procedure is to put the class definition in a header file, and the member function definitions in a similarly named code file. In this way, the source for the class is compiled as a separate project file. However, with templates, this does not work. Consider the following: // Array.h: #ifndef ARRAY_H #define ARRAY_H #include <cassert> template < class T > class Array { private : int m_length {}; T * m_data {}; public : Array ( int length ) { assert ( length > 0 ); m_data = new T [ length ]{}; m_length = length ; } Array ( const Array & ) = delete ; Array & operator = ( const Array & ) = delete ; ~ Array () { delete [] m_data ; } void Erase () { delete [] m_data ; m_data = nullptr ; m_length = 0 ; } T & operator []( int index ) { assert ( index >= 0 && index < m_length ); return m_data [ index ]; } int getLength () const ; }; #endif // Array.cpp: #include \"Array.h\" template < class T > int Array < T >:: getLength () const // note class name is Array<T>, not Array { return m_length ; } // main.cpp: #include \"Array.h\" int main () { Array < int > intArray ( 12 ); Array < double > doubleArray ( 12 ); for ( int count { 0 }; count < intArray . getLength (); ++ count ) { intArray [ count ] = count ; doubleArray [ count ] = count + 0.5 ; } for ( int count { intArray . getLength () - 1 }; count >= 0 ; -- count ) std :: cout << intArray [ count ] << '\\t' << doubleArray [ count ] << '\\n' ; return 0 ; } The above program will compile, but cause a linker error: unresolved external symbol \"public: int __thiscall Array::getLength(void)\" (?GetLength@?$Array@H@@QAEHXZ) In order for the compiler to use a template, it must see both the template definition (not just a declaration) and the template type used to instantiate the template. Also remember that C++ compiles files individually. When the Array.h header is #included in main, the template class definition is copied into main.cpp. When the compiler sees that we need two template instances, Array , and Array , it will instantiate these, and compile them as part of main.cpp. However, when it gets around to compiling Array.cpp separately, it will have forgotten that we need an Array and Array , so that template function is never instantiated. Thus, we get a linker error, because the compiler can\u2019t find a definition for Array ::getLength() or Array ::getLength(). There are quite a few ways to work around this. The easiest way is to simply put all of your template class code in the header file (in this case, put the contents of Array.cpp into Array.h, below the class). In this way, when you #include the header, all of the template code will be in one place. The upside of this solution is that it is simple. The downside here is that if the template class is used in many places, you will end up with many local copies of the template class, which can increase your compile and link times (your linker should remove the duplicate definitions, so it shouldn\u2019t bloat your executable). This is our preferred solution unless the compile or link times start to become a problem. If you feel that putting the Array.cpp code into the Array.h header makes the header too long/messy, an alternative is to rename Array.cpp to Array.inl (.inl stands for inline), and then include Array.inl from the bottom of the Array.h header. That yields the same result as putting all the code in the header, but helps keep things a little cleaner. Other solutions involve #including .cpp files, but we don\u2019t recommend these because of the non-standard usage of #include. Another alternative is to use a three-file approach. The template class definition goes in the header. The template class member functions goes in the code file. Then you add a third file, which contains all of the instantiated classes you need: // templates.cpp: // Ensure the full Array template definition can be seen #include \"Array.h\" #include \"Array.cpp\" // we're breaking best practices here, but only in this one place // #include other .h and .cpp template definitions you need here template class Array < int > ; // Explicitly instantiate template Array<int> template class Array < double > ; // Explicitly instantiate template Array<double> // instantiate other templates here The \u201ctemplate class\u201d command causes the compiler to explicitly instantiate the template class. In the above case, the compiler will stencil out both Array and Array inside of templates.cpp. Because templates.cpp is inside our project, this will then be compiled. These functions can then be linked to from elsewhere. This method is more efficient, but requires maintaining the templates.cpp file for each program","title":"13.3 \u6a21\u677f\u7c7b"},{"location":"13-templates/13.3-template-classes/#133","text":"By Alex on June 16 th , 2008 | last modified by Alex on May 1 st , 2020 In the previous two lessons, you learn how 13.1 -- Function templates, which get instantiated into 13.2 -- Function template instances, allow us to generalize functions to work with many different data types. While this is a great start down the road to generalized programming, it doesn\u2019t solve all of our problems. Let\u2019s take a look at an example of one such problem, and see what templates can further do for us. Templates and container classes In the lesson on 10.6 -- Container classes, you learned how to use composition to implement classes that contained multiple instances of other classes. As one example of such a container, we took a look at the IntArray class. Here is a simplified example of that class: #ifndef INTARRAY_H #define INTARRAY_H #include <cassert> class IntArray { private : int m_length {}; int * m_data {}; public : IntArray ( int length ) { assert ( length > 0 ); m_data = new int [ length ]{}; m_length = length ; } // We don't want to allow copies of IntArray to be created. IntArray ( const IntArray & ) = delete ; IntArray & operator = ( const IntArray & ) = delete ; ~ IntArray () { delete [] m_data ; } void Erase () { delete [] m_data ; // We need to make sure we set m_data to 0 here, otherwise it will // be left pointing at deallocated memory! m_data = nullptr ; m_length = 0 ; } int & operator []( int index ) { assert ( index >= 0 && index < m_length ); return m_data [ index ]; } int getLength () const { return m_length ; } }; #endif While this class provides an easy way to create arrays of integers, what if we want to create an array of doubles? Using traditional programming methods, we\u2019d have to create an entirely new class! Here\u2019s an example of DoubleArray, an array class used to hold doubles. #ifndef DOUBLEARRAY_H #define DOUBLEARRAY_H #include <cassert> class DoubleArray { private : int m_length {}; double * m_data {}; public : DoubleArray ( int length ) { assert ( length > 0 ); m_data = new double [ length ]{}; m_length = length ; } DoubleArray ( const DoubleArray & ) = delete ; DoubleArray & operator = ( const DoubleArray & ) = delete ; ~ DoubleArray () { delete [] m_data ; } void Erase () { delete [] m_data ; // We need to make sure we set m_data to 0 here, otherwise it will // be left pointing at deallocated memory! m_data = nullptr ; m_length = 0 ; } double & operator []( int index ) { assert ( index >= 0 && index < m_length ); return m_data [ index ]; } int getLength () const { return m_length ; } }; #endif Although the code listings are lengthy, you\u2019ll note the two classes are almost identical! In fact, the only substantive difference is the contained data type (int vs double). As you likely have guessed, this is another area where templates can be put to good use, to free us from having to create classes that are bound to one specific data type. Creating template classes works pretty much identically to creating template functions, so we\u2019ll proceed by example. Here\u2019s our array class, templated version: // Array.h: #ifndef ARRAY_H #define ARRAY_H #include <cassert> template < class T > class Array { private : int m_length {}; T * m_data {}; public : Array ( int length ) { assert ( length > 0 ); m_data = new T [ length ]{}; m_length = length ; } Array ( const Array & ) = delete ; Array & operator = ( const Array & ) = delete ; ~ Array () { delete [] m_data ; } void Erase () { delete [] m_data ; // We need to make sure we set m_data to 0 here, otherwise it will // be left pointing at deallocated memory! m_data = nullptr ; m_length = 0 ; } T & operator []( int index ) { assert ( index >= 0 && index < m_length ); return m_data [ index ]; } // templated getLength() function defined below int getLength () const ; }; // member functions defined outside the class need their own template declaration template < class T > int Array < T >:: getLength () const // note class name is Array<T>, not Array { return m_length ; } #endif As you can see, this version is almost identical to the IntArray version, except we\u2019ve added the template declaration, and changed the contained data type from int to T. Note that we\u2019ve also defined the getLength() function outside of the class declaration. This isn\u2019t necessary, but new programmers typically stumble when trying to do this for the first time due to the syntax, so an example is instructive. Each templated member function declared outside the class declaration needs its own template declaration. Also, note that the name of the templated array class is Array , not Array -- Array would refer to a non-templated version of a class named Array. Here\u2019s a short example using the above templated array class: #include <iostream> #include \"Array.h\" int main () { Array < int > intArray ( 12 ); Array < double > doubleArray ( 12 ); for ( int count { 0 }; count < intArray . getLength (); ++ count ) { intArray [ count ] = count ; doubleArray [ count ] = count + 0.5 ; } for ( int count { intArray . getLength () - 1 }; count >= 0 ; -- count ) std :: cout << intArray [ count ] << '\\t' << doubleArray [ count ] << '\\n' ; return 0 ; } This example prints the following: 11 11.5 10 10.5 9 9.5 8 8.5 7 7.5 6 6.5 5 5.5 4 4.5 3 3.5 2 2.5 1 1.5 0 0.5 Template classes are instanced in the same way template functions are -- the compiler stencils out a copy upon demand, with the template parameter replaced by the actual data type the user needs, and then compiles the copy. If you don\u2019t ever use a template class, the compiler won\u2019t even compile it. Template classes are ideal for implementing container classes, because it is highly desirable to have containers work across a wide variety of data types, and templates allow you to do so without duplicating code. Although the syntax is ugly, and the error messages can be cryptic, template classes are truly one of C++\u2019s best and most useful features. Template classes in the standard library Now that we\u2019ve covered template classes, you should understand what std::vector means now -- std::vector is actually a template class, and int is the type parameter to the template! The standard library is full of predefined template classes available for your use. We\u2019ll cover these in later chapters. Splitting up template classes A template is not a class or a function -- it is a stencil used to create classes or functions. As such, it does not work in quite the same way as normal functions or classes. In most cases, this isn\u2019t much of a issue. However, there is one area that commonly causes problems for developers. With non-template classes, the common procedure is to put the class definition in a header file, and the member function definitions in a similarly named code file. In this way, the source for the class is compiled as a separate project file. However, with templates, this does not work. Consider the following: // Array.h: #ifndef ARRAY_H #define ARRAY_H #include <cassert> template < class T > class Array { private : int m_length {}; T * m_data {}; public : Array ( int length ) { assert ( length > 0 ); m_data = new T [ length ]{}; m_length = length ; } Array ( const Array & ) = delete ; Array & operator = ( const Array & ) = delete ; ~ Array () { delete [] m_data ; } void Erase () { delete [] m_data ; m_data = nullptr ; m_length = 0 ; } T & operator []( int index ) { assert ( index >= 0 && index < m_length ); return m_data [ index ]; } int getLength () const ; }; #endif // Array.cpp: #include \"Array.h\" template < class T > int Array < T >:: getLength () const // note class name is Array<T>, not Array { return m_length ; } // main.cpp: #include \"Array.h\" int main () { Array < int > intArray ( 12 ); Array < double > doubleArray ( 12 ); for ( int count { 0 }; count < intArray . getLength (); ++ count ) { intArray [ count ] = count ; doubleArray [ count ] = count + 0.5 ; } for ( int count { intArray . getLength () - 1 }; count >= 0 ; -- count ) std :: cout << intArray [ count ] << '\\t' << doubleArray [ count ] << '\\n' ; return 0 ; } The above program will compile, but cause a linker error: unresolved external symbol \"public: int __thiscall Array::getLength(void)\" (?GetLength@?$Array@H@@QAEHXZ) In order for the compiler to use a template, it must see both the template definition (not just a declaration) and the template type used to instantiate the template. Also remember that C++ compiles files individually. When the Array.h header is #included in main, the template class definition is copied into main.cpp. When the compiler sees that we need two template instances, Array , and Array , it will instantiate these, and compile them as part of main.cpp. However, when it gets around to compiling Array.cpp separately, it will have forgotten that we need an Array and Array , so that template function is never instantiated. Thus, we get a linker error, because the compiler can\u2019t find a definition for Array ::getLength() or Array ::getLength(). There are quite a few ways to work around this. The easiest way is to simply put all of your template class code in the header file (in this case, put the contents of Array.cpp into Array.h, below the class). In this way, when you #include the header, all of the template code will be in one place. The upside of this solution is that it is simple. The downside here is that if the template class is used in many places, you will end up with many local copies of the template class, which can increase your compile and link times (your linker should remove the duplicate definitions, so it shouldn\u2019t bloat your executable). This is our preferred solution unless the compile or link times start to become a problem. If you feel that putting the Array.cpp code into the Array.h header makes the header too long/messy, an alternative is to rename Array.cpp to Array.inl (.inl stands for inline), and then include Array.inl from the bottom of the Array.h header. That yields the same result as putting all the code in the header, but helps keep things a little cleaner. Other solutions involve #including .cpp files, but we don\u2019t recommend these because of the non-standard usage of #include. Another alternative is to use a three-file approach. The template class definition goes in the header. The template class member functions goes in the code file. Then you add a third file, which contains all of the instantiated classes you need: // templates.cpp: // Ensure the full Array template definition can be seen #include \"Array.h\" #include \"Array.cpp\" // we're breaking best practices here, but only in this one place // #include other .h and .cpp template definitions you need here template class Array < int > ; // Explicitly instantiate template Array<int> template class Array < double > ; // Explicitly instantiate template Array<double> // instantiate other templates here The \u201ctemplate class\u201d command causes the compiler to explicitly instantiate the template class. In the above case, the compiler will stencil out both Array and Array inside of templates.cpp. Because templates.cpp is inside our project, this will then be compiled. These functions can then be linked to from elsewhere. This method is more efficient, but requires maintaining the templates.cpp file for each program","title":"13.3 \u6a21\u677f\u7c7b"},{"location":"13-templates/13.4-template-non-type-parameters/","text":"13.4 \u6a21\u677f\u975e\u7c7b\u578b\u53c2\u6570 \u00b6 By Alex on June 19 th , 2008 | last modified by Alex on January 23 rd , 2020 | \u7ffb\u8bd1by dashjay 2020.07.10 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u4e86\u89e3\u5982\u4f55\u4f7f\u7528\u6a21\u677f\u6765\u521b\u5efa\u4e0d\u53d7\u7c7b\u578b\u5f71\u54cd\u7684\u51fd\u6570\u548c\u7c7b\u3002\u7136\u800c\uff0c\u6a21\u677f\u7c7b\u578b\u53c2\u6570\u5e76\u4e0d\u662f\u6a21\u677f\u4e2d\u552f\u4e00\u53ef\u7528\u7684\u53c2\u6570\u3002\uff08However, template type parameters are not the only type of template parameters available.\uff09\u3002\u6a21\u677f\u7c7b\u578b\u548c\u51fd\u6570\u53ef\u4ee5\u5229\u7528\u53e6\u4e00\u7c7b\u7684\u6a21\u677f\u53c2\u6570\uff0c\u5b83\u4eec\u88ab\u53eb\u505a\u8d39\u7c7b\u578b\u53c2\u6570\uff08non-type parameter\uff09\u3002 \u975e\u7c7b\u578b\u53c2\u6570 \u00b6 \u4e00\u4e2a\u6a21\u677f\u975e\u7c7b\u578b\u53c2\u6570\u662f\u4e00\u4e2a\u7279\u6b8a\u7c7b\u578b\u7684\u53c2\u6570\u4e0d\u9002\u5408\u7c7b\u578b\uff0c\u5374\u80fd\u88ab\u4e00\u4e2a\u503c\u66ff\u6362\u3002\u4e00\u4e2a\u975e\u7c7b\u578b\u53c2\u6570\u53ef\u4ee5\u4e3a\u4ee5\u4e0b\u7684\u5176\u4e2d\u4e00\u4e2a\u3002 \u6574\u5f62\u6216\u679a\u4e3e\u578b\u7684\u503c \u6307\u5411\u7c7b\u5bf9\u8c61\u7684\u6307\u9488\u6216\u5f15\u7528 \u6307\u5411\u51fd\u6570\u7684\u6307\u9488\u6216\u5f15\u7528 \u6307\u5411\u4e00\u4e2a\u7c7b\u51fd\u6570\u7684\u7684\u6307\u9488\u6216\u5f15\u7528 std::nullptr_t \u5728\u4e0b\u5217\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u975e\u7c7b\u578b\uff08\u9759\u6001\uff09\u6570\u7ec4\u7c7b\uff0c\u540c\u65f6\u4f7f\u7528\u4e00\u4e2a\u7c7b\u578b\u53c2\u6570\u548c\u4e00\u4e2a\u975e\u7c7b\u578b\u53c2\u6570\u3002\u7c7b\u578b\u53c2\u6570\u63a7\u5236\u9759\u6001\u6570\u7ec4\u6570\u636e\u7c7b\u578b\uff0c\u975e\u7c7b\u578b\u53c2\u6570\u63a7\u5236\u8fd9\u4e2a\u9759\u6001\u6570\u7ec4\u6709\u591a\u5927\u3002 #include <iostream> // size is the non-type parameter // size \u662f\u4e00\u4e2a\u975e\u7c7b\u578b\u53c2\u6570 template < class T , int size > class StaticArray { private : // The non-type parameter controls the size of the array // \u975e\u7c7b\u578b\u53c2\u6570\u63a7\u5236\u6570\u7ec4\u7684\u5927\u5c0f T m_array [ size ]; public : T * getArray (); T & operator []( int index ) { return m_array [ index ]; } }; // \u5c55\u793a\u4e00\u4e2a\u5e26\u6709\u975e\u7c7b\u578b\u53c2\u6570\u7684\u6a21\u677f\u7c7b\u4e2d\u7684\u51fd\u6570\u662f\u5982\u4f55\u5728\u7c7b\u5916\u5b9a\u4e49 // Showing how a function for a class with a non-type parameter is defined outside of the class template < class T , int size > T * StaticArray < T , size >:: getArray () { return m_array ; } int main () { // declare an integer array with room for 12 integers StaticArray < int , 12 > intArray ; // Fill it up in order, then print it backwards for ( int count = 0 ; count < 12 ; ++ count ) intArray [ count ] = count ; for ( int count = 11 ; count >= 0 ; -- count ) std :: cout << intArray [ count ] << \" \" ; std :: cout << '\\n' ; // declare a double buffer with room for 4 doubles StaticArray < double , 4 > doubleArray ; for ( int count = 0 ; count < 4 ; ++ count ) doubleArray [ count ] = 4.4 + 0.1 * count ; for ( int count = 0 ; count < 4 ; ++ count ) std :: cout << doubleArray [ count ] << ' ' ; return 0 ; } \u4ee3\u7801\u4ea7\u751f\u8ba9\u4ee5\u4e0b\u7ed3\u679c\uff1a 11 10 9 8 7 6 5 4 3 2 1 0 4.4 4.5 4.6 4.7 \u4e00\u70b9\u503c\u5f97\u6ce8\u610f\u7684\u4e8b\u60c5\u5173\u4e8e\u4ee5\u4e0a\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u6ca1\u6709\u4f7f\u7528\u52a8\u6001\u5185\u5b58\u5206\u914d\u5728 m_array \u6210\u5458\u4e0a\uff01\u8fd9\u662f\u56e0\u4e3a\u4efb\u4f55\u4f20\u5165 StaticArray \u7c7b\u4e2d\u7684 size \u5b9e\u9645\u4e0a\u90fd\u662f\u4e00\u4e2a\u5e38\u6570\uff0c\u4f8b\u5982\u5982\u679c\u4f60\u5b9e\u4f8b\u5316\u4e86 StaticArray<int, 12> \uff0c\u90a3\u4e48\u7f16\u8bd1\u5668\u4f1a\u4f7f\u7528 12 \u66ff\u6362 size \u3002\u56e0\u6b64 m_array \u662f int[12] \u7c7b\u578b\u7684\uff0c\u8fd9\u53ef\u4ee5\u8fdb\u884c\u9759\u6001\u5206\u914d\u3002 \u8fd9\u4e2a\u529f\u80fd\u4e5f\u88ab\u7528\u5728\u6807\u51c6\u7c7b std::array \u4e2d\uff0c\u5f53\u4f60\u5206\u914d\u4e86\u4e00\u4e2a std::array<int, 5> \u65f6\uff0cint\u662f\u4e00\u4e2a\u7c7b\u578b\u53c2\u6570\uff0c5 \u662f\u4e00\u4e2a\u975e\u7c7b\u578b\u53c2\u6570\u3002","title":"13.4 \u6a21\u677f\u975e\u7c7b\u578b\u53c2\u6570"},{"location":"13-templates/13.4-template-non-type-parameters/#134","text":"By Alex on June 19 th , 2008 | last modified by Alex on January 23 rd , 2020 | \u7ffb\u8bd1by dashjay 2020.07.10 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u4e86\u89e3\u5982\u4f55\u4f7f\u7528\u6a21\u677f\u6765\u521b\u5efa\u4e0d\u53d7\u7c7b\u578b\u5f71\u54cd\u7684\u51fd\u6570\u548c\u7c7b\u3002\u7136\u800c\uff0c\u6a21\u677f\u7c7b\u578b\u53c2\u6570\u5e76\u4e0d\u662f\u6a21\u677f\u4e2d\u552f\u4e00\u53ef\u7528\u7684\u53c2\u6570\u3002\uff08However, template type parameters are not the only type of template parameters available.\uff09\u3002\u6a21\u677f\u7c7b\u578b\u548c\u51fd\u6570\u53ef\u4ee5\u5229\u7528\u53e6\u4e00\u7c7b\u7684\u6a21\u677f\u53c2\u6570\uff0c\u5b83\u4eec\u88ab\u53eb\u505a\u8d39\u7c7b\u578b\u53c2\u6570\uff08non-type parameter\uff09\u3002","title":"13.4 \u6a21\u677f\u975e\u7c7b\u578b\u53c2\u6570"},{"location":"13-templates/13.4-template-non-type-parameters/#_1","text":"\u4e00\u4e2a\u6a21\u677f\u975e\u7c7b\u578b\u53c2\u6570\u662f\u4e00\u4e2a\u7279\u6b8a\u7c7b\u578b\u7684\u53c2\u6570\u4e0d\u9002\u5408\u7c7b\u578b\uff0c\u5374\u80fd\u88ab\u4e00\u4e2a\u503c\u66ff\u6362\u3002\u4e00\u4e2a\u975e\u7c7b\u578b\u53c2\u6570\u53ef\u4ee5\u4e3a\u4ee5\u4e0b\u7684\u5176\u4e2d\u4e00\u4e2a\u3002 \u6574\u5f62\u6216\u679a\u4e3e\u578b\u7684\u503c \u6307\u5411\u7c7b\u5bf9\u8c61\u7684\u6307\u9488\u6216\u5f15\u7528 \u6307\u5411\u51fd\u6570\u7684\u6307\u9488\u6216\u5f15\u7528 \u6307\u5411\u4e00\u4e2a\u7c7b\u51fd\u6570\u7684\u7684\u6307\u9488\u6216\u5f15\u7528 std::nullptr_t \u5728\u4e0b\u5217\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u975e\u7c7b\u578b\uff08\u9759\u6001\uff09\u6570\u7ec4\u7c7b\uff0c\u540c\u65f6\u4f7f\u7528\u4e00\u4e2a\u7c7b\u578b\u53c2\u6570\u548c\u4e00\u4e2a\u975e\u7c7b\u578b\u53c2\u6570\u3002\u7c7b\u578b\u53c2\u6570\u63a7\u5236\u9759\u6001\u6570\u7ec4\u6570\u636e\u7c7b\u578b\uff0c\u975e\u7c7b\u578b\u53c2\u6570\u63a7\u5236\u8fd9\u4e2a\u9759\u6001\u6570\u7ec4\u6709\u591a\u5927\u3002 #include <iostream> // size is the non-type parameter // size \u662f\u4e00\u4e2a\u975e\u7c7b\u578b\u53c2\u6570 template < class T , int size > class StaticArray { private : // The non-type parameter controls the size of the array // \u975e\u7c7b\u578b\u53c2\u6570\u63a7\u5236\u6570\u7ec4\u7684\u5927\u5c0f T m_array [ size ]; public : T * getArray (); T & operator []( int index ) { return m_array [ index ]; } }; // \u5c55\u793a\u4e00\u4e2a\u5e26\u6709\u975e\u7c7b\u578b\u53c2\u6570\u7684\u6a21\u677f\u7c7b\u4e2d\u7684\u51fd\u6570\u662f\u5982\u4f55\u5728\u7c7b\u5916\u5b9a\u4e49 // Showing how a function for a class with a non-type parameter is defined outside of the class template < class T , int size > T * StaticArray < T , size >:: getArray () { return m_array ; } int main () { // declare an integer array with room for 12 integers StaticArray < int , 12 > intArray ; // Fill it up in order, then print it backwards for ( int count = 0 ; count < 12 ; ++ count ) intArray [ count ] = count ; for ( int count = 11 ; count >= 0 ; -- count ) std :: cout << intArray [ count ] << \" \" ; std :: cout << '\\n' ; // declare a double buffer with room for 4 doubles StaticArray < double , 4 > doubleArray ; for ( int count = 0 ; count < 4 ; ++ count ) doubleArray [ count ] = 4.4 + 0.1 * count ; for ( int count = 0 ; count < 4 ; ++ count ) std :: cout << doubleArray [ count ] << ' ' ; return 0 ; } \u4ee3\u7801\u4ea7\u751f\u8ba9\u4ee5\u4e0b\u7ed3\u679c\uff1a 11 10 9 8 7 6 5 4 3 2 1 0 4.4 4.5 4.6 4.7 \u4e00\u70b9\u503c\u5f97\u6ce8\u610f\u7684\u4e8b\u60c5\u5173\u4e8e\u4ee5\u4e0a\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u6ca1\u6709\u4f7f\u7528\u52a8\u6001\u5185\u5b58\u5206\u914d\u5728 m_array \u6210\u5458\u4e0a\uff01\u8fd9\u662f\u56e0\u4e3a\u4efb\u4f55\u4f20\u5165 StaticArray \u7c7b\u4e2d\u7684 size \u5b9e\u9645\u4e0a\u90fd\u662f\u4e00\u4e2a\u5e38\u6570\uff0c\u4f8b\u5982\u5982\u679c\u4f60\u5b9e\u4f8b\u5316\u4e86 StaticArray<int, 12> \uff0c\u90a3\u4e48\u7f16\u8bd1\u5668\u4f1a\u4f7f\u7528 12 \u66ff\u6362 size \u3002\u56e0\u6b64 m_array \u662f int[12] \u7c7b\u578b\u7684\uff0c\u8fd9\u53ef\u4ee5\u8fdb\u884c\u9759\u6001\u5206\u914d\u3002 \u8fd9\u4e2a\u529f\u80fd\u4e5f\u88ab\u7528\u5728\u6807\u51c6\u7c7b std::array \u4e2d\uff0c\u5f53\u4f60\u5206\u914d\u4e86\u4e00\u4e2a std::array<int, 5> \u65f6\uff0cint\u662f\u4e00\u4e2a\u7c7b\u578b\u53c2\u6570\uff0c5 \u662f\u4e00\u4e2a\u975e\u7c7b\u578b\u53c2\u6570\u3002","title":"\u975e\u7c7b\u578b\u53c2\u6570"},{"location":"13-templates/13.5-function-template-specialization/","text":"13.5 \u51fd\u6570\u6a21\u677f\u7279\u5316 \u00b6 By Alex on December 3 rd , 2016 | last modified by Alex on January 23 rd , 2020 | \u7ffb\u8bd1by dashjay 2020.07.10 \u5f53\u4f60\u5b9e\u4f8b\u5316\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\uff0c\u4f7f\u7528\u7ed9\u5b9a\u7684\u7c7b\u578b\uff0c\u7f16\u8bd1\u5668\u4f1a\u590d\u523b\u4e00\u4efd\u6a21\u677f\u51fd\u6570\uff0c\u5e76\u4e14\u7528\u5b9e\u9645\u5b9a\u4e49\u7684\u8981\u4f7f\u7528\u7684\u53c2\u6570\u7c7b\u578b\u66ff\u6362\u6a21\u677f\u7c7b\u578b\u53c2\u6570\u3002\u8fd9\u610f\u5473\u7740\u4e00\u4e2a\u7279\u5b9a\u7684\u51fd\u6570\u5c06\u4f1a\u5728\u6bcf\u4e2a\u5b9e\u4f8b\u7c7b\u6709\u540c\u6837\u7684\u5b9e\u73b0\u7ec6\u8282\uff08\u4e5f\u5c31\u662f\u8bf4\u53ea\u662f\u7c7b\u578b\u4e0d\u540c\uff09\u3002\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u8fd9\u6b63\u662f\u4f60\u60f3\u8981\u7684\uff0c\u5076\u5c14\u4e5f\u6709\u4e00\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5728\u67d0\u4e9b\u7279\u6b8a\u7c7b\u578b\u7684\u6570\u636e\u4e0a\u5b9e\u4f8b\u5316\u6a21\u677f\u51fd\u6570\u4f1a\u6709\u8f7b\u5fae\u7684\u4e0d\u540c\u3002 \u6a21\u677f\u7279\u5316\u5c31\u662f\u89e3\u51b3\u8fd9\u4e2a\u7684\u65b9\u6cd5\u4e4b\u4e00\u3002 \u8ba9\u6211\u4eec\u54ea\u6765\u770b\u4e00\u4e2a\u5f88\u7b80\u5355\u7684\u4f8b\u5b50\uff1a template < class T > class Storage { private : T m_value ; public : Storage ( T value ) { m_value = value ; } ~ Storage () { } void print () { std :: cout << m_value << '\\n' ; } }; \u4ee5\u4e0a\u7684\u4ee3\u7801\u53ef\u4ee5\u5728\u5f88\u591a\u4e0d\u540c\u7684\u6570\u636e\u7c7b\u578b\u4e0b\u5de5\u4f5c\u3002 int main () { // Define some storage units Storage < int > nValue ( 5 ); Storage < double > dValue ( 6.7 ); // Print out some values nValue . print (); dValue . print (); } \u8fd9\u5c06\u4ea7\u751f\u7ed3\u679c 5 6.7 \u73b0\u5728\uff0c\u5047\u8bbe\u8bf4\u6211\u4eec\u60f3\u8981 double \u7c7b\u578b\uff08\u4ec5\u4ec5\u662f\u53cc\u7cbe\u6d6e\u70b9\u6570\uff09\u8f93\u51fa\u4e3a\u7279\u6b8a\u7684\u79d1\u5b66\u8ba1\u6570\u6cd5\u3002\u4e3a\u4e86\u8fbe\u5230\u8fd9\u4e2a\u76ee\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u51fd\u6570\u6a21\u677f\u7279\u5316\uff08\u6709\u65f6\u4e5f\u53eb\u505a\u663e\u5f0f\u51fd\u6570\u6a21\u677f\u7279\u5316\uff09\u6765\u4e3a double \u521b\u5efa\u4e00\u4e2a\u7279\u6b8a\u7248\u672c\u7684 print() \u51fd\u6570\u3002\u8fd9\u76f8\u5f53\u7b80\u5355\uff1a\u7b80\u5355\u7684\u5b9a\u4e49\u7279\u5316\u7684\u51fd\u6570\uff08\u5982\u679c\u51fd\u6570\u662f\u4e00\u4e2a\u7c7b\u578b\uff0c\u5728\u7c7b\u5b9a\u4e49\u5916\u7167\u505a\u5373\u53ef\u3002\uff09\u66ff\u6362\u6a21\u677f\u7c7b\u4e3a\u4f60\u60f3\u8981\u4e3a\u4e4b\u91cd\u5b9a\u4e49\u7684\u7279\u6b8a\u7c7b\u578b\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u4e3adoubles\u4e13\u95e8\u7279\u5316\u540e\u7684 print() \u51fd\u6570\uff1a template <> void Storage < double >:: print () { std :: cout << std :: scientific << m_value << '\\n' ; } \u5f53\u7f16\u8bd1\u5668\u5b9e\u4f8b\u5316 Storage<double>::print() \uff0c\u4ed6\u4f1a\u68c0\u67e5\u6211\u4eec\u65e9\u5c31\u663e\u5f0f\u7684\u5b9a\u4e49\u4e86\u51fd\u6570\uff0c\u5e76\u4e14\u5b83\u5c06\u4f1a\u4f7f\u7528\u90a3\u4e2a\u6211\u4eec\u65e9\u5c31\u5b9a\u4e49\u597d\u7684\u51fd\u6570\u66ff\u6362\u901a\u7528\u6a21\u677f\u51fd\u6570\u3002 \u6a21\u677f <> \u544a\u8bc9\u7f16\u8bd1\u5668\u8fd9\u662f\u4e00\u4e2a\u6a21\u677f\u51fd\u6570\uff0c\u5e76\u4e14\u6ca1\u6709\u6a21\u677f\u53c2\u6570\uff08\u56e0\u4e3a\u5728\u8fd9\u4e2a\u4f8b\u5b50\u91cc\uff0c\u6211\u4eec\u5df2\u7ecf\u663e\u5f0f\u7684\u5236\u5b9a\u4e86\u6240\u6709\u53c2\u6570\uff09\u3002\u4e00\u4e9b\u7f16\u8bd1\u5668\u53ef\u80fd\u5141\u8bb8\u4f60\u7701\u7565\u8fd9\u4e2a\uff0c\u4f46\u662f\u5e26\u4e0a\u5b83\u66f4\u5408\u9002\u3002 \u7ed3\u679c\uff0c\u6211\u4eec\u518d\u6b21\u8fd0\u884c\u4e4b\u524d\u7684\u7684\u7a0b\u5e8f\uff0c\u5c06\u4f1a\u6253\u5370\uff1a 5 6.700000e+000 \u53e6\u4e00\u4e2a\u4f8b\u5b50 \u73b0\u5728\u8ba9\u6211\u4eec\u6765\u4e3e\u53e6\u4e00\u4e2a\u4f8b\u5b50\uff0c\u8fd9\u65f6\u5019\u7684\u51fd\u6570\u7279\u5316\u662f\u53ef\u4ee5\u975e\u5e38\u6709\u7528\u3002\u601d\u8003\u5982\u679c\u6211\u4eec\u5c1d\u8bd5\u4f7f\u7528 char* \u6765\u5b9e\u4f8b\u5316\u6211\u4eec\u7684\u6a21\u677f\u7c7b Storage \uff0c\u5c06\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f int main () { // Dynamically allocate a temporary string char * string = new char [ 40 ]; // Ask user for their name std :: cout << \"Enter your name: \" ; std :: cin >> string ; // Store the name Storage < char *> storage ( string ); // Delete the temporary string delete [] string ; // Print out our value storage . print (); // This will print garbage } \u5f53\u7ed3\u679c\u51fa\u73b0\u65f6\uff0c\u4ee3\u66ff\u672c\u5e94\u8be5\u6253\u5370\u7528\u6237\u8f93\u5165\u7684 storage.print() \u6253\u5370\u4e86\u5783\u573e\uff08garbage\uff09\uff01\u53d1\u751f\u4e86\u4ec0\u4e48\uff1f \u5f53 Storate \u4f7f\u7528 char* \u5b9e\u4f8b\u5316\u65f6\uff0c Storage<char*> \u7684\u6784\u9020\u51fd\u6570\u770b\u8d77\u6765\u5c31\u50cf\u8fd9\u6837\uff1a template <> Storage < char *>:: Storage ( char * value ) { m_value = value ; } \u6362\u53e5\u8bdd\u8bf4\uff0c\u8fd9\u5c31\u662f\u505a\u4e86\u4e00\u4e2a\u6307\u9488\u8d4b\u503c\uff08\u6d45\u62f7\u8d1d\uff09\uff01\u7ed3\u679c\uff0c m_value \u548c string \u6307\u5411\u76f8\u540c\u7684\u5185\u5b58\u5730\u5740\u3002\u5f53\u6211\u4eec\u5220\u9664 string \u5728 main \u4e2d\uff0c\u6211\u4eec\u5220\u9664\u4e86 m_value \u6307\u5411\u7684\u6570\u636e\uff01\u56e0\u6b64\uff0c\u5f53\u6211\u4eec\u6253\u5370\u8fd9\u4e9b\u503c\u65f6\uff0c\u51fa\u73b0\u7684\u5c31\u662f\u4e00\u4e9b\u5783\u573e\u3002 \u5e78\u8fd0\u7684\u662f\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u6a21\u677f\u7279\u5316\u4fee\u590d\u8fd9\u4e9b\u95ee\u9898\u3002\u76f8\u6bd4\u4e8e\u505a\u4e00\u4e2a\u6307\u9488\u62f7\u8d1d\uff0c\u6211\u4eec\u5e94\u8be5\u50cf\u6784\u9020\u51fd\u6570\u90a3\u6837\uff0c\u5bf9\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u505a\u4e00\u4e2a\u5b8c\u5168\u62f7\u8d1d\u3002\u56e0\u6b64\u6211\u4eec\u6765\u4e3a char* \u8fd9\u4e2a\u7c7b\u5199\u4e00\u4e2a\u7279\u5316\u7684\u6784\u9020\u51fd\u6570\uff0c\uff0c\u4e13\u95e8\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 template <> Storage < char *>:: Storage ( char * value ) { // Figure out how long the string in value is int length = 0 ; while ( value [ length ] != '\\0' ) ++ length ; ++ length ; // +1 to account for null terminator // Allocate memory to hold the value string m_value = new char [ length ]; // Copy the actual value string into the m_value memory we just allocated for ( int count = 0 ; count < length ; ++ count ) m_value [ count ] = value [ count ]; } \u73b0\u5728\u5f53\u4e3a Strorage<char*> \u7ed9\u53d8\u91cf\u5206\u914d\u5185\u5b58\u65f6\uff0c\u8fd9\u4e2a\u6784\u9020\u51fd\u6570\u5c06\u4f1a\u88ab\u4f7f\u7528\u6765\u66ff\u4ee3\u9ed8\u8ba4\u7684\u90a3\u4e2a\u3002\u7ed3\u679c m_value \u5c06\u4f1a\u6536\u5230\u5b83\u81ea\u5df1\u7684\u90a3\u4efd string \u7684\u62f7\u8d1d\u3002\u56e0\u6b64\uff0c\u5f53\u6211\u4eec\u5220\u9664 string \u65f6\uff0cm_value \u5c06\u4e0d\u4f1a\u88ab\u5f71\u54cd\u3002 \u7136\u800c\uff0c\u8fd9\u4e2a\u7c7b\u73b0\u5728\u6709\u5185\u5b58\u6cc4\u9732\u5f53\u4f7f\u7528 char* \u5b9e\u4f8b\u5316\u65f6\uff0c\u56e0\u4e3a m_value \u5c06\u4e0d\u4f1a\u88ab\u5220\u9664\uff0c\u5f53\u4e00\u4e2a Storage \u53d8\u91cf\u79bb\u5f00\u4f5c\u7528\u4e8e\u65f6\u3002\u5c31\u50cf\u4f60\u731c\u7684\u90a3\u6837\uff0c\u8fd9\u4e5f\u53ef\u4ee5\u88ab\u89e3\u51b3\uff0c\u901a\u8fc7\u7279\u5316 Storage<char*> \u3002 template <> Storage < char *>::~ Storage () { delete [] m_value ; } Now when variables of type Storage go out of scope, the memory allocated in the specialized constructor will be deleted in the specialized destructor. \u73b0\u5728\u5f53 Storate<char*> \u79bb\u5f00\u4f5c\u7528\u4e8e\u7684\u65f6\u5019\uff0c\u7279\u5316\u7684\u6784\u9020\u51fd\u6570\u5206\u914d\u7684\u5185\u5b58\u5c06\u4f1a\u88ab\u7279\u5316\u7684\u6790\u6784\u51fd\u6570\u7ed9\u5220\u9664\u3002 \u4ee5\u4e0a\u7684\u4f8b\u5b50\u867d\u7136\u5168\u90fd\u7528\u4e86\u6210\u5458\u51fd\u6570\uff0c\u4f60\u4ecd\u7136\u53ef\u4ee5\u7279\u5316\u4e00\u4e2a\u975e\u6210\u5458\u6a21\u677f\u51fd\u6570\u4ee5\u540c\u6837\u7684\u65b9\u5f0f\u3002","title":"13.5 \u51fd\u6570\u6a21\u677f\u7279\u5316"},{"location":"13-templates/13.5-function-template-specialization/#135","text":"By Alex on December 3 rd , 2016 | last modified by Alex on January 23 rd , 2020 | \u7ffb\u8bd1by dashjay 2020.07.10 \u5f53\u4f60\u5b9e\u4f8b\u5316\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\uff0c\u4f7f\u7528\u7ed9\u5b9a\u7684\u7c7b\u578b\uff0c\u7f16\u8bd1\u5668\u4f1a\u590d\u523b\u4e00\u4efd\u6a21\u677f\u51fd\u6570\uff0c\u5e76\u4e14\u7528\u5b9e\u9645\u5b9a\u4e49\u7684\u8981\u4f7f\u7528\u7684\u53c2\u6570\u7c7b\u578b\u66ff\u6362\u6a21\u677f\u7c7b\u578b\u53c2\u6570\u3002\u8fd9\u610f\u5473\u7740\u4e00\u4e2a\u7279\u5b9a\u7684\u51fd\u6570\u5c06\u4f1a\u5728\u6bcf\u4e2a\u5b9e\u4f8b\u7c7b\u6709\u540c\u6837\u7684\u5b9e\u73b0\u7ec6\u8282\uff08\u4e5f\u5c31\u662f\u8bf4\u53ea\u662f\u7c7b\u578b\u4e0d\u540c\uff09\u3002\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u8fd9\u6b63\u662f\u4f60\u60f3\u8981\u7684\uff0c\u5076\u5c14\u4e5f\u6709\u4e00\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5728\u67d0\u4e9b\u7279\u6b8a\u7c7b\u578b\u7684\u6570\u636e\u4e0a\u5b9e\u4f8b\u5316\u6a21\u677f\u51fd\u6570\u4f1a\u6709\u8f7b\u5fae\u7684\u4e0d\u540c\u3002 \u6a21\u677f\u7279\u5316\u5c31\u662f\u89e3\u51b3\u8fd9\u4e2a\u7684\u65b9\u6cd5\u4e4b\u4e00\u3002 \u8ba9\u6211\u4eec\u54ea\u6765\u770b\u4e00\u4e2a\u5f88\u7b80\u5355\u7684\u4f8b\u5b50\uff1a template < class T > class Storage { private : T m_value ; public : Storage ( T value ) { m_value = value ; } ~ Storage () { } void print () { std :: cout << m_value << '\\n' ; } }; \u4ee5\u4e0a\u7684\u4ee3\u7801\u53ef\u4ee5\u5728\u5f88\u591a\u4e0d\u540c\u7684\u6570\u636e\u7c7b\u578b\u4e0b\u5de5\u4f5c\u3002 int main () { // Define some storage units Storage < int > nValue ( 5 ); Storage < double > dValue ( 6.7 ); // Print out some values nValue . print (); dValue . print (); } \u8fd9\u5c06\u4ea7\u751f\u7ed3\u679c 5 6.7 \u73b0\u5728\uff0c\u5047\u8bbe\u8bf4\u6211\u4eec\u60f3\u8981 double \u7c7b\u578b\uff08\u4ec5\u4ec5\u662f\u53cc\u7cbe\u6d6e\u70b9\u6570\uff09\u8f93\u51fa\u4e3a\u7279\u6b8a\u7684\u79d1\u5b66\u8ba1\u6570\u6cd5\u3002\u4e3a\u4e86\u8fbe\u5230\u8fd9\u4e2a\u76ee\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u51fd\u6570\u6a21\u677f\u7279\u5316\uff08\u6709\u65f6\u4e5f\u53eb\u505a\u663e\u5f0f\u51fd\u6570\u6a21\u677f\u7279\u5316\uff09\u6765\u4e3a double \u521b\u5efa\u4e00\u4e2a\u7279\u6b8a\u7248\u672c\u7684 print() \u51fd\u6570\u3002\u8fd9\u76f8\u5f53\u7b80\u5355\uff1a\u7b80\u5355\u7684\u5b9a\u4e49\u7279\u5316\u7684\u51fd\u6570\uff08\u5982\u679c\u51fd\u6570\u662f\u4e00\u4e2a\u7c7b\u578b\uff0c\u5728\u7c7b\u5b9a\u4e49\u5916\u7167\u505a\u5373\u53ef\u3002\uff09\u66ff\u6362\u6a21\u677f\u7c7b\u4e3a\u4f60\u60f3\u8981\u4e3a\u4e4b\u91cd\u5b9a\u4e49\u7684\u7279\u6b8a\u7c7b\u578b\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u4e3adoubles\u4e13\u95e8\u7279\u5316\u540e\u7684 print() \u51fd\u6570\uff1a template <> void Storage < double >:: print () { std :: cout << std :: scientific << m_value << '\\n' ; } \u5f53\u7f16\u8bd1\u5668\u5b9e\u4f8b\u5316 Storage<double>::print() \uff0c\u4ed6\u4f1a\u68c0\u67e5\u6211\u4eec\u65e9\u5c31\u663e\u5f0f\u7684\u5b9a\u4e49\u4e86\u51fd\u6570\uff0c\u5e76\u4e14\u5b83\u5c06\u4f1a\u4f7f\u7528\u90a3\u4e2a\u6211\u4eec\u65e9\u5c31\u5b9a\u4e49\u597d\u7684\u51fd\u6570\u66ff\u6362\u901a\u7528\u6a21\u677f\u51fd\u6570\u3002 \u6a21\u677f <> \u544a\u8bc9\u7f16\u8bd1\u5668\u8fd9\u662f\u4e00\u4e2a\u6a21\u677f\u51fd\u6570\uff0c\u5e76\u4e14\u6ca1\u6709\u6a21\u677f\u53c2\u6570\uff08\u56e0\u4e3a\u5728\u8fd9\u4e2a\u4f8b\u5b50\u91cc\uff0c\u6211\u4eec\u5df2\u7ecf\u663e\u5f0f\u7684\u5236\u5b9a\u4e86\u6240\u6709\u53c2\u6570\uff09\u3002\u4e00\u4e9b\u7f16\u8bd1\u5668\u53ef\u80fd\u5141\u8bb8\u4f60\u7701\u7565\u8fd9\u4e2a\uff0c\u4f46\u662f\u5e26\u4e0a\u5b83\u66f4\u5408\u9002\u3002 \u7ed3\u679c\uff0c\u6211\u4eec\u518d\u6b21\u8fd0\u884c\u4e4b\u524d\u7684\u7684\u7a0b\u5e8f\uff0c\u5c06\u4f1a\u6253\u5370\uff1a 5 6.700000e+000 \u53e6\u4e00\u4e2a\u4f8b\u5b50 \u73b0\u5728\u8ba9\u6211\u4eec\u6765\u4e3e\u53e6\u4e00\u4e2a\u4f8b\u5b50\uff0c\u8fd9\u65f6\u5019\u7684\u51fd\u6570\u7279\u5316\u662f\u53ef\u4ee5\u975e\u5e38\u6709\u7528\u3002\u601d\u8003\u5982\u679c\u6211\u4eec\u5c1d\u8bd5\u4f7f\u7528 char* \u6765\u5b9e\u4f8b\u5316\u6211\u4eec\u7684\u6a21\u677f\u7c7b Storage \uff0c\u5c06\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f int main () { // Dynamically allocate a temporary string char * string = new char [ 40 ]; // Ask user for their name std :: cout << \"Enter your name: \" ; std :: cin >> string ; // Store the name Storage < char *> storage ( string ); // Delete the temporary string delete [] string ; // Print out our value storage . print (); // This will print garbage } \u5f53\u7ed3\u679c\u51fa\u73b0\u65f6\uff0c\u4ee3\u66ff\u672c\u5e94\u8be5\u6253\u5370\u7528\u6237\u8f93\u5165\u7684 storage.print() \u6253\u5370\u4e86\u5783\u573e\uff08garbage\uff09\uff01\u53d1\u751f\u4e86\u4ec0\u4e48\uff1f \u5f53 Storate \u4f7f\u7528 char* \u5b9e\u4f8b\u5316\u65f6\uff0c Storage<char*> \u7684\u6784\u9020\u51fd\u6570\u770b\u8d77\u6765\u5c31\u50cf\u8fd9\u6837\uff1a template <> Storage < char *>:: Storage ( char * value ) { m_value = value ; } \u6362\u53e5\u8bdd\u8bf4\uff0c\u8fd9\u5c31\u662f\u505a\u4e86\u4e00\u4e2a\u6307\u9488\u8d4b\u503c\uff08\u6d45\u62f7\u8d1d\uff09\uff01\u7ed3\u679c\uff0c m_value \u548c string \u6307\u5411\u76f8\u540c\u7684\u5185\u5b58\u5730\u5740\u3002\u5f53\u6211\u4eec\u5220\u9664 string \u5728 main \u4e2d\uff0c\u6211\u4eec\u5220\u9664\u4e86 m_value \u6307\u5411\u7684\u6570\u636e\uff01\u56e0\u6b64\uff0c\u5f53\u6211\u4eec\u6253\u5370\u8fd9\u4e9b\u503c\u65f6\uff0c\u51fa\u73b0\u7684\u5c31\u662f\u4e00\u4e9b\u5783\u573e\u3002 \u5e78\u8fd0\u7684\u662f\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u6a21\u677f\u7279\u5316\u4fee\u590d\u8fd9\u4e9b\u95ee\u9898\u3002\u76f8\u6bd4\u4e8e\u505a\u4e00\u4e2a\u6307\u9488\u62f7\u8d1d\uff0c\u6211\u4eec\u5e94\u8be5\u50cf\u6784\u9020\u51fd\u6570\u90a3\u6837\uff0c\u5bf9\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u505a\u4e00\u4e2a\u5b8c\u5168\u62f7\u8d1d\u3002\u56e0\u6b64\u6211\u4eec\u6765\u4e3a char* \u8fd9\u4e2a\u7c7b\u5199\u4e00\u4e2a\u7279\u5316\u7684\u6784\u9020\u51fd\u6570\uff0c\uff0c\u4e13\u95e8\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 template <> Storage < char *>:: Storage ( char * value ) { // Figure out how long the string in value is int length = 0 ; while ( value [ length ] != '\\0' ) ++ length ; ++ length ; // +1 to account for null terminator // Allocate memory to hold the value string m_value = new char [ length ]; // Copy the actual value string into the m_value memory we just allocated for ( int count = 0 ; count < length ; ++ count ) m_value [ count ] = value [ count ]; } \u73b0\u5728\u5f53\u4e3a Strorage<char*> \u7ed9\u53d8\u91cf\u5206\u914d\u5185\u5b58\u65f6\uff0c\u8fd9\u4e2a\u6784\u9020\u51fd\u6570\u5c06\u4f1a\u88ab\u4f7f\u7528\u6765\u66ff\u4ee3\u9ed8\u8ba4\u7684\u90a3\u4e2a\u3002\u7ed3\u679c m_value \u5c06\u4f1a\u6536\u5230\u5b83\u81ea\u5df1\u7684\u90a3\u4efd string \u7684\u62f7\u8d1d\u3002\u56e0\u6b64\uff0c\u5f53\u6211\u4eec\u5220\u9664 string \u65f6\uff0cm_value \u5c06\u4e0d\u4f1a\u88ab\u5f71\u54cd\u3002 \u7136\u800c\uff0c\u8fd9\u4e2a\u7c7b\u73b0\u5728\u6709\u5185\u5b58\u6cc4\u9732\u5f53\u4f7f\u7528 char* \u5b9e\u4f8b\u5316\u65f6\uff0c\u56e0\u4e3a m_value \u5c06\u4e0d\u4f1a\u88ab\u5220\u9664\uff0c\u5f53\u4e00\u4e2a Storage \u53d8\u91cf\u79bb\u5f00\u4f5c\u7528\u4e8e\u65f6\u3002\u5c31\u50cf\u4f60\u731c\u7684\u90a3\u6837\uff0c\u8fd9\u4e5f\u53ef\u4ee5\u88ab\u89e3\u51b3\uff0c\u901a\u8fc7\u7279\u5316 Storage<char*> \u3002 template <> Storage < char *>::~ Storage () { delete [] m_value ; } Now when variables of type Storage go out of scope, the memory allocated in the specialized constructor will be deleted in the specialized destructor. \u73b0\u5728\u5f53 Storate<char*> \u79bb\u5f00\u4f5c\u7528\u4e8e\u7684\u65f6\u5019\uff0c\u7279\u5316\u7684\u6784\u9020\u51fd\u6570\u5206\u914d\u7684\u5185\u5b58\u5c06\u4f1a\u88ab\u7279\u5316\u7684\u6790\u6784\u51fd\u6570\u7ed9\u5220\u9664\u3002 \u4ee5\u4e0a\u7684\u4f8b\u5b50\u867d\u7136\u5168\u90fd\u7528\u4e86\u6210\u5458\u51fd\u6570\uff0c\u4f60\u4ecd\u7136\u53ef\u4ee5\u7279\u5316\u4e00\u4e2a\u975e\u6210\u5458\u6a21\u677f\u51fd\u6570\u4ee5\u540c\u6837\u7684\u65b9\u5f0f\u3002","title":"13.5 \u51fd\u6570\u6a21\u677f\u7279\u5316"},{"location":"13-templates/13.7-partial-template-specialization/","text":"13.7 \u5c40\u90e8\u6a21\u677f\u7279\u5316 \u00b6 By Alex on August 17 th , 2008 | last modified by nascardriver on March 28 th , 2020 This lesson and the next are optional reading for those desiring a deeper knowledge of C++ templates. Partial template specialization is not used all that often (but can be useful in specific cases). In lesson 13.4 -- Template non-type parameters, you learned how expression parameters could be used to parameterize template classes. Let\u2019s take another look at the Static Array class we used in one of our previous examples: template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } }; This class takes two template parameters, a type parameter, and an expression parameter. Now, let\u2019s say we wanted to write a function to print out the whole array. Although we could implement this as a member function, we\u2019re going to do it as a non-member function instead because it will make the successive examples easier to follow. Using templates, we might write something like this: template < typename T , int size > void print ( StaticArray < T , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ] << ' ' ; } This would allow us to do the following: #include <iostream> #include <cstring> template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } }; template < typename T , int size > void print ( StaticArray < T , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ] << ' ' ; } int main () { // declare an int array StaticArray < int , 4 > int4 {}; int4 [ 0 ] = 0 ; int4 [ 1 ] = 1 ; int4 [ 2 ] = 2 ; int4 [ 3 ] = 3 ; // Print the array print ( int4 ); return 0 ; } and get the following result: 0 1 2 3 Although this works, it has a design flaw. Consider the following: int main () { // declare a char array StaticArray < char , 14 > char14 {}; std :: strcpy ( char14 . getArray (), \"Hello, world!\" ); // Print the array print ( char14 ); return 0 ; } (We covered std::strcpy in lesson 6.6 -- C-style strings if you need a refresher) This program will compile, execute, and produce the following value (or one similar): H e l l o , w o r l d ! For non-char types, it makes sense to put a space between each array element, so they don\u2019t run together. However, with a char type, it makes more sense to print everything run together as a C-style string, which our print() function doesn\u2019t do. So how can we fix this? Template specialization to the rescue? One might first think of using template specialization. The problem with full template specialization is that all template parameters must be explicitly defined. Consider: #include <iostream> #include <cstring> template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } }; template < typename T , int size > void print ( StaticArray < T , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ] << ' ' ; } // Override print() for fully specialized StaticArray<char, 14> template <> void print ( StaticArray < char , 14 > & array ) { for ( int count { 0 }; count < 14 ; ++ count ) std :: cout << array [ count ]; } int main () { // declare a char array StaticArray < char , 14 > char14 {}; std :: strcpy ( char14 . getArray (), \"Hello, world!\" ); // Print the array print ( char14 ); return 0 ; } As you can see, we\u2019ve now provided an overloaded print function for fully specialized StaticArray . Indeed, this prints: Hello, world! Although this solves the issue of making sure print() can be called with a StaticArray , it brings up another problem: using full template specialization means we have to explicitly define the length of the array this function will accept! Consider the following example: int main () { // declare a char array StaticArray < char , 12 > char12 {}; std :: strcpy ( char12 . getArray (), \"Hello, mom!\" ); // Print the array print ( char12 ); return 0 ; } Calling print() with char12 will call the version of print() that takes a StaticArray , because char12 is of type StaticArray , and our overloaded print() will only be called when passed a StaticArray . Although we could make a copy of print() that handles StaticArray , what happens when we want to call print() with an array size of 5, or 22? We\u2019d have to copy the function for each different array size. That\u2019s redundant. Obviously full template specialization is too restrictive a solution here. The solution we are looking for is partial template specialization. Partial template specialization Partial template specialization allows us to specialize classes (but not individual functions!) where some, but not all, of the template parameters have been explicitly defined. For our challenge above, the ideal solution would be to have our overloaded print function work with StaticArray of type char, but leave the length expression parameter templated so it can vary as needed. Partial template specialization allows us to do just that! Here\u2019s our example with an overloaded print function that takes a partially specialized StaticArray: // overload of print() function for partially specialized StaticArray<char, size> template < int size > // size is still a templated expression parameter void print ( StaticArray < char , size > & array ) // we're explicitly defining type char here { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ]; } As you can see here, we\u2019ve explicitly declared that this function will only work for StaticArray of type char, but size is still a templated expression parameter, so it will work for char arrays of any size. That\u2019s all there is to it! Here\u2019s a full program using this: #include <iostream> #include <cstring> template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } }; template < typename T , int size > void print ( StaticArray < T , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ] << ' ' ; } // overload of print() function for partially specialized StaticArray<char, size> template < int size > void print ( StaticArray < char , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ]; } int main () { // Declare an char array of size 14 StaticArray < char , 14 > char14 {}; std :: strcpy ( char14 . getArray (), \"Hello, world!\" ); // Print the array print ( char14 ); // Now declare an char array of size 12 StaticArray < char , 12 > char12 {}; std :: strcpy ( char12 . getArray (), \"Hello, mom!\" ); // Print the array print ( char12 ); return 0 ; } This prints: Hello, world! Hello, mom! Just as we expect. Note that as of C++14, partial template specialization can only be used with classes, not template functions (functions must be fully specialized). Our void print(StaticArray &array) example works because the print function is not partially specialized (it\u2019s just an overloaded function using a class parameter that\u2019s partially specialized). Partial template specialization for member functions The limitation on the partial specialization of functions can lead to some challenges when dealing with member functions. For example, what if we had defined StaticArray like this? template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } void print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << m_array [ i ] << ' ' ; std :: cout << '\\n' ; } }; print() is now a member function of class StaticArray . So what happens when we want to partially specialize print(), so that it works differently? You might try this: // Doesn't work template < int size > void StaticArray < double , size >:: print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << std :: scientific << m_array [ i ] << ' ' ; std :: cout << '\\n' ; } Unfortunately, this doesn\u2019t work, because we\u2019re trying to partially specialize a function, which is disallowed. So how do we get around this? One obvious way is to partially specialize the entire class: #include <iostream> template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } void print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << m_array [ i ] << ' ' ; std :: cout << \" \\n \" ; } }; template < int size > // size is the expression parameter class StaticArray < double , size > { private : // The expression parameter controls the size of the array double m_array [ size ]{}; public : double * getArray () { return m_array ; } double & operator []( int index ) { return m_array [ index ]; } void print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << std :: scientific << m_array [ i ] << ' ' ; std :: cout << '\\n' ; } }; int main () { // declare an integer array with room for 6 integers StaticArray < int , 6 > intArray {}; // Fill it up in order, then print it for ( int count { 0 }; count < 6 ; ++ count ) intArray [ count ] = count ; intArray . print (); // declare a double buffer with room for 4 doubles StaticArray < double , 4 > doubleArray {}; for ( int count { 0 }; count < 4 ; ++ count ) doubleArray [ count ] = ( 4.0 + 0.1 * count ); doubleArray . print (); return 0 ; } This prints: 0 1 2 3 4 5 4.000000e+00 4.100000e+00 4.200000e+00 4.300000e+00 While it works, this isn\u2019t a great solution, because we had to duplicate a lot of code from StaticArray to StaticArray . If only there were some way to reuse the code in StaticArray in StaticArray . Sounds like a job for inheritance! You might start off trying to write that code like this: template < int size > // size is the expression parameter class StaticArray < double , size >: public StaticArray < // Then what? How do we reference StaticArray? We can\u2019t. Fortunately, there\u2019s a workaround, by using a common base class: #include <iostream> template < class T , int size > // size is the expression parameter class StaticArray_Base { protected : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } virtual void print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << m_array [ i ]; std :: cout << '\\n' ; } virtual ~ StaticArray_Base () = default ; }; template < class T , int size > // size is the expression parameter class StaticArray : public StaticArray_Base < T , size > { public : }; template < int size > // size is the expression parameter class StaticArray < double , size >: public StaticArray_Base < double , size > { public : virtual void print () override { for ( int i { 0 }; i < size ; ++ i ) std :: cout << std :: scientific << this -> m_array [ i ] << ' ' ; // note: The this-> prefix in the above line is needed. // See https://stackoverflow.com/a/6592617 or https://isocpp.org/wiki/faq/templates#nondependent-name-lookup-members for more info on why. std :: cout << '\\n' ; } }; int main () { // declare an integer array with room for 6 integers StaticArray < int , 6 > intArray {}; // Fill it up in order, then print it for ( int count { 0 }; count < 6 ; ++ count ) intArray [ count ] = count ; intArray . print (); // declare a double buffer with room for 4 doubles StaticArray < double , 4 > doubleArray {}; for ( int count { 0 }; count < 4 ; ++ count ) doubleArray [ count ] = ( 4.0 + 0.1 * count ); doubleArray . print (); return 0 ; } This prints the same as above, but has significantly less duplicated code.","title":"13.7 \u5c40\u90e8\u6a21\u677f\u7279\u5316"},{"location":"13-templates/13.7-partial-template-specialization/#137","text":"By Alex on August 17 th , 2008 | last modified by nascardriver on March 28 th , 2020 This lesson and the next are optional reading for those desiring a deeper knowledge of C++ templates. Partial template specialization is not used all that often (but can be useful in specific cases). In lesson 13.4 -- Template non-type parameters, you learned how expression parameters could be used to parameterize template classes. Let\u2019s take another look at the Static Array class we used in one of our previous examples: template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } }; This class takes two template parameters, a type parameter, and an expression parameter. Now, let\u2019s say we wanted to write a function to print out the whole array. Although we could implement this as a member function, we\u2019re going to do it as a non-member function instead because it will make the successive examples easier to follow. Using templates, we might write something like this: template < typename T , int size > void print ( StaticArray < T , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ] << ' ' ; } This would allow us to do the following: #include <iostream> #include <cstring> template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } }; template < typename T , int size > void print ( StaticArray < T , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ] << ' ' ; } int main () { // declare an int array StaticArray < int , 4 > int4 {}; int4 [ 0 ] = 0 ; int4 [ 1 ] = 1 ; int4 [ 2 ] = 2 ; int4 [ 3 ] = 3 ; // Print the array print ( int4 ); return 0 ; } and get the following result: 0 1 2 3 Although this works, it has a design flaw. Consider the following: int main () { // declare a char array StaticArray < char , 14 > char14 {}; std :: strcpy ( char14 . getArray (), \"Hello, world!\" ); // Print the array print ( char14 ); return 0 ; } (We covered std::strcpy in lesson 6.6 -- C-style strings if you need a refresher) This program will compile, execute, and produce the following value (or one similar): H e l l o , w o r l d ! For non-char types, it makes sense to put a space between each array element, so they don\u2019t run together. However, with a char type, it makes more sense to print everything run together as a C-style string, which our print() function doesn\u2019t do. So how can we fix this? Template specialization to the rescue? One might first think of using template specialization. The problem with full template specialization is that all template parameters must be explicitly defined. Consider: #include <iostream> #include <cstring> template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } }; template < typename T , int size > void print ( StaticArray < T , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ] << ' ' ; } // Override print() for fully specialized StaticArray<char, 14> template <> void print ( StaticArray < char , 14 > & array ) { for ( int count { 0 }; count < 14 ; ++ count ) std :: cout << array [ count ]; } int main () { // declare a char array StaticArray < char , 14 > char14 {}; std :: strcpy ( char14 . getArray (), \"Hello, world!\" ); // Print the array print ( char14 ); return 0 ; } As you can see, we\u2019ve now provided an overloaded print function for fully specialized StaticArray . Indeed, this prints: Hello, world! Although this solves the issue of making sure print() can be called with a StaticArray , it brings up another problem: using full template specialization means we have to explicitly define the length of the array this function will accept! Consider the following example: int main () { // declare a char array StaticArray < char , 12 > char12 {}; std :: strcpy ( char12 . getArray (), \"Hello, mom!\" ); // Print the array print ( char12 ); return 0 ; } Calling print() with char12 will call the version of print() that takes a StaticArray , because char12 is of type StaticArray , and our overloaded print() will only be called when passed a StaticArray . Although we could make a copy of print() that handles StaticArray , what happens when we want to call print() with an array size of 5, or 22? We\u2019d have to copy the function for each different array size. That\u2019s redundant. Obviously full template specialization is too restrictive a solution here. The solution we are looking for is partial template specialization. Partial template specialization Partial template specialization allows us to specialize classes (but not individual functions!) where some, but not all, of the template parameters have been explicitly defined. For our challenge above, the ideal solution would be to have our overloaded print function work with StaticArray of type char, but leave the length expression parameter templated so it can vary as needed. Partial template specialization allows us to do just that! Here\u2019s our example with an overloaded print function that takes a partially specialized StaticArray: // overload of print() function for partially specialized StaticArray<char, size> template < int size > // size is still a templated expression parameter void print ( StaticArray < char , size > & array ) // we're explicitly defining type char here { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ]; } As you can see here, we\u2019ve explicitly declared that this function will only work for StaticArray of type char, but size is still a templated expression parameter, so it will work for char arrays of any size. That\u2019s all there is to it! Here\u2019s a full program using this: #include <iostream> #include <cstring> template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } }; template < typename T , int size > void print ( StaticArray < T , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ] << ' ' ; } // overload of print() function for partially specialized StaticArray<char, size> template < int size > void print ( StaticArray < char , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ]; } int main () { // Declare an char array of size 14 StaticArray < char , 14 > char14 {}; std :: strcpy ( char14 . getArray (), \"Hello, world!\" ); // Print the array print ( char14 ); // Now declare an char array of size 12 StaticArray < char , 12 > char12 {}; std :: strcpy ( char12 . getArray (), \"Hello, mom!\" ); // Print the array print ( char12 ); return 0 ; } This prints: Hello, world! Hello, mom! Just as we expect. Note that as of C++14, partial template specialization can only be used with classes, not template functions (functions must be fully specialized). Our void print(StaticArray &array) example works because the print function is not partially specialized (it\u2019s just an overloaded function using a class parameter that\u2019s partially specialized). Partial template specialization for member functions The limitation on the partial specialization of functions can lead to some challenges when dealing with member functions. For example, what if we had defined StaticArray like this? template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } void print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << m_array [ i ] << ' ' ; std :: cout << '\\n' ; } }; print() is now a member function of class StaticArray . So what happens when we want to partially specialize print(), so that it works differently? You might try this: // Doesn't work template < int size > void StaticArray < double , size >:: print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << std :: scientific << m_array [ i ] << ' ' ; std :: cout << '\\n' ; } Unfortunately, this doesn\u2019t work, because we\u2019re trying to partially specialize a function, which is disallowed. So how do we get around this? One obvious way is to partially specialize the entire class: #include <iostream> template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } void print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << m_array [ i ] << ' ' ; std :: cout << \" \\n \" ; } }; template < int size > // size is the expression parameter class StaticArray < double , size > { private : // The expression parameter controls the size of the array double m_array [ size ]{}; public : double * getArray () { return m_array ; } double & operator []( int index ) { return m_array [ index ]; } void print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << std :: scientific << m_array [ i ] << ' ' ; std :: cout << '\\n' ; } }; int main () { // declare an integer array with room for 6 integers StaticArray < int , 6 > intArray {}; // Fill it up in order, then print it for ( int count { 0 }; count < 6 ; ++ count ) intArray [ count ] = count ; intArray . print (); // declare a double buffer with room for 4 doubles StaticArray < double , 4 > doubleArray {}; for ( int count { 0 }; count < 4 ; ++ count ) doubleArray [ count ] = ( 4.0 + 0.1 * count ); doubleArray . print (); return 0 ; } This prints: 0 1 2 3 4 5 4.000000e+00 4.100000e+00 4.200000e+00 4.300000e+00 While it works, this isn\u2019t a great solution, because we had to duplicate a lot of code from StaticArray to StaticArray . If only there were some way to reuse the code in StaticArray in StaticArray . Sounds like a job for inheritance! You might start off trying to write that code like this: template < int size > // size is the expression parameter class StaticArray < double , size >: public StaticArray < // Then what? How do we reference StaticArray? We can\u2019t. Fortunately, there\u2019s a workaround, by using a common base class: #include <iostream> template < class T , int size > // size is the expression parameter class StaticArray_Base { protected : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } virtual void print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << m_array [ i ]; std :: cout << '\\n' ; } virtual ~ StaticArray_Base () = default ; }; template < class T , int size > // size is the expression parameter class StaticArray : public StaticArray_Base < T , size > { public : }; template < int size > // size is the expression parameter class StaticArray < double , size >: public StaticArray_Base < double , size > { public : virtual void print () override { for ( int i { 0 }; i < size ; ++ i ) std :: cout << std :: scientific << this -> m_array [ i ] << ' ' ; // note: The this-> prefix in the above line is needed. // See https://stackoverflow.com/a/6592617 or https://isocpp.org/wiki/faq/templates#nondependent-name-lookup-members for more info on why. std :: cout << '\\n' ; } }; int main () { // declare an integer array with room for 6 integers StaticArray < int , 6 > intArray {}; // Fill it up in order, then print it for ( int count { 0 }; count < 6 ; ++ count ) intArray [ count ] = count ; intArray . print (); // declare a double buffer with room for 4 doubles StaticArray < double , 4 > doubleArray {}; for ( int count { 0 }; count < 4 ; ++ count ) doubleArray [ count ] = ( 4.0 + 0.1 * count ); doubleArray . print (); return 0 ; } This prints the same as above, but has significantly less duplicated code.","title":"13.7 \u5c40\u90e8\u6a21\u677f\u7279\u5316"},{"location":"13-templates/13.8-partial-template-specialization-for-pointers/","text":"13.8 \u6307\u9488\u7684\u5c40\u90e8\u6a21\u677f\u7279\u5316 \u00b6 By Alex on December 5 th , 2016 | last modified by Alex on January 23 rd , 2020 In previous lesson 13.5 -- Function template specialization, we took a look at a simple templated Storage class: #include <iostream> template < class T > class Storage { private : T m_value ; public : Storage ( T value ) { m_value = value ; } ~ Storage () { } void print () { std :: cout << m_value << '\\n' ; } }; We showed that this class had problems when template parameter T was of type char*because of the shallow copy/pointer assignment that takes place in the constructor. In that lesson, we used full template specialization to create a specialized version of the Storage constructor for type char* that allocated memory and created an actual deep copy of m_value. For reference, here\u2019s the fully specialized char* Storage constructor and destructor: // You need to include the Storage<T> class from the example above here template <> Storage < char *>:: Storage ( char * value ) { // Figure out how long the string in value is int length = 0 ; while ( value [ length ] != '\\0' ) ++ length ; ++ length ; // +1 to account for null terminator // Allocate memory to hold the value string m_value = new char [ length ]; // Copy the actual value string into the m_value memory we just allocated for ( int count = 0 ; count < length ; ++ count ) m_value [ count ] = value [ count ]; } template <> Storage < char *>::~ Storage () { delete [] m_value ; } While that worked great for Storage , what about other pointer types (such as int*)? It\u2019s fairly easy to see that if T is any pointer type, then we run into the problem of the constructor doing a pointer assignment instead of making an actual deep copy of the element being pointed to. Because full template specialization forces us to fully resolve templated types, in order to fix this issue we\u2019d have to define a new specialized constructor (and destructor) for each and every pointer type we wanted to use Storage with! This leads to lots of duplicate code, which as you well know by now is something we want to avoid as much as possible. Fortunately, partial template specialization offers us a convenient solution. In this case, we\u2019ll use class partial template specialization to define a special version of the Storage class that works for pointer values. This class is considered partially specialized because we\u2019re telling the compiler that it\u2019s only for use with pointer types, even though we haven\u2019t specified the underlying type exactly. #include <iostream> // You need to include the Storage<T> class from the example above here template < typename T > class Storage < T *> // this is a partial-specialization of Storage that works with pointer types { private : T * m_value ; public : Storage ( T * value ) // for pointer type T { // For pointers, we'll do a deep copy m_value = new T ( * value ); // this copies a single value, not an array } ~ Storage () { delete m_value ; // so we use scalar delete here, not array delete } void print () { std :: cout << * m_value << '\\n' ; } }; And an example of this working: int main () { // Declare a non-pointer Storage to show it works Storage < int > myint ( 5 ); myint . print (); // Declare a pointer Storage to show it works int x = 7 ; Storage < int *> myintptr ( & x ); // If myintptr did a pointer assignment on x, // then changing x will change myintptr too x = 9 ; myintptr . print (); return 0 ; } This prints the value: 5 7 When myintptr is defined with an int* template parameter, the compiler sees that we have defined a partially specialized template class that works with any pointer type, and instantiates a version of Storage using that template. The constructor of that class makes a deep copy of parameter x. Later, when we change x to 9, the myintptr.m_value is not affected because it\u2019s pointing at its own separate copy of the value. If the partial template specialization class did not exist, myintptr would have used the normal (non-partially-specialized) version of the template. The constructor of that class does a shallow copy pointer assignment, which means that myintptr.m_value and x would be referencing the same address. Then when we changed the value of x to 9, we would have changed myintptr\u2019s value too. It\u2019s worth noting that because this partially specialized Storage class only allocates a single value, for C-style strings, only the first character will be copied. If the desire is to copy entire strings, a specialization of the constructor (and destructor) for type char*can be fully specialized. The fully specialized version will take precedence over the partially specialized version. Here\u2019s an example program that uses both partial specialization for pointers, and full specialization for char*: #include <iostream> #include <cstring> // Our Storage class for non-pointers template < class T > class Storage { private : T m_value ; public : Storage ( T value ) { m_value = value ; } ~ Storage () { } void print () { std :: cout << m_value << '\\n' ; } }; // Partial-specialization of Storage class for pointers template < class T > class Storage < T *> { private : T * m_value ; public : Storage ( T * value ) { m_value = new T ( * value ); } ~ Storage () { delete m_value ; } void print () { std :: cout << * m_value << '\\n' ; } }; // Full specialization of constructor for type char* template <> Storage < char *>:: Storage ( char * value ) { // Figure out how long the string in value is int length = 0 ; while ( value [ length ] != '\\0' ) ++ length ; ++ length ; // +1 to account for null terminator // Allocate memory to hold the value string m_value = new char [ length ]; // Copy the actual value string into the m_value memory we just allocated for ( int count = 0 ; count < length ; ++ count ) m_value [ count ] = value [ count ]; } // Full specialization of destructor for type char* template <> Storage < char *>::~ Storage () { delete [] m_value ; } // Full specialization of print function for type char* // Without this, printing a Storage<char*> would call Storage<T*>::print(), which only prints the first element template <> void Storage < char *>:: print () { std :: cout << m_value ; } int main () { // Declare a non-pointer Storage to show it works Storage < int > myint ( 5 ); myint . print (); // Declare a pointer Storage to show it works int x = 7 ; Storage < int *> myintptr ( & x ); // If myintptr did a pointer assignment on x, // then changing x will change myintptr too x = 9 ; myintptr . print (); // Dynamically allocate a temporary string char * name = new char [ 40 ]{ \"Alex\" }; // requires C++14 // If your compiler isn't C++14 compatible, comment out the above line and uncomment these // char *name = new char[40]; // strcpy(name, \"Alex\"); // Store the name Storage < char *> myname ( name ); // Delete the temporary string delete [] name ; // Print out our name myname . print (); } This works as we expect: 5 7 Alex Using partial template class specialization to create separate pointer and non-pointer implementations of a class is extremely useful when you want a class to handle both differently, but in a way that\u2019s completely transparent to the end-user.","title":"13.8 \u6307\u9488\u7684\u5c40\u90e8\u6a21\u677f\u7279\u5316"},{"location":"13-templates/13.8-partial-template-specialization-for-pointers/#138","text":"By Alex on December 5 th , 2016 | last modified by Alex on January 23 rd , 2020 In previous lesson 13.5 -- Function template specialization, we took a look at a simple templated Storage class: #include <iostream> template < class T > class Storage { private : T m_value ; public : Storage ( T value ) { m_value = value ; } ~ Storage () { } void print () { std :: cout << m_value << '\\n' ; } }; We showed that this class had problems when template parameter T was of type char*because of the shallow copy/pointer assignment that takes place in the constructor. In that lesson, we used full template specialization to create a specialized version of the Storage constructor for type char* that allocated memory and created an actual deep copy of m_value. For reference, here\u2019s the fully specialized char* Storage constructor and destructor: // You need to include the Storage<T> class from the example above here template <> Storage < char *>:: Storage ( char * value ) { // Figure out how long the string in value is int length = 0 ; while ( value [ length ] != '\\0' ) ++ length ; ++ length ; // +1 to account for null terminator // Allocate memory to hold the value string m_value = new char [ length ]; // Copy the actual value string into the m_value memory we just allocated for ( int count = 0 ; count < length ; ++ count ) m_value [ count ] = value [ count ]; } template <> Storage < char *>::~ Storage () { delete [] m_value ; } While that worked great for Storage , what about other pointer types (such as int*)? It\u2019s fairly easy to see that if T is any pointer type, then we run into the problem of the constructor doing a pointer assignment instead of making an actual deep copy of the element being pointed to. Because full template specialization forces us to fully resolve templated types, in order to fix this issue we\u2019d have to define a new specialized constructor (and destructor) for each and every pointer type we wanted to use Storage with! This leads to lots of duplicate code, which as you well know by now is something we want to avoid as much as possible. Fortunately, partial template specialization offers us a convenient solution. In this case, we\u2019ll use class partial template specialization to define a special version of the Storage class that works for pointer values. This class is considered partially specialized because we\u2019re telling the compiler that it\u2019s only for use with pointer types, even though we haven\u2019t specified the underlying type exactly. #include <iostream> // You need to include the Storage<T> class from the example above here template < typename T > class Storage < T *> // this is a partial-specialization of Storage that works with pointer types { private : T * m_value ; public : Storage ( T * value ) // for pointer type T { // For pointers, we'll do a deep copy m_value = new T ( * value ); // this copies a single value, not an array } ~ Storage () { delete m_value ; // so we use scalar delete here, not array delete } void print () { std :: cout << * m_value << '\\n' ; } }; And an example of this working: int main () { // Declare a non-pointer Storage to show it works Storage < int > myint ( 5 ); myint . print (); // Declare a pointer Storage to show it works int x = 7 ; Storage < int *> myintptr ( & x ); // If myintptr did a pointer assignment on x, // then changing x will change myintptr too x = 9 ; myintptr . print (); return 0 ; } This prints the value: 5 7 When myintptr is defined with an int* template parameter, the compiler sees that we have defined a partially specialized template class that works with any pointer type, and instantiates a version of Storage using that template. The constructor of that class makes a deep copy of parameter x. Later, when we change x to 9, the myintptr.m_value is not affected because it\u2019s pointing at its own separate copy of the value. If the partial template specialization class did not exist, myintptr would have used the normal (non-partially-specialized) version of the template. The constructor of that class does a shallow copy pointer assignment, which means that myintptr.m_value and x would be referencing the same address. Then when we changed the value of x to 9, we would have changed myintptr\u2019s value too. It\u2019s worth noting that because this partially specialized Storage class only allocates a single value, for C-style strings, only the first character will be copied. If the desire is to copy entire strings, a specialization of the constructor (and destructor) for type char*can be fully specialized. The fully specialized version will take precedence over the partially specialized version. Here\u2019s an example program that uses both partial specialization for pointers, and full specialization for char*: #include <iostream> #include <cstring> // Our Storage class for non-pointers template < class T > class Storage { private : T m_value ; public : Storage ( T value ) { m_value = value ; } ~ Storage () { } void print () { std :: cout << m_value << '\\n' ; } }; // Partial-specialization of Storage class for pointers template < class T > class Storage < T *> { private : T * m_value ; public : Storage ( T * value ) { m_value = new T ( * value ); } ~ Storage () { delete m_value ; } void print () { std :: cout << * m_value << '\\n' ; } }; // Full specialization of constructor for type char* template <> Storage < char *>:: Storage ( char * value ) { // Figure out how long the string in value is int length = 0 ; while ( value [ length ] != '\\0' ) ++ length ; ++ length ; // +1 to account for null terminator // Allocate memory to hold the value string m_value = new char [ length ]; // Copy the actual value string into the m_value memory we just allocated for ( int count = 0 ; count < length ; ++ count ) m_value [ count ] = value [ count ]; } // Full specialization of destructor for type char* template <> Storage < char *>::~ Storage () { delete [] m_value ; } // Full specialization of print function for type char* // Without this, printing a Storage<char*> would call Storage<T*>::print(), which only prints the first element template <> void Storage < char *>:: print () { std :: cout << m_value ; } int main () { // Declare a non-pointer Storage to show it works Storage < int > myint ( 5 ); myint . print (); // Declare a pointer Storage to show it works int x = 7 ; Storage < int *> myintptr ( & x ); // If myintptr did a pointer assignment on x, // then changing x will change myintptr too x = 9 ; myintptr . print (); // Dynamically allocate a temporary string char * name = new char [ 40 ]{ \"Alex\" }; // requires C++14 // If your compiler isn't C++14 compatible, comment out the above line and uncomment these // char *name = new char[40]; // strcpy(name, \"Alex\"); // Store the name Storage < char *> myname ( name ); // Delete the temporary string delete [] name ; // Print out our name myname . print (); } This works as we expect: 5 7 Alex Using partial template class specialization to create separate pointer and non-pointer implementations of a class is extremely useful when you want a class to handle both differently, but in a way that\u2019s completely transparent to the end-user.","title":"13.8 \u6307\u9488\u7684\u5c40\u90e8\u6a21\u677f\u7279\u5316"},{"location":"13-templates/13.x%20chapter-13-comprehensice-quiz/","text":"13.x \u5341\u4e09\u7ae0\u7406\u89e3\u548c\u7ec3\u4e60 \u00b6 By Alex on December 19 th , 2016 | last modified by Alex on January 23 rd , 2020 | \u7ffb\u8bd1by dashjay 7\u670811\u65e5 Templates allow us to write functions or classes using placeholder types, so that we can stencil out identical versions of the function or class using different types. A function or class that has been instantiated is called a function or class instance. All template functions or classes must start with a template parameter declaration that tells the compiler that the following function or class is a template function or class. Within the template parameter declaration, the template type parameters or expression parameters are specified. Template type parameters are just placeholder types, normally named T, T1, T2, or other single letter names (e.g. S). Expression parameters are usually integral types, but can be a pointer or reference to a function, class object, or member function. Splitting up template class definition and member function definitions doesn\u2019t work like normal classes -- you can\u2019t put your class definition in a header and member function definitions in a .cpp file. It\u2019s usually best to keep all of them in a header file, with the member function definitions underneath the class. Template specialization can be used when we want to override the default behavior from the templated function or class for a specific type. If all types are overridden, this is called full specialization. Classes also support partial specialization, where only some of the templated parameters are specialized. Functions do not support partial specialization as of C++14. Many classes in the C++ standard library use templates, including std::array and std::vector. Templates are often used for implementing container classes, so a container can be written once and used with any appropriate type. Quiz time 1) It\u2019s sometimes useful to define data that travels in pairs. Write a templated class named Pair1 that allows the user to define one template type that is used for both values in the pair. The following function should work: int main () { Pair1 < int > p1 ( 5 , 8 ); std :: cout << \"Pair: \" << p1 . first () << ' ' << p1 . second () << '\\n' ; const Pair1 < double > p2 ( 2.3 , 4.5 ); std :: cout << \"Pair: \" << p2 . first () << ' ' << p2 . second () << '\\n' ; return 0 ; } and print: Pair: 5 8 Pair: 2.3 4.5 Hide Solution #include <iostream> template < class T > class Pair1 { private : T m_x ; T m_y ; public : Pair1 ( const T & x , const T & y ) : m_x ( x ), m_y ( y ) { } const T & first () const { return m_x ; } const T & second () const { return m_y ; } }; int main () { Pair1 < int > p1 ( 5 , 8 ); std :: cout << \"Pair: \" << p1 . first () << ' ' << p1 . second () << '\\n' ; const Pair1 < double > p2 ( 2.3 , 4.5 ); std :: cout << \"Pair: \" << p2 . first () << ' ' << p2 . second () << '\\n' ; return 0 ; } 2) Write a Pair class that allows you to specify separate types for each of the two values in the pair. Note: We\u2019re naming this class differently from the previous one because C++ does not currently allow you to \u201coverload\u201d classes that differ only in the number or type of template parameters. The following program should work: int main () { Pair < int , double > p1 ( 5 , 6.7 ); std :: cout << \"Pair: \" << p1 . first () << ' ' << p1 . second () << '\\n' ; const Pair < double , int > p2 ( 2.3 , 4 ); std :: cout << \"Pair: \" << p2 . first () << ' ' << p2 . second () << '\\n' ; return 0 ; } and print: Pair: 5 6.7 Pair: 2.3 4 Hint: To define a template using two different types, separate the two types by a comma in the template parameter declaration. See lesson 13.1 -- Function templates for more information. #include <iostream> template < class T , class S > class Pair { private : T m_x ; S m_y ; public : Pair ( const T & x , const S & y ) : m_x ( x ), m_y ( y ) { } const T & first () const { return m_x ; } const S & second () const { return m_y ; } }; int main () { Pair < int , double > p1 ( 5 , 6.7 ); std :: cout << \"Pair: \" << p1 . first () << ' ' << p1 . second () << '\\n' ; const Pair < double , int > p2 ( 2.3 , 4 ); std :: cout << \"Pair: \" << p2 . first () << ' ' << p2 . second () << '\\n' ; return 0 ; } 3) A string-value pair is a special type of pair where the first value is always a string type, and the second value can be any type. Write a template class named StringValuePair that inherits from a partially specialized Pair class (using std::string as the first type, and allowing the user to specify the second type). The following program should run: int main () { StringValuePair < int > svp ( \"Hello\" , 5 ); std :: cout << \"Pair: \" << svp . first () << ' ' << svp . second () << '\\n' ; return 0 ; } and print: Pair: Hello 5 Hint: When you call the Pair constructor from the StringValuePair constructor, don\u2019t forget to include the template parameters as part of the Pair class name. Hide Solution #include <iostream> #include <string> template < class T , class S > class Pair { private : T m_x ; S m_y ; public : Pair ( const T & x , const S & y ) : m_x ( x ), m_y ( y ) { } const T & first () const { return m_x ; } const S & second () const { return m_y ; } }; template < class S > class StringValuePair : public Pair < std :: string , S > { public : StringValuePair ( const std :: string & key , const S & value ) : Pair < std :: string , S > ( key , value ) { } }; int main () { StringValuePair < int > svp ( \"Hello\" , 5 ); std :: cout << \"Pair: \" << svp . first () << ' ' << svp . second () << '\\n' ; return 0 ; }","title":"13.x \u5341\u4e09\u7ae0\u7406\u89e3\u548c\u7ec3\u4e60"},{"location":"13-templates/13.x%20chapter-13-comprehensice-quiz/#13x","text":"By Alex on December 19 th , 2016 | last modified by Alex on January 23 rd , 2020 | \u7ffb\u8bd1by dashjay 7\u670811\u65e5 Templates allow us to write functions or classes using placeholder types, so that we can stencil out identical versions of the function or class using different types. A function or class that has been instantiated is called a function or class instance. All template functions or classes must start with a template parameter declaration that tells the compiler that the following function or class is a template function or class. Within the template parameter declaration, the template type parameters or expression parameters are specified. Template type parameters are just placeholder types, normally named T, T1, T2, or other single letter names (e.g. S). Expression parameters are usually integral types, but can be a pointer or reference to a function, class object, or member function. Splitting up template class definition and member function definitions doesn\u2019t work like normal classes -- you can\u2019t put your class definition in a header and member function definitions in a .cpp file. It\u2019s usually best to keep all of them in a header file, with the member function definitions underneath the class. Template specialization can be used when we want to override the default behavior from the templated function or class for a specific type. If all types are overridden, this is called full specialization. Classes also support partial specialization, where only some of the templated parameters are specialized. Functions do not support partial specialization as of C++14. Many classes in the C++ standard library use templates, including std::array and std::vector. Templates are often used for implementing container classes, so a container can be written once and used with any appropriate type. Quiz time 1) It\u2019s sometimes useful to define data that travels in pairs. Write a templated class named Pair1 that allows the user to define one template type that is used for both values in the pair. The following function should work: int main () { Pair1 < int > p1 ( 5 , 8 ); std :: cout << \"Pair: \" << p1 . first () << ' ' << p1 . second () << '\\n' ; const Pair1 < double > p2 ( 2.3 , 4.5 ); std :: cout << \"Pair: \" << p2 . first () << ' ' << p2 . second () << '\\n' ; return 0 ; } and print: Pair: 5 8 Pair: 2.3 4.5 Hide Solution #include <iostream> template < class T > class Pair1 { private : T m_x ; T m_y ; public : Pair1 ( const T & x , const T & y ) : m_x ( x ), m_y ( y ) { } const T & first () const { return m_x ; } const T & second () const { return m_y ; } }; int main () { Pair1 < int > p1 ( 5 , 8 ); std :: cout << \"Pair: \" << p1 . first () << ' ' << p1 . second () << '\\n' ; const Pair1 < double > p2 ( 2.3 , 4.5 ); std :: cout << \"Pair: \" << p2 . first () << ' ' << p2 . second () << '\\n' ; return 0 ; } 2) Write a Pair class that allows you to specify separate types for each of the two values in the pair. Note: We\u2019re naming this class differently from the previous one because C++ does not currently allow you to \u201coverload\u201d classes that differ only in the number or type of template parameters. The following program should work: int main () { Pair < int , double > p1 ( 5 , 6.7 ); std :: cout << \"Pair: \" << p1 . first () << ' ' << p1 . second () << '\\n' ; const Pair < double , int > p2 ( 2.3 , 4 ); std :: cout << \"Pair: \" << p2 . first () << ' ' << p2 . second () << '\\n' ; return 0 ; } and print: Pair: 5 6.7 Pair: 2.3 4 Hint: To define a template using two different types, separate the two types by a comma in the template parameter declaration. See lesson 13.1 -- Function templates for more information. #include <iostream> template < class T , class S > class Pair { private : T m_x ; S m_y ; public : Pair ( const T & x , const S & y ) : m_x ( x ), m_y ( y ) { } const T & first () const { return m_x ; } const S & second () const { return m_y ; } }; int main () { Pair < int , double > p1 ( 5 , 6.7 ); std :: cout << \"Pair: \" << p1 . first () << ' ' << p1 . second () << '\\n' ; const Pair < double , int > p2 ( 2.3 , 4 ); std :: cout << \"Pair: \" << p2 . first () << ' ' << p2 . second () << '\\n' ; return 0 ; } 3) A string-value pair is a special type of pair where the first value is always a string type, and the second value can be any type. Write a template class named StringValuePair that inherits from a partially specialized Pair class (using std::string as the first type, and allowing the user to specify the second type). The following program should run: int main () { StringValuePair < int > svp ( \"Hello\" , 5 ); std :: cout << \"Pair: \" << svp . first () << ' ' << svp . second () << '\\n' ; return 0 ; } and print: Pair: Hello 5 Hint: When you call the Pair constructor from the StringValuePair constructor, don\u2019t forget to include the template parameters as part of the Pair class name. Hide Solution #include <iostream> #include <string> template < class T , class S > class Pair { private : T m_x ; S m_y ; public : Pair ( const T & x , const S & y ) : m_x ( x ), m_y ( y ) { } const T & first () const { return m_x ; } const S & second () const { return m_y ; } }; template < class S > class StringValuePair : public Pair < std :: string , S > { public : StringValuePair ( const std :: string & key , const S & value ) : Pair < std :: string , S > ( key , value ) { } }; int main () { StringValuePair < int > svp ( \"Hello\" , 5 ); std :: cout << \"Pair: \" << svp . first () << ' ' << svp . second () << '\\n' ; return 0 ; }","title":"13.x \u5341\u4e09\u7ae0\u7406\u89e3\u548c\u7ec3\u4e60"},{"location":"14-exceptions/","text":"14 \u5f02\u5e38 \u00b6 14.1 \u4e3a\u4ec0\u4e48\u9700\u8981\u5f02\u5e38 14.2 \u57fa\u672c\u5f02\u5e38\u5904\u7406 14.3 \u5f02\u5e38\uff0c\u51fd\u6570\uff0c\u6808\u5c55\u5f00 14.4 \u672a\u6355\u83b7\u5f02\u5e38\uff0c\u6355\u83b7\u5168\u90e8\u5f02\u5e38\u548c\u5f02\u5e38\u8bf4\u660e\u7b26 14.5 \u5f02\u5e38\uff0c\u7c7b\u548c\u7ee7\u627f 14.6 \u5f02\u5e38\u7684\u518d\u629b\u51fa 14.7 \u51fd\u6570\u7ea7\u7684 try \u4ee3\u7801\u5757 14.8 \u5f02\u5e38\u7684\u5371\u9669\u548c\u7f3a\u70b9","title":"14 \u5f02\u5e38"},{"location":"14-exceptions/#14","text":"14.1 \u4e3a\u4ec0\u4e48\u9700\u8981\u5f02\u5e38 14.2 \u57fa\u672c\u5f02\u5e38\u5904\u7406 14.3 \u5f02\u5e38\uff0c\u51fd\u6570\uff0c\u6808\u5c55\u5f00 14.4 \u672a\u6355\u83b7\u5f02\u5e38\uff0c\u6355\u83b7\u5168\u90e8\u5f02\u5e38\u548c\u5f02\u5e38\u8bf4\u660e\u7b26 14.5 \u5f02\u5e38\uff0c\u7c7b\u548c\u7ee7\u627f 14.6 \u5f02\u5e38\u7684\u518d\u629b\u51fa 14.7 \u51fd\u6570\u7ea7\u7684 try \u4ee3\u7801\u5757 14.8 \u5f02\u5e38\u7684\u5371\u9669\u548c\u7f3a\u70b9","title":"14 \u5f02\u5e38"},{"location":"14-exceptions/14.1-the-need-for-exceptions/","text":"14.1 \u4e3a\u4ec0\u4e48\u9700\u8981\u5f02\u5e38 \u00b6 By Alex on October 4 th , 2008 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.13 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6709\u5173\u9519\u8bef\u5904\u7406\u65f6\uff0c\u6211\u4eec\u8ba8\u8bba\u4e86\u5173\u4e8e\u4f7f\u7528 assert() \uff0c cerr() \u548c exit() \u6765\u5904\u7406\u9519\u8bef\u7684\u65b9\u6cd5\u3002\u90a3\u65f6\u6211\u4eec\u63d0\u5230\u4e86\u4e00\u4e2a\u5c06\u4f1a\u8bb2\u7684\u8bdd\u9898\uff0c\u7136\u540e\u6211\u4eec\u73b0\u5728\u5c31\u8981\u5f00\u59cb\u8bb2\uff1a \u5f02\u5e38 \u3002 \u5931\u8d25\u65f6\u8fd4\u56de\u72b6\u6001\u7801 \u00b6 \u5f53\u6211\u4eec\u7f16\u5199\u53ef\u590d\u7528\u7684\u4ee3\u7801\u65f6\uff0c\u9519\u8bef\u5904\u7406\u662f\u4e00\u4e2a\u5fc5\u9009\u9879\u3002\u6700\u5e38\u89c1\u7684\u5904\u7406\u9519\u8bef\u7684\u65b9\u5f0f\u4e4b\u4e00\u662f\u901a\u8fc7\u8fd4\u56de\u72b6\u6001\u7801\uff0c\u4f8b\u5982\uff1a int findFirstChar ( const char * string , char ch ) { const std :: size_t stringlength { strlen ( string ) }; // \u9010\u4e2a\u8c03\u8bd5\u6240\u6709\u5b57\u7b26\u4e32 for ( std :: size_t index = 0 ; index < stringlength ; ++ index ) // \u5982\u679c\u5339\u914d\u8fd4\u56de\u4e0b\u6807\u5bf9\u5e94\u7d22\u5f15... if ( string [ index ] == ch ) return index ; // \u5982\u679c\u6ca1\u6709\u5339\u914d\u4e0a\uff0c\u8fd4\u56de-1 return - 1 ; } \u8fd9\u4e2a\u51fd\u6570\u8fd4\u56de\u7b2c\u4e00\u4e2a\u9996\u5b57\u7b26\u5339\u914d\u7684\u5b57\u7b26\u4e32\u7d22\u5f15\uff0c\u5982\u679c\u5b57\u7b26\u6ca1\u6709\u88ab\u627e\u5230\uff0c\u51fd\u6570\u8fd4\u56de -1 \u7528\u4f5c\u9519\u8bef\u6307\u793a\u3002 \u8fd9\u4e2a\u57fa\u7840\u7684\u65b9\u6cd5\u662f\u76f8\u5f53\u7684\u7b80\u5355\uff0c\u7136\u800c\uff0c\u4f7f\u7528\u8fd4\u56de\u72b6\u6001\u7801\u6709\u4e00\u4e9b\u7f3a\u70b9\uff0c\u7136\u800c\u8fd9\u4e9b\u7f3a\u70b9\u53ef\u80fd\u5728\u4e00\u4e9b\u4f8b\u5b50\u4e2d\u53d8\u5f97\u5c24\u5176\u660e\u663e\uff1a \u7b2c\u4e00\uff1a \u8fd4\u56de\u503c\u542b\u4e49\u6a21\u7cca\u2014\u2014\u5982\u679c\u4e00\u4e2a\u51fd\u6570\u8fd4\u56de -1 \uff0c\u5b83\u5c1d\u8bd5\u8868\u660e\u4e00\u4e2a\u9519\u8bef\uff0c\u800c\u6216\u8005\u90a3\u5c31\u662f\u4e00\u4e2a\u6b63\u5e38\u7684\u8fd4\u56de\u503c\uff1f\u5982\u679c\u4e0d\u8fdb\u5165\u4e00\u4e2a\u51fd\u6570\u67e5\u770b\u5177\u4f53\u5b9e\u73b0\uff0c\u901a\u5e38\u5f88\u96be\u77e5\u9053\u3002 \u7b2c\u4e8c\uff1a \u51fd\u53ea\u80fd\u6709\u4e00\u4e2a\u8fd4\u56de\u503c\uff0c\u56e0\u6b64\u5982\u679c\u4f60\u9700\u8981\u540c\u65f6\u8fd4\u56de\u4e00\u4e2a\u51fd\u6570\u7ed3\u679c\u548c\u4e00\u4e2a\u9519\u8bef\u7801\uff0c\u601d\u8003\u4e0b\u9762\u7684\u51fd\u6570\uff1a double divide ( int x , int y ) { return static_cast < double > ( x ) / y ; } \u8fd9\u4e2a\u51fd\u6570\u80af\u5b9a\u9700\u8981\u4e00\u4e9b\u9519\u8bef\u5904\u7406\uff0c\u56e0\u4e3a\u5982\u679c\u7528\u6237\u4f20\u5165\u4e00\u4e2a 0 \u4f5c\u4e3a\u53d8\u91cf y \uff0c\u5b83\u5c06\u4f1a\u5d29\u6e83\u3002\u7136\u800c\uff0c\u5b83\u4e5f\u9700\u8981\u8fd4\u56de x/y \u7684\u7ed3\u679c\u3002\u5b83\u5982\u4f55\u624d\u80fd\u517c\u987e\uff1f\u6700\u5e38\u89c1\u7684\u7b54\u6848\u5c31\u662f\u5c06\u7ed3\u679c\u6216\u8005\u9519\u8bef\u5904\u7406\u503c\u4f20\u5165\u4f5c\u4e3a\u4e00\u4e2a\u5f15\u7528\u53d8\u91cf\u3002\u90a3\u6837\u7684\u4ee3\u7801\u770b\u8d77\u6765\u5f88\u7cdf\u7cd5\uff0c\u4e5f\u4e0d\u65b9\u4fbf\u4f7f\u7528\uff0c\u4f8b\u5982\uff1a #include <iostream> double divide ( int x , int y , bool & success ) { if ( y == 0 ) { success = false ; return 0.0 ; } success = true ; return static_cast < double > ( x ) / y ; } int main () { bool success ; // \u6211\u4eec\u5fc5\u987b\u4f20\u5165\u4e00\u4e2a bool \u6765\u770b\u51fd\u6570\u662f\u5426\u6267\u884c\u6210\u529f\u3002 double result = divide ( 5 , 3 , success ); if ( ! success ) // \u5728\u4f7f\u7528\u503c\u4e4b\u524d\u8981\u5148\u68c0\u67e5\u662f\u5426\u6210\u529f std :: cerr << \"An error occurred\" << std :: endl ; else cout << \"The answer is \" << result << '\\n' ; } \u7b2c\u4e09\uff1a \u5728\u4e00\u5806\u4ee3\u7801\u4e2d\u53ef\u80fd\u6709\u8bb8\u591a\u4e8b\u60c5\u53ef\u80fd\u4f1a\u62a5\u9519\uff0c\u9519\u8bef\u72b6\u6001\u7801\u4f1a\u88ab\u4e0d\u65ad\u7684\u68c0\u67e5\u3002 \u601d\u8003\u4e0b\u9762\u7684\u4ee3\u7801\u7247\u6bb5\uff0c\u8be5\u7247\u6bb5\u6d89\u53ca\u5230\u89e3\u6790\u4e00\u4e2a\u6587\u5b57\u6587\u4ef6\uff0c\u7528\u6765\u83b7\u53d6\u4e00\u4e9b\u5b58\u5728\u6587\u4ef6\u4e2d\u7684\u503c\uff1a std :: ifstream setupIni ( \"setup.ini\" ); // open setup.ini for reading // \u6253\u5f00 \u5e76\u8bfb\u53d6 setup.ini // If the file couldn't be opened (e.g. because it was missing) return some error enum // \u5982\u679c\u4e0d\u80fd\u88ab\u6253\u5f00\uff08\u4f8b\u5982\uff1a\u56e0\u4e3a\u5b83\u4e22\u5931\u4e86\uff09\uff0c\u8fd4\u56de\u4e86\u4e00\u4e9b\u9519\u8bef\u679a\u4e3e if ( ! setupIni ) return ERROR_OPENING_FILE ; // Now read a bunch of values from a file // \u73b0\u5728\u4ece\u6587\u4ef6\u4e2d\u8bfb\u51fa\u4e00\u5806\u503c if ( ! readIntegerFromFile ( setupIni , m_firstParameter )) // try to read an integer from the file // \u5c1d\u8bd5\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u4e00\u4e2a\u6574\u578b return ERROR_READING_VALUE ; // Return enum value indicating value couldn't be read // \u8fd4\u56de\u4e00\u4e2a\u679a\u4e3e\u503c\u8868\u793a\u503c\u4e0d\u80fd\u88ab\u8bfb\u53d6 if ( ! readDoubleFromFile ( setupIni , m_secondParameter )) // try to read a double from the file return ERROR_READING_VALUE ; if ( ! readFloatFromFile ( setupIni , m_thirdParameter )) // try to read a float from the file return ERROR_READING_VALUE ; \u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u4eec\u8fd8\u6ca1\u6709\u8bb2\u8fc7\u6587\u4ef6\u8bbf\u95ee\uff0c\u5982\u679c\u4f60\u4e0d\u77e5\u9053\u4e0a\u9762\u7684\u4ee3\u7801\u65f6\u5982\u4f55\u5de5\u4f5c\u7684\uff0c\u4e0d\u8981\u56e0\u6b64\u62c5\u5fc3\u3002 \u6ce8\u610f\u6bcf\u6b21\u90fd\u8c03\u7528\u9700\u8981\u4e00\u4e2a\u9519\u8bef\u68c0\u67e5\u5e76\u4e14\u8fd4\u56de\u7ed9\u8c03\u7528\u8005\u3002\u73b0\u5728\u60f3\u8c61\u5982\u679c\u670920\u4e2a\u4e0d\u540c\u7684\u7c7b\u578b\u2014\u2014\u4f60\u5c06\u68c0\u67e5\u4e00\u4e2a\u9519\u8bef\uff0c\u5e76\u4e14\u8fd4\u56de ERROR_READING_VALUE \u4e8c\u5341\u6b21\uff01\u6240\u6709\u8fd9\u4e9b\u4e0d\u540c\u7684\u9519\u8bef\u68c0\u67e5\u548c\u8fd4\u56de\u503c\u4f7f\u5f97\u786e\u5b9a\u51fd\u6570\u8981\u505a\u7684\u4e8b\u60c5\u53d8\u5f97\u66f4\u52a0\u96be\u4ee5\u8bc6\u522b\u3002 \uff08All of this error checking and returning values makes determining what the function is trying to do much harder to discern.\uff09 \u7b2c\u56db\uff1a \u8fd4\u56de\u9519\u8bef\u7801\u4e0d\u80fd\u548c\u6784\u9020\u51fd\u6570\u5f88\u597d\u7684\u642d\u914d\u3002\u5982\u679c\u4f60\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u65f6\u6784\u9020\u51fd\u6570\u53d1\u751f\u4e0d\u53ef\u6062\u590d\u7684\u9519\u8bef\uff0c\u5c06\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u6784\u9020\u51fd\u6570\u6ca1\u6709\u8fd4\u56de\u503c\u4f20\u56de\u4e00\u4e2a\u72b6\u6001\u6307\u793a\uff0c\u6216\u8bb8\u4f60\u53ef\u4ee5\u901a\u8fc7\u4f20\u5165\u5f15\u7528\u6765\u4f20\u56de\u4e00\u4e2a\u72b6\u6001\u7801\uff0c\u4f46\u8fd9\u6837\u4f1a\u5f88\u6df7\u4e71\uff0c\u5e76\u4e14\u5fc5\u987b\u88ab\u663e\u5f0f\u7684\u68c0\u67e5\u3002\u6b64\u5916\uff0c\u5373\u4fbf\u4f60\u8fd9\u6837\u505a\u4e86\uff0c\u5bf9\u8c61\u4ecd\u7136\u4f1a\u88ab\u521b\u5efa\u5e76\u4e14\u7d27\u63a5\u4e0d\u5f97\u4e0d\u88ab\u5904\u7406 \uff08 the object will still be created and then has to be dealt with or disposed of.\uff09 \u3002 \u6700\u540e\uff1a \u5f53\u4e00\u4e2a\u9519\u8bef\u7801\u8fd4\u56de\u7ed9\u8c03\u7528\u8005\uff0c\u8c03\u7528\u8005\u53ef\u80fd\u4e0d\u5177\u6709\u5904\u7406\u8fd9\u4e2a\u9519\u8bef\u7684\u80fd\u529b\u3002\u5982\u679c\u8c03\u7528\u8005\u4e0d\u80fd\u6216\u8005\u4e0d\u60f3\u5904\u7406\u8fd9\u4e2a\u9519\u8bef\uff0c\u8c03\u7528\u8005\u53ef\u4ee5\u5ffd\u7565\u9519\u8bef\uff08\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u9519\u8bef\u5c06\u4f1a\u6c38\u8fdc\u4e22\u5931\uff09\uff0c\u6216\u8005\u8fd4\u56de\u51fa\u9519\u8bef\u5230\u8c03\u7528\u8be5\u51fd\u6570\u7684\u51fd\u6570\u3002\u8fd9\u53ef\u80fd\u5f88\u4e71\u5e76\u4e14\u5f15\u8d77\u5f88\u591a\u4ee5\u4e0a\u63d0\u5230\u7684\u540c\u6837\u7684\u95ee\u9898\u3002 \u603b\u7684\u6765\u8bf4\uff0c\u8fd4\u56de\u72b6\u6001\u7801\u7684\u57fa\u672c\u95ee\u9898\u5c31\u662f\u9519\u8bef\u7801\u9519\u7efc\u590d\u6742\u7684\u548c\u4ee3\u7801\u4e2d\u7684\u5e38\u89c4\u63a7\u5236\u6d41\u6df7\u5408\u5728\u4e00\u8d77\u3002\u8fd9\u4e9b\u6700\u7ec8\u53cd\u8fc7\u6765\u4e0d\u4ec5\u9650\u5236\u4e86\u4ee3\u7801\u5982\u4f55\u7f16\u5199\uff0c\u540c\u65f6\u8fd8\u9650\u5236\u4e86\u9519\u8bef\u5982\u4f55\u80fd\u88ab\u5408\u7406\u7684\u5904\u7406\u3002 \u5f02\u5e38 \u00b6 \u5f02\u5e38\u5904\u7406\u63d0\u4f9b\u4e86\u4e00\u4e2a\u673a\u5236\uff0c\u5c06\u5904\u7406\u9519\u8bef\u4e0e\u4f60\u4ee3\u7801\u91cc\u5e38\u89c4\u63a7\u5236\u6d41\u4e2d\u51fa\u73b0\u7684\u5f02\u5e38\u60c5\u51b5\u89e3\u8026\u3002\u8fd9\u53ef\u4ee5\u7ed9\u6211\u4eec\u66f4\u591a\u7684\u81ea\u7531\u6765\u51b3\u5b9a\u5728\u5f53\u524d\u60c5\u51b5\u4e0b\uff0c\u4f55\u65f6\u6216\u8005\u5982\u4f55\u5904\u7406\u9519\u8bef\uff0c\u51cf\u8f7b\u4e86\u8bb8\u591a\uff08\u6216\u8bb8\u4e0d\u662f\u6240\u6709\uff09\u8fd4\u56de\u9519\u8bef\u7801\u65f6\u7684\u6df7\u4e71\u3002 In the next lesson, we\u2019ll take a look at how exceptions work in C++. \u5728\u63a5\u4e0b\u6765\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u5c06\u770b\u770b\u5f02\u5e38\u5728C++\u4e2d\u662f\u5982\u4f55\u5de5\u4f5c\u7684\u3002","title":"14.1 \u4e3a\u4ec0\u4e48\u9700\u8981\u5f02\u5e38"},{"location":"14-exceptions/14.1-the-need-for-exceptions/#141","text":"By Alex on October 4 th , 2008 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.13 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6709\u5173\u9519\u8bef\u5904\u7406\u65f6\uff0c\u6211\u4eec\u8ba8\u8bba\u4e86\u5173\u4e8e\u4f7f\u7528 assert() \uff0c cerr() \u548c exit() \u6765\u5904\u7406\u9519\u8bef\u7684\u65b9\u6cd5\u3002\u90a3\u65f6\u6211\u4eec\u63d0\u5230\u4e86\u4e00\u4e2a\u5c06\u4f1a\u8bb2\u7684\u8bdd\u9898\uff0c\u7136\u540e\u6211\u4eec\u73b0\u5728\u5c31\u8981\u5f00\u59cb\u8bb2\uff1a \u5f02\u5e38 \u3002","title":"14.1 \u4e3a\u4ec0\u4e48\u9700\u8981\u5f02\u5e38"},{"location":"14-exceptions/14.1-the-need-for-exceptions/#_1","text":"\u5f53\u6211\u4eec\u7f16\u5199\u53ef\u590d\u7528\u7684\u4ee3\u7801\u65f6\uff0c\u9519\u8bef\u5904\u7406\u662f\u4e00\u4e2a\u5fc5\u9009\u9879\u3002\u6700\u5e38\u89c1\u7684\u5904\u7406\u9519\u8bef\u7684\u65b9\u5f0f\u4e4b\u4e00\u662f\u901a\u8fc7\u8fd4\u56de\u72b6\u6001\u7801\uff0c\u4f8b\u5982\uff1a int findFirstChar ( const char * string , char ch ) { const std :: size_t stringlength { strlen ( string ) }; // \u9010\u4e2a\u8c03\u8bd5\u6240\u6709\u5b57\u7b26\u4e32 for ( std :: size_t index = 0 ; index < stringlength ; ++ index ) // \u5982\u679c\u5339\u914d\u8fd4\u56de\u4e0b\u6807\u5bf9\u5e94\u7d22\u5f15... if ( string [ index ] == ch ) return index ; // \u5982\u679c\u6ca1\u6709\u5339\u914d\u4e0a\uff0c\u8fd4\u56de-1 return - 1 ; } \u8fd9\u4e2a\u51fd\u6570\u8fd4\u56de\u7b2c\u4e00\u4e2a\u9996\u5b57\u7b26\u5339\u914d\u7684\u5b57\u7b26\u4e32\u7d22\u5f15\uff0c\u5982\u679c\u5b57\u7b26\u6ca1\u6709\u88ab\u627e\u5230\uff0c\u51fd\u6570\u8fd4\u56de -1 \u7528\u4f5c\u9519\u8bef\u6307\u793a\u3002 \u8fd9\u4e2a\u57fa\u7840\u7684\u65b9\u6cd5\u662f\u76f8\u5f53\u7684\u7b80\u5355\uff0c\u7136\u800c\uff0c\u4f7f\u7528\u8fd4\u56de\u72b6\u6001\u7801\u6709\u4e00\u4e9b\u7f3a\u70b9\uff0c\u7136\u800c\u8fd9\u4e9b\u7f3a\u70b9\u53ef\u80fd\u5728\u4e00\u4e9b\u4f8b\u5b50\u4e2d\u53d8\u5f97\u5c24\u5176\u660e\u663e\uff1a \u7b2c\u4e00\uff1a \u8fd4\u56de\u503c\u542b\u4e49\u6a21\u7cca\u2014\u2014\u5982\u679c\u4e00\u4e2a\u51fd\u6570\u8fd4\u56de -1 \uff0c\u5b83\u5c1d\u8bd5\u8868\u660e\u4e00\u4e2a\u9519\u8bef\uff0c\u800c\u6216\u8005\u90a3\u5c31\u662f\u4e00\u4e2a\u6b63\u5e38\u7684\u8fd4\u56de\u503c\uff1f\u5982\u679c\u4e0d\u8fdb\u5165\u4e00\u4e2a\u51fd\u6570\u67e5\u770b\u5177\u4f53\u5b9e\u73b0\uff0c\u901a\u5e38\u5f88\u96be\u77e5\u9053\u3002 \u7b2c\u4e8c\uff1a \u51fd\u53ea\u80fd\u6709\u4e00\u4e2a\u8fd4\u56de\u503c\uff0c\u56e0\u6b64\u5982\u679c\u4f60\u9700\u8981\u540c\u65f6\u8fd4\u56de\u4e00\u4e2a\u51fd\u6570\u7ed3\u679c\u548c\u4e00\u4e2a\u9519\u8bef\u7801\uff0c\u601d\u8003\u4e0b\u9762\u7684\u51fd\u6570\uff1a double divide ( int x , int y ) { return static_cast < double > ( x ) / y ; } \u8fd9\u4e2a\u51fd\u6570\u80af\u5b9a\u9700\u8981\u4e00\u4e9b\u9519\u8bef\u5904\u7406\uff0c\u56e0\u4e3a\u5982\u679c\u7528\u6237\u4f20\u5165\u4e00\u4e2a 0 \u4f5c\u4e3a\u53d8\u91cf y \uff0c\u5b83\u5c06\u4f1a\u5d29\u6e83\u3002\u7136\u800c\uff0c\u5b83\u4e5f\u9700\u8981\u8fd4\u56de x/y \u7684\u7ed3\u679c\u3002\u5b83\u5982\u4f55\u624d\u80fd\u517c\u987e\uff1f\u6700\u5e38\u89c1\u7684\u7b54\u6848\u5c31\u662f\u5c06\u7ed3\u679c\u6216\u8005\u9519\u8bef\u5904\u7406\u503c\u4f20\u5165\u4f5c\u4e3a\u4e00\u4e2a\u5f15\u7528\u53d8\u91cf\u3002\u90a3\u6837\u7684\u4ee3\u7801\u770b\u8d77\u6765\u5f88\u7cdf\u7cd5\uff0c\u4e5f\u4e0d\u65b9\u4fbf\u4f7f\u7528\uff0c\u4f8b\u5982\uff1a #include <iostream> double divide ( int x , int y , bool & success ) { if ( y == 0 ) { success = false ; return 0.0 ; } success = true ; return static_cast < double > ( x ) / y ; } int main () { bool success ; // \u6211\u4eec\u5fc5\u987b\u4f20\u5165\u4e00\u4e2a bool \u6765\u770b\u51fd\u6570\u662f\u5426\u6267\u884c\u6210\u529f\u3002 double result = divide ( 5 , 3 , success ); if ( ! success ) // \u5728\u4f7f\u7528\u503c\u4e4b\u524d\u8981\u5148\u68c0\u67e5\u662f\u5426\u6210\u529f std :: cerr << \"An error occurred\" << std :: endl ; else cout << \"The answer is \" << result << '\\n' ; } \u7b2c\u4e09\uff1a \u5728\u4e00\u5806\u4ee3\u7801\u4e2d\u53ef\u80fd\u6709\u8bb8\u591a\u4e8b\u60c5\u53ef\u80fd\u4f1a\u62a5\u9519\uff0c\u9519\u8bef\u72b6\u6001\u7801\u4f1a\u88ab\u4e0d\u65ad\u7684\u68c0\u67e5\u3002 \u601d\u8003\u4e0b\u9762\u7684\u4ee3\u7801\u7247\u6bb5\uff0c\u8be5\u7247\u6bb5\u6d89\u53ca\u5230\u89e3\u6790\u4e00\u4e2a\u6587\u5b57\u6587\u4ef6\uff0c\u7528\u6765\u83b7\u53d6\u4e00\u4e9b\u5b58\u5728\u6587\u4ef6\u4e2d\u7684\u503c\uff1a std :: ifstream setupIni ( \"setup.ini\" ); // open setup.ini for reading // \u6253\u5f00 \u5e76\u8bfb\u53d6 setup.ini // If the file couldn't be opened (e.g. because it was missing) return some error enum // \u5982\u679c\u4e0d\u80fd\u88ab\u6253\u5f00\uff08\u4f8b\u5982\uff1a\u56e0\u4e3a\u5b83\u4e22\u5931\u4e86\uff09\uff0c\u8fd4\u56de\u4e86\u4e00\u4e9b\u9519\u8bef\u679a\u4e3e if ( ! setupIni ) return ERROR_OPENING_FILE ; // Now read a bunch of values from a file // \u73b0\u5728\u4ece\u6587\u4ef6\u4e2d\u8bfb\u51fa\u4e00\u5806\u503c if ( ! readIntegerFromFile ( setupIni , m_firstParameter )) // try to read an integer from the file // \u5c1d\u8bd5\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u4e00\u4e2a\u6574\u578b return ERROR_READING_VALUE ; // Return enum value indicating value couldn't be read // \u8fd4\u56de\u4e00\u4e2a\u679a\u4e3e\u503c\u8868\u793a\u503c\u4e0d\u80fd\u88ab\u8bfb\u53d6 if ( ! readDoubleFromFile ( setupIni , m_secondParameter )) // try to read a double from the file return ERROR_READING_VALUE ; if ( ! readFloatFromFile ( setupIni , m_thirdParameter )) // try to read a float from the file return ERROR_READING_VALUE ; \u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u4eec\u8fd8\u6ca1\u6709\u8bb2\u8fc7\u6587\u4ef6\u8bbf\u95ee\uff0c\u5982\u679c\u4f60\u4e0d\u77e5\u9053\u4e0a\u9762\u7684\u4ee3\u7801\u65f6\u5982\u4f55\u5de5\u4f5c\u7684\uff0c\u4e0d\u8981\u56e0\u6b64\u62c5\u5fc3\u3002 \u6ce8\u610f\u6bcf\u6b21\u90fd\u8c03\u7528\u9700\u8981\u4e00\u4e2a\u9519\u8bef\u68c0\u67e5\u5e76\u4e14\u8fd4\u56de\u7ed9\u8c03\u7528\u8005\u3002\u73b0\u5728\u60f3\u8c61\u5982\u679c\u670920\u4e2a\u4e0d\u540c\u7684\u7c7b\u578b\u2014\u2014\u4f60\u5c06\u68c0\u67e5\u4e00\u4e2a\u9519\u8bef\uff0c\u5e76\u4e14\u8fd4\u56de ERROR_READING_VALUE \u4e8c\u5341\u6b21\uff01\u6240\u6709\u8fd9\u4e9b\u4e0d\u540c\u7684\u9519\u8bef\u68c0\u67e5\u548c\u8fd4\u56de\u503c\u4f7f\u5f97\u786e\u5b9a\u51fd\u6570\u8981\u505a\u7684\u4e8b\u60c5\u53d8\u5f97\u66f4\u52a0\u96be\u4ee5\u8bc6\u522b\u3002 \uff08All of this error checking and returning values makes determining what the function is trying to do much harder to discern.\uff09 \u7b2c\u56db\uff1a \u8fd4\u56de\u9519\u8bef\u7801\u4e0d\u80fd\u548c\u6784\u9020\u51fd\u6570\u5f88\u597d\u7684\u642d\u914d\u3002\u5982\u679c\u4f60\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u65f6\u6784\u9020\u51fd\u6570\u53d1\u751f\u4e0d\u53ef\u6062\u590d\u7684\u9519\u8bef\uff0c\u5c06\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u6784\u9020\u51fd\u6570\u6ca1\u6709\u8fd4\u56de\u503c\u4f20\u56de\u4e00\u4e2a\u72b6\u6001\u6307\u793a\uff0c\u6216\u8bb8\u4f60\u53ef\u4ee5\u901a\u8fc7\u4f20\u5165\u5f15\u7528\u6765\u4f20\u56de\u4e00\u4e2a\u72b6\u6001\u7801\uff0c\u4f46\u8fd9\u6837\u4f1a\u5f88\u6df7\u4e71\uff0c\u5e76\u4e14\u5fc5\u987b\u88ab\u663e\u5f0f\u7684\u68c0\u67e5\u3002\u6b64\u5916\uff0c\u5373\u4fbf\u4f60\u8fd9\u6837\u505a\u4e86\uff0c\u5bf9\u8c61\u4ecd\u7136\u4f1a\u88ab\u521b\u5efa\u5e76\u4e14\u7d27\u63a5\u4e0d\u5f97\u4e0d\u88ab\u5904\u7406 \uff08 the object will still be created and then has to be dealt with or disposed of.\uff09 \u3002 \u6700\u540e\uff1a \u5f53\u4e00\u4e2a\u9519\u8bef\u7801\u8fd4\u56de\u7ed9\u8c03\u7528\u8005\uff0c\u8c03\u7528\u8005\u53ef\u80fd\u4e0d\u5177\u6709\u5904\u7406\u8fd9\u4e2a\u9519\u8bef\u7684\u80fd\u529b\u3002\u5982\u679c\u8c03\u7528\u8005\u4e0d\u80fd\u6216\u8005\u4e0d\u60f3\u5904\u7406\u8fd9\u4e2a\u9519\u8bef\uff0c\u8c03\u7528\u8005\u53ef\u4ee5\u5ffd\u7565\u9519\u8bef\uff08\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u9519\u8bef\u5c06\u4f1a\u6c38\u8fdc\u4e22\u5931\uff09\uff0c\u6216\u8005\u8fd4\u56de\u51fa\u9519\u8bef\u5230\u8c03\u7528\u8be5\u51fd\u6570\u7684\u51fd\u6570\u3002\u8fd9\u53ef\u80fd\u5f88\u4e71\u5e76\u4e14\u5f15\u8d77\u5f88\u591a\u4ee5\u4e0a\u63d0\u5230\u7684\u540c\u6837\u7684\u95ee\u9898\u3002 \u603b\u7684\u6765\u8bf4\uff0c\u8fd4\u56de\u72b6\u6001\u7801\u7684\u57fa\u672c\u95ee\u9898\u5c31\u662f\u9519\u8bef\u7801\u9519\u7efc\u590d\u6742\u7684\u548c\u4ee3\u7801\u4e2d\u7684\u5e38\u89c4\u63a7\u5236\u6d41\u6df7\u5408\u5728\u4e00\u8d77\u3002\u8fd9\u4e9b\u6700\u7ec8\u53cd\u8fc7\u6765\u4e0d\u4ec5\u9650\u5236\u4e86\u4ee3\u7801\u5982\u4f55\u7f16\u5199\uff0c\u540c\u65f6\u8fd8\u9650\u5236\u4e86\u9519\u8bef\u5982\u4f55\u80fd\u88ab\u5408\u7406\u7684\u5904\u7406\u3002","title":"\u5931\u8d25\u65f6\u8fd4\u56de\u72b6\u6001\u7801"},{"location":"14-exceptions/14.1-the-need-for-exceptions/#_2","text":"\u5f02\u5e38\u5904\u7406\u63d0\u4f9b\u4e86\u4e00\u4e2a\u673a\u5236\uff0c\u5c06\u5904\u7406\u9519\u8bef\u4e0e\u4f60\u4ee3\u7801\u91cc\u5e38\u89c4\u63a7\u5236\u6d41\u4e2d\u51fa\u73b0\u7684\u5f02\u5e38\u60c5\u51b5\u89e3\u8026\u3002\u8fd9\u53ef\u4ee5\u7ed9\u6211\u4eec\u66f4\u591a\u7684\u81ea\u7531\u6765\u51b3\u5b9a\u5728\u5f53\u524d\u60c5\u51b5\u4e0b\uff0c\u4f55\u65f6\u6216\u8005\u5982\u4f55\u5904\u7406\u9519\u8bef\uff0c\u51cf\u8f7b\u4e86\u8bb8\u591a\uff08\u6216\u8bb8\u4e0d\u662f\u6240\u6709\uff09\u8fd4\u56de\u9519\u8bef\u7801\u65f6\u7684\u6df7\u4e71\u3002 In the next lesson, we\u2019ll take a look at how exceptions work in C++. \u5728\u63a5\u4e0b\u6765\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u5c06\u770b\u770b\u5f02\u5e38\u5728C++\u4e2d\u662f\u5982\u4f55\u5de5\u4f5c\u7684\u3002","title":"\u5f02\u5e38"},{"location":"14-exceptions/14.2-basic-exception-handloing/","text":"14.2 \u57fa\u672c\u5f02\u5e38\u5904\u7406 \u00b6 By Alex on October 4 th , 2008 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.13 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b \u4e3a\u4ec0\u4e48\u9700\u8981\u5f02\u5e38 \u4e2d\uff0c\u6211\u4eec\u8ba8\u8bba\u4e86\u5173\u4e8e\u4f7f\u7528\u8fd4\u56de\u503c\u72b6\u6001\u7801\u4e3a\u4f55\u4f1a\u4f7f\u5f97\u4f60\u7684\u63a7\u5236\u6d41\u548c\u9519\u8bef\u5904\u7406\u88ab\u6df7\u5408\uff0c\u4f7f\u5f97\u4e24\u8005\u76f8\u4e92\u7ea6\u675f\u3002\u5f02\u5e38\u5728C++\u4e2d\u7684\u5b9e\u73b0\u4f7f\u7528\u4e86\u4e09\u4e2a\u5173\u952e\u8bcd\uff0c\u6765\u76f8\u4e92\u8fde\u63a5\uff1a throw , try , catch \u3002 \u629b\u51fa\u5f02\u5e38 \u00b6 \u5728\u73b0\u5b9e\u751f\u6d3b\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u4fe1\u53f7\u6765\u8bb0\u5f55\u5df2\u7ecf\u53d1\u751f\u7684\u7279\u5b9a\u7684\u4e8b\u60c5\u3002\u4f8b\u5982\u5728\u7f8e\u56fd\u8db3\u7403\u6bd4\u8d5b\u4e2d\uff0c\u5982\u679c\u4e00\u4e2a\u8fd0\u52a8\u5458\u72af\u89c4\u4e86\uff0c\u88c1\u5224\u5c06\u4f1a\u62ff\u51fa\u4e00\u4e2aflag\u5e76\u4e14\u5439\u54e8\u8868\u793a\u6e38\u620f\u6682\u505c\u3002\u60e9\u7f5a\u5c31\u662f\u7d27\u63a5\u7740\u8bc4\u4f30\u548c\u6267\u884c\u3002\u60e9\u7f5a\u88ab\u6267\u884c\u540e\uff0c\u6e38\u620f\u7167\u65e7\u7ee7\u7eed\u3002 \u5728 C++ \u4e2d\uff0c\u4e00\u4e2a\u629b\u51fa\u8bed\u53e5\u88ab\u7528\u6765\u53d1\u9001\u4e00\u4e2a\u4fe1\u53f7\u8868\u793a\u4e00\u4e2a\u5f02\u5e38\u6216\u8005\u9519\u8bef\u5df2\u7ecf\u53d1\u751f\uff08\u53ef\u4ee5\u8ba4\u4e3a\u662f\u629b\u51fa\u4e86\u4e00\u4e2a\u60e9\u7f5a\u7684flag\uff09\u3002\u53d1\u51fa\u4fe1\u53f7\u8868\u793a\u4e00\u4e2a\u5f02\u5e38\u5df2\u7ecf\u53d1\u751f\uff0c\u8005\u901a\u5e38\u88ab\u53eb\u505a\u629b\u51fa\u4e00\u4e2a\u5f02\u5e38\u3002 \u4e3a\u4e86\u4f7f\u7528\u4e00\u4e2a\u5f02\u5e38\u4e00\u53e5\uff0c\u7b80\u5355\u7684\u4f7f\u7528 throw \u5173\u952e\u8bcd\uff0c\u7d27\u8ddf\u7740\u4e00\u4e2a\u4f60\u5e0c\u671b\u4f7f\u7528\u7684\u4efb\u4f55\u7c7b\u578b\u7684\u503c\u6765\u901a\u77e5\u4e00\u4e2a\u9519\u8bef\u5df2\u7ecf\u53d1\u751f\uff0c\u901a\u5e38\u8fd9\u548c\u503c\u5c06\u4f1a\u662f\u4e00\u4e2a\u9519\u8bef\u7801\uff0c\u4e00\u4e2a\u95ee\u9898\u7684\u63cf\u8ff0\uff0c\u6216\u8005\u4e00\u4e2a\u81ea\u5b9a\u4e49\u5f02\u5e38\u7c7b\u3002 \u8fd9\u91cc\u662f\u4e00\u4e9b\u4f8b\u5b50\uff1a throw - 1 ; // throw a literal integer value throw ENUM_INVALID_INDEX ; // throw an enum value throw \"Can not take square root of negative number\" ; // throw a literal C-style (const char*) string throw dX ; // throw a double variable that was previously defined throw MyException ( \"Fatal Error\" ); // Throw an object of class MyException \u8fd9\u91cc\u7684\u6bcf\u4e00\u4e2a\u8bed\u53e5\u90fd\u5f53\u505a\u4e00\u4e2a\u4fe1\u53f7\uff0c\u8868\u793a\u67d0\u79cd\u7c7b\u578b\u7684\u9700\u8981\u88ab\u89e3\u51b3\u7684\u95ee\u9898\u5df2\u7ecf\u53d1\u751f\u4e86\u3002 \u5bfb\u627e\u5f02\u5e38 \u00b6 \u629b\u51fa\u5f02\u5e38\u53ea\u662f\u5f02\u5e38\u5904\u7406\u8fdb\u7a0b\u7684\u4e00\u90e8\u5206\u3002\u8ba9\u6211\u4eec\u56de\u5230\u7f8e\u56fd\u8db3\u7403\u7684\u6bd4\u55bb\u4e2d\uff1a\u4e00\u65e6\u88c1\u5224\u629b\u51fa\u4e00\u4e2a\u4e00\u4e2a\u60e9\u7f5aflag\uff0c\u63a5\u4e0b\u6765\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u53c2\u8d5b\u8005\u4eec\u4e3b\u8981\u5230\u4e00\u4e2a\u60e9\u7f5a\u53d1\u751f\uff0c\u5e76\u4e14\u505c\u6b62\u6e38\u620f\u3002\u4e00\u4e2a\u666e\u901a\u7684\u8db3\u7403\u6bd4\u8d5b\u6d41\u7a0b\u4e2d\u65ad\u3002 \u5728C++\u4e2d\uff0c\u6211\u4eec\u7528 try \u5173\u952e\u8bcd\u6765\u5b9a\u4e49\u4e00\u4e2a\u8bed\u53e5\u5757\uff08\u88ab\u53eb\u505a try \u8bed\u53e5\u5757\uff09\uff0ctry \u8bed\u53e5\u5757\u4f5c\u4e3a\u4e00\u4e2a\u89c2\u5bdf\u8005\uff0c\u5bfb\u627e\u4efb\u4f55\u7c7b\u578b\u88ab\u629b\u51fa\u7684\u5f02\u5e38\u5728 try \u8bed\u53e5\u7684block\u4e2d\u3002 Here\u2019s an example of a try block: try { // Statements that may throw exceptions you want to handle go here // \u5230\u90a3\u513f\uff0c\u53ef\u80fd\u629b\u51fa\u4f60\u9700\u8981\u5904\u7406\u7684\u5f02\u5e38\u7684\u8bed\u53e5\u3002 throw - 1 ; // here's a trivial throw statement // \u4e00\u4e2a\u5e38\u8bc6\u629b\u51fa\u7684\u8bed\u53e5 } \u6ce8\u610f\uff0ctry \u8bed\u53e5\u5757\u6ca1\u6709\u5b9a\u4e49\u5982\u4f55\u5904\u7406\u5f02\u5e38\u3002\u4ed6\u4ec5\u4ec5\u544a\u8bc9\u7a0b\u5e8f\uff0c\u201c\u563f\uff0c\u5982\u679c\u4efb\u4f55\u8bed\u53e5\u5728\u8fd9\u4e2a try \u8bed\u53e5\u5757\u4e2d\u629b\u51fa\uff0c\u6293\u4f4f\u5b83\uff01\u201d\u3002 \u5f02\u5e38\u5904\u7406 \u00b6 \u6700\u540e\uff0c\u7f8e\u56fd\u8db3\u7403\u7684\u6bd4\u55bb\uff1a\u5728\u60e9\u7f5a\u88ab\u8c03\u7528\uff0c\u6e38\u620f\u5df2\u7ecf\u505c\u6b62\uff0c\u88c1\u5224\u8bc4\u4f30\u60e9\u7f5a\u5e76\u4e14\u6267\u884c\u5b83\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u60e9\u7f5a\u5fc5\u987b\u88ab\u5904\u7406\u5728\u7ee7\u7eed\u6e38\u620f\u4e4b\u524d\u3002 \u4e8b\u5b9e\u4e0a\uff0c\u5f02\u5e38\u5904\u7406\u662f catch \u8bed\u53e5\u5757\u7684\u5de5\u4f5c\u3002 catch \u5173\u952e\u8bcd\u88ab\u7528\u6765\u5b9a\u4e49\u4e00\u4e2a\u8bed\u53e5\u5757\uff08\u88ab\u53eb\u505a catch \u8bed\u53e5\u5757\uff09\u5904\u7406\u5355\u4e2a\u6570\u636e\u7c7b\u578b\u7684\u7684\u5f02\u5e38\u3002 \u8fd9\u6709\u4e00\u4e2a catch \u8bed\u53e5\u5757\u7684\u4f8b\u5b50\uff0c\u5b83\u4f1a\u6355\u83b7\u4e00\u4e2a\u6574\u578b\u5f02\u5e38\uff1a catch ( int x ) { // Handle an exception of type int here // \u5904\u7406\u4e00\u4e2a\u6574\u578b\u7684\u5f02\u5e38 std :: cerr << \"We caught an int exception with value\" << x << '\\n' ; } try \u8bed\u53e5\u5757\u548c catch \u8bed\u53e5\u5757\u4e00\u8d77\u5de5\u4f5c\u2014\u2014 \u4e00\u4e2a try \u8bed\u53e5\u5757\u68c0\u6d4b try \u8bed\u53e5\u5757\u4e2d\u7684\u4efb\u4f55\u8bed\u53e5\u629b\u51fa\u7684\u5f02\u5e38\uff0c\u5e76\u4e14\u53d1\u9001\u5b83\u4eec\u5230\uff0c\u5408\u9002\u7684 catch \u8bed\u53e5\u5757\u6765\u8fdb\u884c\u5904\u7406\u3002\u4e00\u4e2a try \u8bed\u53e5\u5757\u5fc5\u987b\u6709\u81f3\u5c11\u4e00\u4e2a catch \u8bed\u53e5\u5757\uff0c\u7d27\u8ddf\u7740 try \u8bed\u53e5\uff0c\u4e5f\u8bb8\u6709\u5f88\u591a\u4e2a\u6355\u83b7\u8bed\u53e5\u5feb\u6309\u987a\u5e8f\u6392\u5217\u3002 \u4e00\u65e6\u4e00\u4e2a\u5f02\u5e38\u5728 try \u8bed\u53e5\u4e2d\u88ab\u6355\u83b7\uff0c\u5e76\u4e14\u53d1\u9001\u5230\u4e00\u4e2a catch \u8bed\u53e5\u5757\u6765\u5904\u7406\uff0c\u5f02\u5e38\u88ab\u8ba4\u4e3a\u5904\u7406\uff0c\u5e76\u4e14\u5728 catch \u8bed\u53e5\u540e\u6267\u884c\u5c06\u4f1a\u50cf\u5f80\u5e38\u4e00\u6837\u7ee7\u7eed\u3002 \u6355\u83b7\u53c2\u6570\u5c31\u50cf\u51fd\u6570\u53c2\u6570\u90a3\u6837\u5de5\u4f5c\uff0c\u53c2\u6570\u5728\u540e\u7eed\u7684 try \u8bed\u53e5\u5757\u4e2d\u53ef\u7528\u3002\u57fa\u7840\u7c7b\u578b\u7684\u5f02\u5e38\u53ef\u4ee5\u88ab\u6355\u83b7\u4ee5\u503c\u7684\u5f62\u5f0f\uff0c\u4f46\u662f\u975e\u57fa\u7840\u7c7b\u578b\u7684\u5f02\u5e38\u5e94\u8be5\u88ab\u6355\u83b7\uff0c\u4ee5\u5e38\u5f15\u7528\u7684\u65b9\u5f0f\uff0c\u6765\u907f\u514d\u4e0d\u5fc5\u8981\u7684\u62f7\u8d1d\u3002 \u5c31\u50cf\u7528\u51fd\u6570\u90a3\u6837\uff0c\u5982\u679c\u53c2\u6570\u6ca1\u6709\u5728\u8bed\u53e5\u4e2d\u88ab\u4f7f\u7528\uff0c\u53d8\u91cf\u540d\u53ef\u4ee5\u88ab\u7701\u7565 catch ( double ) // note: no variable name since we don't use it in the catch block below // \u6ce8\u610f\uff1a\u65e0\u53d8\u91cf\u540d\uff0c\u56e0\u4e3a\u6211\u4eec\u4e0d\u4f1a\u518dcatch\u8bed\u53e5\u5757\u4e2d\u4f7f\u7528\u5b83 { // Handle exception of type double here // \u5904\u7406 double \u7c7b\u578b\u7684\u5f02\u5e38 std :: cerr << \"We caught an exception of type double\" << '\\n' ; } \u8fd9\u53ef\u4ee5\u9632\u6b62\u7f16\u8bd1\u5668\u505a\u6709\u5173\u672a\u4f7f\u7528\u53d8\u91cf\u7684\u8b66\u544a\u3002 \u629b\u51fa(throw)\uff0ctry\uff0c\u6355\u83b7(catch) \u00b6 \u8fd9\u6709\u4e00\u6574\u4e2a\u7a0b\u5e8f\uff0c\u4f7f\u7528\u4e86 throw, try \u548c\u8bb8\u591a catch \u8bed\u53e5\u5757\u3002 #include <iostream> #include <string> int main () { try { // Statements that may throw exceptions you want to handle go here throw - 1 ; // here's a trivial example } catch ( int x ) { // Any exceptions of type int thrown within the above try block get sent here std :: cerr << \"We caught an int exception with value: \" << x << '\\n' ; } catch ( double ) // no variable name since we don't use the exception itself in the catch block below { // Any exceptions of type double thrown within the above try block get sent here std :: cerr << \"We caught an exception of type double\" << '\\n' ; } catch ( const std :: string & str ) // catch classes by const reference { // Any exceptions of type std::string thrown within the above try block get sent here std :: cerr << \"We caught an exception of type std::string\" << '\\n' ; } std :: cout << \"Continuing on our merry way \\n \" ; return 0 ; } \u8fd0\u884c\u4ee5\u4e0a\u7684 try/catch \u8bed\u53e5\u5757\u5c06\u4f1a\u4ea7\u751f\u5982\u4e0b\u7ed3\u679c\uff1a We caught an int exception with value -1 Continuing on our merry way \u4e00\u4e2a\u629b\u51fa\u8bed\u53e5\u88ab\u7528\u6765\u629b\u51fa\u4e00\u4e2a\u5f02\u5e38\uff0c\u901a\u8fc7 -1 \u8fd9\u4e2a\u503c\uff0c\u7c7b\u578b\u4e3a int \u3002 throw \u8bed\u53e5\u4f1a\u88ab\u7d27\u63a5\u7740\u7684\u5c01\u95ed\u7684 try \u8bed\u53e5\u5757\u6355\u83b7\uff0c\u5e76\u4e14\u53d1\u9001\u5230\u5408\u9002\u7684\u5904\u7406\u6574\u578b\u5f02\u5e38\u7684 catch \u8bed\u53e5\u5757\u3002\u8fd9\u4e2a catch \u8bed\u53e5\u5757\u6253\u5370\u4e86\u5408\u9002\u7684\u9519\u8bef\u4fe1\u606f\u3002 \u4e00\u65e6\u5f02\u5e38\u88ab\u5904\u7406\uff0c\u7a0b\u5e8f\u5c31\u4f1a\u4ece catch \u8bed\u53e5\u5757\u7ed3\u675f\u7684\u5730\u65b9\u5f00\u59cb\u6b63\u5e38\u8fd0\u884c\uff0c\u5e76\u4e14\u6253\u5370 \u201cContinuing on our merry way\u201d\u3002 \u518d\u590d\u4e60\u5f02\u5e38\u5904\u7406 \u00b6 \u5f02\u5e38\u5904\u7406\u5b9e\u9645\u4e0a\u975e\u5e38\u7b80\u5355\uff0c\u4e0b\u9762\u4e24\u6bb5\u8bdd\u8986\u76d6\u4e86\u5927\u591a\u6570\u4f60\u9700\u8981\u8bb0\u5f97\u7684\u6709\u5173\u5f02\u5e38\u7684\u4e8b\u60c5\uff1a \u5f53\u4e00\u4e2a\u5f02\u5e38\u88ab\u4f7f\u7528 throw \u629b\u51fa\uff0c\u7a0b\u5e8f\u7684\u6267\u884c\u4f1a\u7acb\u5373\u8df3\u5230\u6700\u8fd1\u7684 try \u8bed\u53e5\u5757\uff08\u5411\u4e0a\u4f20\u64ad\u5806\u6808\uff0c\u5982\u679c\u6709\u5fc5\u8981\u627e\u5230\u4e00\u4e2a\u5c01\u95ed\u7684 try \u8bed\u53e5\u5757\u2014\u2014\u6211\u4eec\u5c06\u5728\u4e0b\u8282\u8bfe\u8ba8\u8bba\u66f4\u52a0\u8be6\u7ec6\u7684\u5185\u5bb9\uff09\u3002\u5982\u679c\u4efb\u4f55\u5f02\u5e38\u51fd\u6570\u53ef\u4ee5\u5904\u7406\u4e4b\u524d try \u8bed\u53e5\u5feb\u629b\u51fa\u7684\u5f02\u5e38\uff0c\u90a3\u4e2a\u51fd\u6570\u5c06\u4f1a\u88ab\u6267\u884c\uff0c\u5f02\u5e38\u4e5f\u4f1a\u88ab\u8ba4\u4e3a\u5904\u7406\u4e86\u3002 \u5982\u679c\u6ca1\u6709\u5408\u9002\u7684\u5904\u7406\u51fd\u6570\u5b58\u5728\uff0c\u6267\u884c\u7684\u7a0b\u5e8f\u4f1a\u8df3\u51fa\u5230\u4e0b\u4e00\u4e2a try \u95ed\u5408\u8bed\u53e5\uff0c\u5982\u679c\u6ca1\u6709\u5408\u9002\u7684 catch \u8bed\u53e5\u53ef\u4ee5\u88ab\u627e\u5230\u5728\u7a0b\u5e8f\u7ed3\u675f\u524d\uff0c\u7a0b\u5e8f\u5c06\u4f1a\u5e26\u7740\u5f02\u5e38\u9519\u8bef\u5931\u8d25\u3002 \u6ce8\u610f\uff0c\u7f16\u8bd1\u5668\u4e0d\u4f1a\u6267\u884c\u4e00\u4e2a\u9690\u5f0f\u8f6c\u5316 (implicit conversions) \u6216\u8005\u5347\u7ea7 (promotions) \u5f53\u4f7f\u7528 catch \u8bed\u53e5\u6765\u6355\u83b7\u5f02\u5e38\u65f6\uff01\u4f8b\u5982\uff0c\u4e00\u4e2a char \u7c7b\u578b\u7684\u5f02\u5e38\u5c06\u4e0d\u4f1a\u5339\u914d\u4e00\u4e2a int \u7c7b\u578b\u7684 catch \u8bed\u53e5\u5757\u3002\u4e00\u4e2a int \u5f02\u5e38\u5c06\u4e0d\u4f1a\u5339\u914d\u4e00\u4e2a float \u7c7b\u578b\u7684 catch \u8bed\u53e5\u5757\u3002\u7136\u800c\uff0c\u4ece\u6d3e\u751f\u7c7b\u5230\u7236\u7c7b\u4e4b\u4e00\u5c06\u4f1a\u6267\u884c\u3002 \u8fd9\u5c31\u662f\u5168\u90e8\uff0c\u63a5\u4e0b\u6765\u7684\u7ae0\u8282\u5c06\u4f1a\u5c3d\u91cf\u5c55\u793a\u6240\u6709\u8fd9\u4e9b\u539f\u5219\u7684\u4f8b\u5b50\u3002 \u5f02\u5e38\u88ab\u7acb\u5373\u5904\u7406 \u00b6 \u8fd9\u662f\u4e00\u4e2a\u77ed\u5c0f\u7684\u7a0b\u5e8f\uff0c\u5c55\u793a\u4e86\u5f02\u5e38\u5982\u4f55\u88ab\u7acb\u523b\u5904\u7406\uff1a #include <iostream> int main () { try { throw 4.5 ; // throw exception of type double std :: cout << \"This never prints \\n \" ; } catch ( double x ) // handle exception of type double { std :: cerr << \"We caught a double of value: \" << x << '\\n' ; } return 0 ; } \u8fd9\u4e2a\u7a0b\u5e8f\u975e\u5e38\u7b80\u5355\u3002\u8fd9\u5c31\u662f\u5177\u4f53\u53d1\u751f\u7684\u7684\u4e8b\u60c5\uff1a\u629b\u51fa\u8bed\u53e5\u662f\u7b2c\u4e00\u6267\u884c\u7684\u8bed\u53e5 \u2014\u2014 \u8fd9\u5f15\u8d77\u4e86\u4e00\u4e2a double \u7c7b\u578b\u7684\u5f02\u5e38\u88ab\u629b\u51fa\u3002\u6267\u884c\u6d41\u7a0b\u4e00\u9897\u79fb\u52a8\u5230\u6700\u8fd1\u7684 try \u8bed\u53e5\u5757\u95ed\u5408\u5904\uff0c\u4e5f\u662f\u8fd9\u4e2a\u7a0b\u5e8f\u4e2d\u552f\u4e00\u7684 try block\u3002 catch \u8bed\u53e5\u5c06\u4f1a\u7d27\u63a5\u7740\u68c0\u67e5\u662f\u5426\u6709 handler \u5339\u914d\u3002\u6211\u4eec\u7684\u5f02\u5e38\u5c31\u662f double \u7c7b\u578b\u7684\u3002\u800c\u4e14\u6211\u4eec\u6b63\u5728\u5bfb\u627e\u4e00\u4e2a double \u7c7b\u578b\u7684 catch \u8bed\u53e5\uff0c\u6211\u4eec\u521a\u597d\u6709\u4e00\u4e2a\uff0c\u7d27\u63a5\u7740\u5b83\u5c31\u4f1a\u6267\u884c\u3002 \u56e0\u6b64\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u8f93\u51fa\u5982\u4e0b\uff1a We caught a double of value: 4.5 \u6ce8\u610f\u5230 \"this never prints\" \u662f\u4ece\u6ca1\u88ab\u6253\u5370\u7684\uff0c\u56e0\u4e3a\u5f02\u5e38\u9020\u6210\u6267\u884c\u8def\u5f84\u7acb\u523b\u8df3\u5230 double \u7684\u5f02\u5e38\u5904\u7406\u3002 \u4e00\u4e2a\u66f4\u52a0\u771f\u5b9e\u7684\u4f8b\u5b50 \u00b6 \u8ba9\u6211\u4eec\u770b\u4e00\u4e2a\u4e0d\u662f\u90a3\u4e48\u7406\u8bba\u7684\u4f8b\u5b50\uff1a #include \"math.h\" // for sqrt() function #include <iostream> int main () { std :: cout << \"Enter a number: \" ; double x ; std :: cin >> x ; try // Look for exceptions that occur within try block and route to attached catch block(s) { // If the user entered a negative number, this is an error condition if ( x < 0.0 ) throw \"Can not take sqrt of negative number\" ; // throw exception of type const char* // Otherwise, print the answer std :: cout << \"The sqrt of \" << x << \" is \" << sqrt ( x ) << '\\n' ; } catch ( const char * exception ) // catch exceptions of type const char* { std :: cerr << \"Error: \" << exception << '\\n' ; } } In this code, the user is asked to enter a number. If they enter a positive number, the if statement does not execute, no exception is thrown, and the square root of the number is printed. Because no exception is thrown in this case, the code inside the catch block never executes. The result is something like this: \u5728\u8fd9\u6bb5\u4ee3\u7801\u4e2d\uff0c\u7528\u6237\u88ab\u8981\u6c42\u8f93\u5165\u4e00\u4e2a\u6570\u5b57\uff0c\u5982\u679c\u4ed6\u4eec\u8f93\u5165\u4e00\u4e2a\u6b63\u6570\uff0c\u90a3\u4e48 if \u8bed\u53e5\u4e0d\u4f1a\u6267\u884c\uff0c\u6ca1\u6709\u5f02\u5e38\u629b\u51fa\uff0c\u5e76\u4e14\u8f93\u5165\u6570\u5b57\u7684\u5e73\u65b9\u6839\u5c06\u4f1a\u88ab\u6253\u5370\u3002\u56e0\u4e3a\u6ca1\u6709\u5f02\u5e38\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\u88ab\u629b\u51fa\uff0c catch \u8bed\u53e5\u5757\u4e2d\u7684\u4ee3\u7801\u4ece\u4e0d\u4f1a\u6267\u884c\uff0c\u7ed3\u679c\u5982\u4e0b\uff1a Enter a number: 9 The sqrt of 9 is 3 If the user enters a negative number, we throw an exception of type const char*. Because we\u2019re within a try block and a matching exception handler is found, control immediately transfers to the const char* exception handler. The result is: Enter a number: -4 Error: Can not take sqrt of negative number By now, you should be getting the basic idea behind exceptions. In the next lesson, we\u2019ll do quite a few more examples to show how flexible exceptions are. What catch blocks typically do If an exception is routed to a catch block, it is considered \u201chandled\u201d even if the catch block is empty. However, typically you\u2019ll want your catch blocks to do something useful. There are three common things that catch blocks do when they catch an exception: First, catch blocks may print an error (either to the console, or a log file). Second, catch blocks may return a value or error code back to the caller. Third, a catch block may throw another exception. Because the catch block is outside of the try block, the newly thrown exception in this case is not handled by the preceding try block -- it\u2019s handled by the next enclosing try block.","title":"14.2 \u57fa\u672c\u5f02\u5e38\u5904\u7406"},{"location":"14-exceptions/14.2-basic-exception-handloing/#142","text":"By Alex on October 4 th , 2008 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.13 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b \u4e3a\u4ec0\u4e48\u9700\u8981\u5f02\u5e38 \u4e2d\uff0c\u6211\u4eec\u8ba8\u8bba\u4e86\u5173\u4e8e\u4f7f\u7528\u8fd4\u56de\u503c\u72b6\u6001\u7801\u4e3a\u4f55\u4f1a\u4f7f\u5f97\u4f60\u7684\u63a7\u5236\u6d41\u548c\u9519\u8bef\u5904\u7406\u88ab\u6df7\u5408\uff0c\u4f7f\u5f97\u4e24\u8005\u76f8\u4e92\u7ea6\u675f\u3002\u5f02\u5e38\u5728C++\u4e2d\u7684\u5b9e\u73b0\u4f7f\u7528\u4e86\u4e09\u4e2a\u5173\u952e\u8bcd\uff0c\u6765\u76f8\u4e92\u8fde\u63a5\uff1a throw , try , catch \u3002","title":"14.2 \u57fa\u672c\u5f02\u5e38\u5904\u7406"},{"location":"14-exceptions/14.2-basic-exception-handloing/#_1","text":"\u5728\u73b0\u5b9e\u751f\u6d3b\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u4fe1\u53f7\u6765\u8bb0\u5f55\u5df2\u7ecf\u53d1\u751f\u7684\u7279\u5b9a\u7684\u4e8b\u60c5\u3002\u4f8b\u5982\u5728\u7f8e\u56fd\u8db3\u7403\u6bd4\u8d5b\u4e2d\uff0c\u5982\u679c\u4e00\u4e2a\u8fd0\u52a8\u5458\u72af\u89c4\u4e86\uff0c\u88c1\u5224\u5c06\u4f1a\u62ff\u51fa\u4e00\u4e2aflag\u5e76\u4e14\u5439\u54e8\u8868\u793a\u6e38\u620f\u6682\u505c\u3002\u60e9\u7f5a\u5c31\u662f\u7d27\u63a5\u7740\u8bc4\u4f30\u548c\u6267\u884c\u3002\u60e9\u7f5a\u88ab\u6267\u884c\u540e\uff0c\u6e38\u620f\u7167\u65e7\u7ee7\u7eed\u3002 \u5728 C++ \u4e2d\uff0c\u4e00\u4e2a\u629b\u51fa\u8bed\u53e5\u88ab\u7528\u6765\u53d1\u9001\u4e00\u4e2a\u4fe1\u53f7\u8868\u793a\u4e00\u4e2a\u5f02\u5e38\u6216\u8005\u9519\u8bef\u5df2\u7ecf\u53d1\u751f\uff08\u53ef\u4ee5\u8ba4\u4e3a\u662f\u629b\u51fa\u4e86\u4e00\u4e2a\u60e9\u7f5a\u7684flag\uff09\u3002\u53d1\u51fa\u4fe1\u53f7\u8868\u793a\u4e00\u4e2a\u5f02\u5e38\u5df2\u7ecf\u53d1\u751f\uff0c\u8005\u901a\u5e38\u88ab\u53eb\u505a\u629b\u51fa\u4e00\u4e2a\u5f02\u5e38\u3002 \u4e3a\u4e86\u4f7f\u7528\u4e00\u4e2a\u5f02\u5e38\u4e00\u53e5\uff0c\u7b80\u5355\u7684\u4f7f\u7528 throw \u5173\u952e\u8bcd\uff0c\u7d27\u8ddf\u7740\u4e00\u4e2a\u4f60\u5e0c\u671b\u4f7f\u7528\u7684\u4efb\u4f55\u7c7b\u578b\u7684\u503c\u6765\u901a\u77e5\u4e00\u4e2a\u9519\u8bef\u5df2\u7ecf\u53d1\u751f\uff0c\u901a\u5e38\u8fd9\u548c\u503c\u5c06\u4f1a\u662f\u4e00\u4e2a\u9519\u8bef\u7801\uff0c\u4e00\u4e2a\u95ee\u9898\u7684\u63cf\u8ff0\uff0c\u6216\u8005\u4e00\u4e2a\u81ea\u5b9a\u4e49\u5f02\u5e38\u7c7b\u3002 \u8fd9\u91cc\u662f\u4e00\u4e9b\u4f8b\u5b50\uff1a throw - 1 ; // throw a literal integer value throw ENUM_INVALID_INDEX ; // throw an enum value throw \"Can not take square root of negative number\" ; // throw a literal C-style (const char*) string throw dX ; // throw a double variable that was previously defined throw MyException ( \"Fatal Error\" ); // Throw an object of class MyException \u8fd9\u91cc\u7684\u6bcf\u4e00\u4e2a\u8bed\u53e5\u90fd\u5f53\u505a\u4e00\u4e2a\u4fe1\u53f7\uff0c\u8868\u793a\u67d0\u79cd\u7c7b\u578b\u7684\u9700\u8981\u88ab\u89e3\u51b3\u7684\u95ee\u9898\u5df2\u7ecf\u53d1\u751f\u4e86\u3002","title":"\u629b\u51fa\u5f02\u5e38"},{"location":"14-exceptions/14.2-basic-exception-handloing/#_2","text":"\u629b\u51fa\u5f02\u5e38\u53ea\u662f\u5f02\u5e38\u5904\u7406\u8fdb\u7a0b\u7684\u4e00\u90e8\u5206\u3002\u8ba9\u6211\u4eec\u56de\u5230\u7f8e\u56fd\u8db3\u7403\u7684\u6bd4\u55bb\u4e2d\uff1a\u4e00\u65e6\u88c1\u5224\u629b\u51fa\u4e00\u4e2a\u4e00\u4e2a\u60e9\u7f5aflag\uff0c\u63a5\u4e0b\u6765\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u53c2\u8d5b\u8005\u4eec\u4e3b\u8981\u5230\u4e00\u4e2a\u60e9\u7f5a\u53d1\u751f\uff0c\u5e76\u4e14\u505c\u6b62\u6e38\u620f\u3002\u4e00\u4e2a\u666e\u901a\u7684\u8db3\u7403\u6bd4\u8d5b\u6d41\u7a0b\u4e2d\u65ad\u3002 \u5728C++\u4e2d\uff0c\u6211\u4eec\u7528 try \u5173\u952e\u8bcd\u6765\u5b9a\u4e49\u4e00\u4e2a\u8bed\u53e5\u5757\uff08\u88ab\u53eb\u505a try \u8bed\u53e5\u5757\uff09\uff0ctry \u8bed\u53e5\u5757\u4f5c\u4e3a\u4e00\u4e2a\u89c2\u5bdf\u8005\uff0c\u5bfb\u627e\u4efb\u4f55\u7c7b\u578b\u88ab\u629b\u51fa\u7684\u5f02\u5e38\u5728 try \u8bed\u53e5\u7684block\u4e2d\u3002 Here\u2019s an example of a try block: try { // Statements that may throw exceptions you want to handle go here // \u5230\u90a3\u513f\uff0c\u53ef\u80fd\u629b\u51fa\u4f60\u9700\u8981\u5904\u7406\u7684\u5f02\u5e38\u7684\u8bed\u53e5\u3002 throw - 1 ; // here's a trivial throw statement // \u4e00\u4e2a\u5e38\u8bc6\u629b\u51fa\u7684\u8bed\u53e5 } \u6ce8\u610f\uff0ctry \u8bed\u53e5\u5757\u6ca1\u6709\u5b9a\u4e49\u5982\u4f55\u5904\u7406\u5f02\u5e38\u3002\u4ed6\u4ec5\u4ec5\u544a\u8bc9\u7a0b\u5e8f\uff0c\u201c\u563f\uff0c\u5982\u679c\u4efb\u4f55\u8bed\u53e5\u5728\u8fd9\u4e2a try \u8bed\u53e5\u5757\u4e2d\u629b\u51fa\uff0c\u6293\u4f4f\u5b83\uff01\u201d\u3002","title":"\u5bfb\u627e\u5f02\u5e38"},{"location":"14-exceptions/14.2-basic-exception-handloing/#_3","text":"\u6700\u540e\uff0c\u7f8e\u56fd\u8db3\u7403\u7684\u6bd4\u55bb\uff1a\u5728\u60e9\u7f5a\u88ab\u8c03\u7528\uff0c\u6e38\u620f\u5df2\u7ecf\u505c\u6b62\uff0c\u88c1\u5224\u8bc4\u4f30\u60e9\u7f5a\u5e76\u4e14\u6267\u884c\u5b83\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u60e9\u7f5a\u5fc5\u987b\u88ab\u5904\u7406\u5728\u7ee7\u7eed\u6e38\u620f\u4e4b\u524d\u3002 \u4e8b\u5b9e\u4e0a\uff0c\u5f02\u5e38\u5904\u7406\u662f catch \u8bed\u53e5\u5757\u7684\u5de5\u4f5c\u3002 catch \u5173\u952e\u8bcd\u88ab\u7528\u6765\u5b9a\u4e49\u4e00\u4e2a\u8bed\u53e5\u5757\uff08\u88ab\u53eb\u505a catch \u8bed\u53e5\u5757\uff09\u5904\u7406\u5355\u4e2a\u6570\u636e\u7c7b\u578b\u7684\u7684\u5f02\u5e38\u3002 \u8fd9\u6709\u4e00\u4e2a catch \u8bed\u53e5\u5757\u7684\u4f8b\u5b50\uff0c\u5b83\u4f1a\u6355\u83b7\u4e00\u4e2a\u6574\u578b\u5f02\u5e38\uff1a catch ( int x ) { // Handle an exception of type int here // \u5904\u7406\u4e00\u4e2a\u6574\u578b\u7684\u5f02\u5e38 std :: cerr << \"We caught an int exception with value\" << x << '\\n' ; } try \u8bed\u53e5\u5757\u548c catch \u8bed\u53e5\u5757\u4e00\u8d77\u5de5\u4f5c\u2014\u2014 \u4e00\u4e2a try \u8bed\u53e5\u5757\u68c0\u6d4b try \u8bed\u53e5\u5757\u4e2d\u7684\u4efb\u4f55\u8bed\u53e5\u629b\u51fa\u7684\u5f02\u5e38\uff0c\u5e76\u4e14\u53d1\u9001\u5b83\u4eec\u5230\uff0c\u5408\u9002\u7684 catch \u8bed\u53e5\u5757\u6765\u8fdb\u884c\u5904\u7406\u3002\u4e00\u4e2a try \u8bed\u53e5\u5757\u5fc5\u987b\u6709\u81f3\u5c11\u4e00\u4e2a catch \u8bed\u53e5\u5757\uff0c\u7d27\u8ddf\u7740 try \u8bed\u53e5\uff0c\u4e5f\u8bb8\u6709\u5f88\u591a\u4e2a\u6355\u83b7\u8bed\u53e5\u5feb\u6309\u987a\u5e8f\u6392\u5217\u3002 \u4e00\u65e6\u4e00\u4e2a\u5f02\u5e38\u5728 try \u8bed\u53e5\u4e2d\u88ab\u6355\u83b7\uff0c\u5e76\u4e14\u53d1\u9001\u5230\u4e00\u4e2a catch \u8bed\u53e5\u5757\u6765\u5904\u7406\uff0c\u5f02\u5e38\u88ab\u8ba4\u4e3a\u5904\u7406\uff0c\u5e76\u4e14\u5728 catch \u8bed\u53e5\u540e\u6267\u884c\u5c06\u4f1a\u50cf\u5f80\u5e38\u4e00\u6837\u7ee7\u7eed\u3002 \u6355\u83b7\u53c2\u6570\u5c31\u50cf\u51fd\u6570\u53c2\u6570\u90a3\u6837\u5de5\u4f5c\uff0c\u53c2\u6570\u5728\u540e\u7eed\u7684 try \u8bed\u53e5\u5757\u4e2d\u53ef\u7528\u3002\u57fa\u7840\u7c7b\u578b\u7684\u5f02\u5e38\u53ef\u4ee5\u88ab\u6355\u83b7\u4ee5\u503c\u7684\u5f62\u5f0f\uff0c\u4f46\u662f\u975e\u57fa\u7840\u7c7b\u578b\u7684\u5f02\u5e38\u5e94\u8be5\u88ab\u6355\u83b7\uff0c\u4ee5\u5e38\u5f15\u7528\u7684\u65b9\u5f0f\uff0c\u6765\u907f\u514d\u4e0d\u5fc5\u8981\u7684\u62f7\u8d1d\u3002 \u5c31\u50cf\u7528\u51fd\u6570\u90a3\u6837\uff0c\u5982\u679c\u53c2\u6570\u6ca1\u6709\u5728\u8bed\u53e5\u4e2d\u88ab\u4f7f\u7528\uff0c\u53d8\u91cf\u540d\u53ef\u4ee5\u88ab\u7701\u7565 catch ( double ) // note: no variable name since we don't use it in the catch block below // \u6ce8\u610f\uff1a\u65e0\u53d8\u91cf\u540d\uff0c\u56e0\u4e3a\u6211\u4eec\u4e0d\u4f1a\u518dcatch\u8bed\u53e5\u5757\u4e2d\u4f7f\u7528\u5b83 { // Handle exception of type double here // \u5904\u7406 double \u7c7b\u578b\u7684\u5f02\u5e38 std :: cerr << \"We caught an exception of type double\" << '\\n' ; } \u8fd9\u53ef\u4ee5\u9632\u6b62\u7f16\u8bd1\u5668\u505a\u6709\u5173\u672a\u4f7f\u7528\u53d8\u91cf\u7684\u8b66\u544a\u3002","title":"\u5f02\u5e38\u5904\u7406"},{"location":"14-exceptions/14.2-basic-exception-handloing/#throwtrycatch","text":"\u8fd9\u6709\u4e00\u6574\u4e2a\u7a0b\u5e8f\uff0c\u4f7f\u7528\u4e86 throw, try \u548c\u8bb8\u591a catch \u8bed\u53e5\u5757\u3002 #include <iostream> #include <string> int main () { try { // Statements that may throw exceptions you want to handle go here throw - 1 ; // here's a trivial example } catch ( int x ) { // Any exceptions of type int thrown within the above try block get sent here std :: cerr << \"We caught an int exception with value: \" << x << '\\n' ; } catch ( double ) // no variable name since we don't use the exception itself in the catch block below { // Any exceptions of type double thrown within the above try block get sent here std :: cerr << \"We caught an exception of type double\" << '\\n' ; } catch ( const std :: string & str ) // catch classes by const reference { // Any exceptions of type std::string thrown within the above try block get sent here std :: cerr << \"We caught an exception of type std::string\" << '\\n' ; } std :: cout << \"Continuing on our merry way \\n \" ; return 0 ; } \u8fd0\u884c\u4ee5\u4e0a\u7684 try/catch \u8bed\u53e5\u5757\u5c06\u4f1a\u4ea7\u751f\u5982\u4e0b\u7ed3\u679c\uff1a We caught an int exception with value -1 Continuing on our merry way \u4e00\u4e2a\u629b\u51fa\u8bed\u53e5\u88ab\u7528\u6765\u629b\u51fa\u4e00\u4e2a\u5f02\u5e38\uff0c\u901a\u8fc7 -1 \u8fd9\u4e2a\u503c\uff0c\u7c7b\u578b\u4e3a int \u3002 throw \u8bed\u53e5\u4f1a\u88ab\u7d27\u63a5\u7740\u7684\u5c01\u95ed\u7684 try \u8bed\u53e5\u5757\u6355\u83b7\uff0c\u5e76\u4e14\u53d1\u9001\u5230\u5408\u9002\u7684\u5904\u7406\u6574\u578b\u5f02\u5e38\u7684 catch \u8bed\u53e5\u5757\u3002\u8fd9\u4e2a catch \u8bed\u53e5\u5757\u6253\u5370\u4e86\u5408\u9002\u7684\u9519\u8bef\u4fe1\u606f\u3002 \u4e00\u65e6\u5f02\u5e38\u88ab\u5904\u7406\uff0c\u7a0b\u5e8f\u5c31\u4f1a\u4ece catch \u8bed\u53e5\u5757\u7ed3\u675f\u7684\u5730\u65b9\u5f00\u59cb\u6b63\u5e38\u8fd0\u884c\uff0c\u5e76\u4e14\u6253\u5370 \u201cContinuing on our merry way\u201d\u3002","title":"\u629b\u51fa(throw)\uff0ctry\uff0c\u6355\u83b7(catch)"},{"location":"14-exceptions/14.2-basic-exception-handloing/#_4","text":"\u5f02\u5e38\u5904\u7406\u5b9e\u9645\u4e0a\u975e\u5e38\u7b80\u5355\uff0c\u4e0b\u9762\u4e24\u6bb5\u8bdd\u8986\u76d6\u4e86\u5927\u591a\u6570\u4f60\u9700\u8981\u8bb0\u5f97\u7684\u6709\u5173\u5f02\u5e38\u7684\u4e8b\u60c5\uff1a \u5f53\u4e00\u4e2a\u5f02\u5e38\u88ab\u4f7f\u7528 throw \u629b\u51fa\uff0c\u7a0b\u5e8f\u7684\u6267\u884c\u4f1a\u7acb\u5373\u8df3\u5230\u6700\u8fd1\u7684 try \u8bed\u53e5\u5757\uff08\u5411\u4e0a\u4f20\u64ad\u5806\u6808\uff0c\u5982\u679c\u6709\u5fc5\u8981\u627e\u5230\u4e00\u4e2a\u5c01\u95ed\u7684 try \u8bed\u53e5\u5757\u2014\u2014\u6211\u4eec\u5c06\u5728\u4e0b\u8282\u8bfe\u8ba8\u8bba\u66f4\u52a0\u8be6\u7ec6\u7684\u5185\u5bb9\uff09\u3002\u5982\u679c\u4efb\u4f55\u5f02\u5e38\u51fd\u6570\u53ef\u4ee5\u5904\u7406\u4e4b\u524d try \u8bed\u53e5\u5feb\u629b\u51fa\u7684\u5f02\u5e38\uff0c\u90a3\u4e2a\u51fd\u6570\u5c06\u4f1a\u88ab\u6267\u884c\uff0c\u5f02\u5e38\u4e5f\u4f1a\u88ab\u8ba4\u4e3a\u5904\u7406\u4e86\u3002 \u5982\u679c\u6ca1\u6709\u5408\u9002\u7684\u5904\u7406\u51fd\u6570\u5b58\u5728\uff0c\u6267\u884c\u7684\u7a0b\u5e8f\u4f1a\u8df3\u51fa\u5230\u4e0b\u4e00\u4e2a try \u95ed\u5408\u8bed\u53e5\uff0c\u5982\u679c\u6ca1\u6709\u5408\u9002\u7684 catch \u8bed\u53e5\u53ef\u4ee5\u88ab\u627e\u5230\u5728\u7a0b\u5e8f\u7ed3\u675f\u524d\uff0c\u7a0b\u5e8f\u5c06\u4f1a\u5e26\u7740\u5f02\u5e38\u9519\u8bef\u5931\u8d25\u3002 \u6ce8\u610f\uff0c\u7f16\u8bd1\u5668\u4e0d\u4f1a\u6267\u884c\u4e00\u4e2a\u9690\u5f0f\u8f6c\u5316 (implicit conversions) \u6216\u8005\u5347\u7ea7 (promotions) \u5f53\u4f7f\u7528 catch \u8bed\u53e5\u6765\u6355\u83b7\u5f02\u5e38\u65f6\uff01\u4f8b\u5982\uff0c\u4e00\u4e2a char \u7c7b\u578b\u7684\u5f02\u5e38\u5c06\u4e0d\u4f1a\u5339\u914d\u4e00\u4e2a int \u7c7b\u578b\u7684 catch \u8bed\u53e5\u5757\u3002\u4e00\u4e2a int \u5f02\u5e38\u5c06\u4e0d\u4f1a\u5339\u914d\u4e00\u4e2a float \u7c7b\u578b\u7684 catch \u8bed\u53e5\u5757\u3002\u7136\u800c\uff0c\u4ece\u6d3e\u751f\u7c7b\u5230\u7236\u7c7b\u4e4b\u4e00\u5c06\u4f1a\u6267\u884c\u3002 \u8fd9\u5c31\u662f\u5168\u90e8\uff0c\u63a5\u4e0b\u6765\u7684\u7ae0\u8282\u5c06\u4f1a\u5c3d\u91cf\u5c55\u793a\u6240\u6709\u8fd9\u4e9b\u539f\u5219\u7684\u4f8b\u5b50\u3002","title":"\u518d\u590d\u4e60\u5f02\u5e38\u5904\u7406"},{"location":"14-exceptions/14.2-basic-exception-handloing/#_5","text":"\u8fd9\u662f\u4e00\u4e2a\u77ed\u5c0f\u7684\u7a0b\u5e8f\uff0c\u5c55\u793a\u4e86\u5f02\u5e38\u5982\u4f55\u88ab\u7acb\u523b\u5904\u7406\uff1a #include <iostream> int main () { try { throw 4.5 ; // throw exception of type double std :: cout << \"This never prints \\n \" ; } catch ( double x ) // handle exception of type double { std :: cerr << \"We caught a double of value: \" << x << '\\n' ; } return 0 ; } \u8fd9\u4e2a\u7a0b\u5e8f\u975e\u5e38\u7b80\u5355\u3002\u8fd9\u5c31\u662f\u5177\u4f53\u53d1\u751f\u7684\u7684\u4e8b\u60c5\uff1a\u629b\u51fa\u8bed\u53e5\u662f\u7b2c\u4e00\u6267\u884c\u7684\u8bed\u53e5 \u2014\u2014 \u8fd9\u5f15\u8d77\u4e86\u4e00\u4e2a double \u7c7b\u578b\u7684\u5f02\u5e38\u88ab\u629b\u51fa\u3002\u6267\u884c\u6d41\u7a0b\u4e00\u9897\u79fb\u52a8\u5230\u6700\u8fd1\u7684 try \u8bed\u53e5\u5757\u95ed\u5408\u5904\uff0c\u4e5f\u662f\u8fd9\u4e2a\u7a0b\u5e8f\u4e2d\u552f\u4e00\u7684 try block\u3002 catch \u8bed\u53e5\u5c06\u4f1a\u7d27\u63a5\u7740\u68c0\u67e5\u662f\u5426\u6709 handler \u5339\u914d\u3002\u6211\u4eec\u7684\u5f02\u5e38\u5c31\u662f double \u7c7b\u578b\u7684\u3002\u800c\u4e14\u6211\u4eec\u6b63\u5728\u5bfb\u627e\u4e00\u4e2a double \u7c7b\u578b\u7684 catch \u8bed\u53e5\uff0c\u6211\u4eec\u521a\u597d\u6709\u4e00\u4e2a\uff0c\u7d27\u63a5\u7740\u5b83\u5c31\u4f1a\u6267\u884c\u3002 \u56e0\u6b64\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u8f93\u51fa\u5982\u4e0b\uff1a We caught a double of value: 4.5 \u6ce8\u610f\u5230 \"this never prints\" \u662f\u4ece\u6ca1\u88ab\u6253\u5370\u7684\uff0c\u56e0\u4e3a\u5f02\u5e38\u9020\u6210\u6267\u884c\u8def\u5f84\u7acb\u523b\u8df3\u5230 double \u7684\u5f02\u5e38\u5904\u7406\u3002","title":"\u5f02\u5e38\u88ab\u7acb\u5373\u5904\u7406"},{"location":"14-exceptions/14.2-basic-exception-handloing/#_6","text":"\u8ba9\u6211\u4eec\u770b\u4e00\u4e2a\u4e0d\u662f\u90a3\u4e48\u7406\u8bba\u7684\u4f8b\u5b50\uff1a #include \"math.h\" // for sqrt() function #include <iostream> int main () { std :: cout << \"Enter a number: \" ; double x ; std :: cin >> x ; try // Look for exceptions that occur within try block and route to attached catch block(s) { // If the user entered a negative number, this is an error condition if ( x < 0.0 ) throw \"Can not take sqrt of negative number\" ; // throw exception of type const char* // Otherwise, print the answer std :: cout << \"The sqrt of \" << x << \" is \" << sqrt ( x ) << '\\n' ; } catch ( const char * exception ) // catch exceptions of type const char* { std :: cerr << \"Error: \" << exception << '\\n' ; } } In this code, the user is asked to enter a number. If they enter a positive number, the if statement does not execute, no exception is thrown, and the square root of the number is printed. Because no exception is thrown in this case, the code inside the catch block never executes. The result is something like this: \u5728\u8fd9\u6bb5\u4ee3\u7801\u4e2d\uff0c\u7528\u6237\u88ab\u8981\u6c42\u8f93\u5165\u4e00\u4e2a\u6570\u5b57\uff0c\u5982\u679c\u4ed6\u4eec\u8f93\u5165\u4e00\u4e2a\u6b63\u6570\uff0c\u90a3\u4e48 if \u8bed\u53e5\u4e0d\u4f1a\u6267\u884c\uff0c\u6ca1\u6709\u5f02\u5e38\u629b\u51fa\uff0c\u5e76\u4e14\u8f93\u5165\u6570\u5b57\u7684\u5e73\u65b9\u6839\u5c06\u4f1a\u88ab\u6253\u5370\u3002\u56e0\u4e3a\u6ca1\u6709\u5f02\u5e38\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\u88ab\u629b\u51fa\uff0c catch \u8bed\u53e5\u5757\u4e2d\u7684\u4ee3\u7801\u4ece\u4e0d\u4f1a\u6267\u884c\uff0c\u7ed3\u679c\u5982\u4e0b\uff1a Enter a number: 9 The sqrt of 9 is 3 If the user enters a negative number, we throw an exception of type const char*. Because we\u2019re within a try block and a matching exception handler is found, control immediately transfers to the const char* exception handler. The result is: Enter a number: -4 Error: Can not take sqrt of negative number By now, you should be getting the basic idea behind exceptions. In the next lesson, we\u2019ll do quite a few more examples to show how flexible exceptions are. What catch blocks typically do If an exception is routed to a catch block, it is considered \u201chandled\u201d even if the catch block is empty. However, typically you\u2019ll want your catch blocks to do something useful. There are three common things that catch blocks do when they catch an exception: First, catch blocks may print an error (either to the console, or a log file). Second, catch blocks may return a value or error code back to the caller. Third, a catch block may throw another exception. Because the catch block is outside of the try block, the newly thrown exception in this case is not handled by the preceding try block -- it\u2019s handled by the next enclosing try block.","title":"\u4e00\u4e2a\u66f4\u52a0\u771f\u5b9e\u7684\u4f8b\u5b50"},{"location":"14-exceptions/14.3-exceptions-functions-and-stack-unwinding/","text":"14.3 \u5f02\u5e38\uff0c\u51fd\u6570\uff0c\u6808\u5c55\u5f00 \u00b6 By Alex on October 5 th , 2008 | last modified by Alex on January 23 rd , 2020 In the previous lesson on basic exception handling, we explained how throw, try, and catch work together to enable exception handling. In this lesson, we\u2019ll talk about how exception handling interacts with functions. Throwing exceptions outside of a try block In the examples in the previous lesson, the throw statements were placed directly within a try block. If this were a necessity, exception handling would be of limited use. One of the most useful properties of exception handling is that the throw statements do NOT have to be placed directly inside a try block due to the way exceptions propagate up the stack when thrown. This allows us to use exception handling in a much more modular fashion. We\u2019ll demonstrate this by rewriting the square root program from the previous lesson to use a modular function. #include <cmath> // for sqrt() function #include <iostream> // A modular square root function double mySqrt ( double x ) { // If the user entered a negative number, this is an error condition if ( x < 0.0 ) throw \"Can not take sqrt of negative number\" ; // throw exception of type const char* return sqrt ( x ); } int main () { std :: cout << \"Enter a number: \" ; double x ; std :: cin >> x ; try // Look for exceptions that occur within try block and route to attached catch block(s) { double d = mySqrt ( x ); std :: cout << \"The sqrt of \" << x << \" is \" << d << '\\n' ; } catch ( const char * exception ) // catch exceptions of type const char* { std :: cerr << \"Error: \" << exception << std :: endl ; } return 0 ; } In this program, we\u2019ve taken the code that checks for an exception and calculates the square root and put it inside a modular function called mySqrt(). We\u2019ve then called this mySqrt() function from inside a try block. Let\u2019s verify that it still works as expected: Enter a number: -4 Error: Can not take sqrt of negative number It does! Let\u2019s revisit for a moment what happens when an exception is raised. First, the program looks to see if the exception can be handled immediately (which means it was thrown inside a try block). If not, the current function is terminated, and the program checks to see if the function\u2019s caller will handle the exception. If not, it terminates the caller and checks the caller\u2019s caller. Each function is terminated in sequence until a handler for the exception is found, or until main() is terminated without the exception being handled. This process is called unwinding the stack (see the lesson on the stack and the heap if you need a refresher on what the call stack is). Now, let\u2019s take a detailed look at how that applies to this program when an exception is raised from within mySqrt(). First, the program checks to see if the exception was thrown from within a try block inside the function. In this case, it was not. Then, the stack begins to unwind. First, mySqrt() terminates, and control returns to main(). The program now checks to see if we\u2019re inside a try block. We are, and there\u2019s a const char* handler, so the exception is handled by the try block within main(). To summarize, mySqrt() raised the exception, but the try/catch block in main() was the one who captured and handled the exception. Or, put another way, try blocks catch exceptions not only from statements within the try block, but also from functions that are called within the try block. The most interesting part of the above program is that the mySqrt() function can throw an exception, but this exception is not immediately inside of a try block! This essentially means mySqrt is willing to say, \u201cHey, there\u2019s a problem!\u201d, but is unwilling to handle the problem itself. It is, in essence, delegating the responsibility for handling the exception to its caller (the equivalent of how using a return code passes the responsibility of handling an error back to a function\u2019s caller). At this point, some of you are probably wondering why it\u2019s a good idea to pass errors back to the caller. Why not just make MySqrt() handle its own error? The problem is that different applications may want to handle errors in different ways. A console application may want to print a text message. A windows application may want to pop up an error dialog. In one application, this may be a fatal error, and in another application it may not be. By passing the error back up the stack, each application can handle an error from mySqrt() in a way that is the most context appropriate for it! Ultimately, this keeps mySqrt() as modular as possible, and the error handling can be placed in the less-modular parts of the code. Another stack unwinding example Here\u2019s another example showing stack unwinding in practice, using a larger stack. Although this program is long, it\u2019s pretty simple: main() calls first(), first() calls second(), second() calls third(), third() calls last(), and last() throws an exception. #include <iostream> void last () // called by third() { std :: cout << \"Start last \\n \" ; std :: cout << \"last throwing int exception \\n \" ; throw - 1 ; std :: cout << \"End last \\n \" ; } void third () // called by second() { std :: cout << \"Start third \\n \" ; last (); std :: cout << \"End third \\n \" ; } void second () // called by first() { std :: cout << \"Start second \\n \" ; try { third (); } catch ( double ) { std :: cerr << \"second caught double exception \\n \" ; } std :: cout << \"End second \\n \" ; } void first () // called by main() { std :: cout << \"Start first \\n \" ; try { second (); } catch ( int ) { std :: cerr << \"first caught int exception \\n \" ; } catch ( double ) { std :: cerr << \"first caught double exception \\n \" ; } std :: cout << \"End first \\n \" ; } int main () { std :: cout << \"Start main \\n \" ; try { first (); } catch ( int ) { std :: cerr << \"main caught int exception \\n \" ; } std :: cout << \"End main \\n \" ; return 0 ; } Take a look at this program in more detail, and see if you can figure out what gets printed and what doesn\u2019t when it is run. The answer follows: Start main Start first Start second Start third Start last last throwing int exception first caught int exception End first End main Let\u2019s examine what happens in this case. The printing of all the \u201cStart\u201d statements is straightforward and doesn\u2019t warrant further explanation. Function last() prints \u201clast throwing int exception\u201d and then throws an int exception. This is where things start to get interesting. Because last() doesn\u2019t handle the exception itself, the stack begins to unwind. Function last() terminates immediately and control returns to the caller, which is third(). Function third() doesn\u2019t handle any exceptions, so it terminates immediately and control returns to second(). Function second() has a try block, and the call to third() is within it, so the program attempts to match the exception with an appropriate catch block. However, there are no handlers for exceptions of type int here, so second() terminates immediately and control returns to first(). Note that the integer exception is not implicitly converted to match the catch block handling a double. Function first() also has a try block, and the call to second() is within it, so the program looks to see if there is a catch handler for int exceptions. There is! Consequently, first() handles the exception, and prints \u201cfirst caught int exception\u201d. Because the exception has now been handled, control continues normally at the end of the catch block within first(). This means first() prints \u201cEnd first\u201d and then terminates normally. Control returns to main(). Although main() has an exception handler for int, our exception has already been handled by first(), so the catch block within main() does not get executed. main() simply prints \u201cEnd main\u201d and then terminates normally. There are quite a few interesting principles illustrated by this program: First, the immediate caller of a function that throws an exception doesn\u2019t have to handle the exception if it doesn\u2019t want to. In this case, third() didn\u2019t handle the exception thrown by last(). It delegated that responsibility to one of its callers up the stack. Second, if a try block doesn\u2019t have a catch handler for the type of exception being thrown, stack unwinding occurs just as if there were no try block at all. In this case, second() didn\u2019t handle the exception either because it didn\u2019t have the right kind of catch block. Third, once an exception is handled, control flow proceeds as normal starting from the end of the catch blocks. This was demonstrated by first() handling the error and then terminating normally. By the time the program got back to main(), the exception had been thrown and handled already -- main() had no idea there even was an exception at all! As you can see, stack unwinding provides us with some very useful behavior -- if a function does not want to handle an exception, it doesn\u2019t have to. The exception will propagate up the stack until it finds someone who will! This allows us to decide where in the call stack is the most appropriate place to handle any errors that may occur. In the next lesson, we\u2019ll take a look at what happens when you don\u2019t capture an exception, and a method to prevent that from happening.","title":"14.3 \u5f02\u5e38\uff0c\u51fd\u6570\uff0c\u6808\u5c55\u5f00"},{"location":"14-exceptions/14.3-exceptions-functions-and-stack-unwinding/#143","text":"By Alex on October 5 th , 2008 | last modified by Alex on January 23 rd , 2020 In the previous lesson on basic exception handling, we explained how throw, try, and catch work together to enable exception handling. In this lesson, we\u2019ll talk about how exception handling interacts with functions. Throwing exceptions outside of a try block In the examples in the previous lesson, the throw statements were placed directly within a try block. If this were a necessity, exception handling would be of limited use. One of the most useful properties of exception handling is that the throw statements do NOT have to be placed directly inside a try block due to the way exceptions propagate up the stack when thrown. This allows us to use exception handling in a much more modular fashion. We\u2019ll demonstrate this by rewriting the square root program from the previous lesson to use a modular function. #include <cmath> // for sqrt() function #include <iostream> // A modular square root function double mySqrt ( double x ) { // If the user entered a negative number, this is an error condition if ( x < 0.0 ) throw \"Can not take sqrt of negative number\" ; // throw exception of type const char* return sqrt ( x ); } int main () { std :: cout << \"Enter a number: \" ; double x ; std :: cin >> x ; try // Look for exceptions that occur within try block and route to attached catch block(s) { double d = mySqrt ( x ); std :: cout << \"The sqrt of \" << x << \" is \" << d << '\\n' ; } catch ( const char * exception ) // catch exceptions of type const char* { std :: cerr << \"Error: \" << exception << std :: endl ; } return 0 ; } In this program, we\u2019ve taken the code that checks for an exception and calculates the square root and put it inside a modular function called mySqrt(). We\u2019ve then called this mySqrt() function from inside a try block. Let\u2019s verify that it still works as expected: Enter a number: -4 Error: Can not take sqrt of negative number It does! Let\u2019s revisit for a moment what happens when an exception is raised. First, the program looks to see if the exception can be handled immediately (which means it was thrown inside a try block). If not, the current function is terminated, and the program checks to see if the function\u2019s caller will handle the exception. If not, it terminates the caller and checks the caller\u2019s caller. Each function is terminated in sequence until a handler for the exception is found, or until main() is terminated without the exception being handled. This process is called unwinding the stack (see the lesson on the stack and the heap if you need a refresher on what the call stack is). Now, let\u2019s take a detailed look at how that applies to this program when an exception is raised from within mySqrt(). First, the program checks to see if the exception was thrown from within a try block inside the function. In this case, it was not. Then, the stack begins to unwind. First, mySqrt() terminates, and control returns to main(). The program now checks to see if we\u2019re inside a try block. We are, and there\u2019s a const char* handler, so the exception is handled by the try block within main(). To summarize, mySqrt() raised the exception, but the try/catch block in main() was the one who captured and handled the exception. Or, put another way, try blocks catch exceptions not only from statements within the try block, but also from functions that are called within the try block. The most interesting part of the above program is that the mySqrt() function can throw an exception, but this exception is not immediately inside of a try block! This essentially means mySqrt is willing to say, \u201cHey, there\u2019s a problem!\u201d, but is unwilling to handle the problem itself. It is, in essence, delegating the responsibility for handling the exception to its caller (the equivalent of how using a return code passes the responsibility of handling an error back to a function\u2019s caller). At this point, some of you are probably wondering why it\u2019s a good idea to pass errors back to the caller. Why not just make MySqrt() handle its own error? The problem is that different applications may want to handle errors in different ways. A console application may want to print a text message. A windows application may want to pop up an error dialog. In one application, this may be a fatal error, and in another application it may not be. By passing the error back up the stack, each application can handle an error from mySqrt() in a way that is the most context appropriate for it! Ultimately, this keeps mySqrt() as modular as possible, and the error handling can be placed in the less-modular parts of the code. Another stack unwinding example Here\u2019s another example showing stack unwinding in practice, using a larger stack. Although this program is long, it\u2019s pretty simple: main() calls first(), first() calls second(), second() calls third(), third() calls last(), and last() throws an exception. #include <iostream> void last () // called by third() { std :: cout << \"Start last \\n \" ; std :: cout << \"last throwing int exception \\n \" ; throw - 1 ; std :: cout << \"End last \\n \" ; } void third () // called by second() { std :: cout << \"Start third \\n \" ; last (); std :: cout << \"End third \\n \" ; } void second () // called by first() { std :: cout << \"Start second \\n \" ; try { third (); } catch ( double ) { std :: cerr << \"second caught double exception \\n \" ; } std :: cout << \"End second \\n \" ; } void first () // called by main() { std :: cout << \"Start first \\n \" ; try { second (); } catch ( int ) { std :: cerr << \"first caught int exception \\n \" ; } catch ( double ) { std :: cerr << \"first caught double exception \\n \" ; } std :: cout << \"End first \\n \" ; } int main () { std :: cout << \"Start main \\n \" ; try { first (); } catch ( int ) { std :: cerr << \"main caught int exception \\n \" ; } std :: cout << \"End main \\n \" ; return 0 ; } Take a look at this program in more detail, and see if you can figure out what gets printed and what doesn\u2019t when it is run. The answer follows: Start main Start first Start second Start third Start last last throwing int exception first caught int exception End first End main Let\u2019s examine what happens in this case. The printing of all the \u201cStart\u201d statements is straightforward and doesn\u2019t warrant further explanation. Function last() prints \u201clast throwing int exception\u201d and then throws an int exception. This is where things start to get interesting. Because last() doesn\u2019t handle the exception itself, the stack begins to unwind. Function last() terminates immediately and control returns to the caller, which is third(). Function third() doesn\u2019t handle any exceptions, so it terminates immediately and control returns to second(). Function second() has a try block, and the call to third() is within it, so the program attempts to match the exception with an appropriate catch block. However, there are no handlers for exceptions of type int here, so second() terminates immediately and control returns to first(). Note that the integer exception is not implicitly converted to match the catch block handling a double. Function first() also has a try block, and the call to second() is within it, so the program looks to see if there is a catch handler for int exceptions. There is! Consequently, first() handles the exception, and prints \u201cfirst caught int exception\u201d. Because the exception has now been handled, control continues normally at the end of the catch block within first(). This means first() prints \u201cEnd first\u201d and then terminates normally. Control returns to main(). Although main() has an exception handler for int, our exception has already been handled by first(), so the catch block within main() does not get executed. main() simply prints \u201cEnd main\u201d and then terminates normally. There are quite a few interesting principles illustrated by this program: First, the immediate caller of a function that throws an exception doesn\u2019t have to handle the exception if it doesn\u2019t want to. In this case, third() didn\u2019t handle the exception thrown by last(). It delegated that responsibility to one of its callers up the stack. Second, if a try block doesn\u2019t have a catch handler for the type of exception being thrown, stack unwinding occurs just as if there were no try block at all. In this case, second() didn\u2019t handle the exception either because it didn\u2019t have the right kind of catch block. Third, once an exception is handled, control flow proceeds as normal starting from the end of the catch blocks. This was demonstrated by first() handling the error and then terminating normally. By the time the program got back to main(), the exception had been thrown and handled already -- main() had no idea there even was an exception at all! As you can see, stack unwinding provides us with some very useful behavior -- if a function does not want to handle an exception, it doesn\u2019t have to. The exception will propagate up the stack until it finds someone who will! This allows us to decide where in the call stack is the most appropriate place to handle any errors that may occur. In the next lesson, we\u2019ll take a look at what happens when you don\u2019t capture an exception, and a method to prevent that from happening.","title":"14.3 \u5f02\u5e38\uff0c\u51fd\u6570\uff0c\u6808\u5c55\u5f00"},{"location":"14-exceptions/14.4-uncaught-exceptions-catch-all-handlers-and-exception-specifiers/","text":"14.4 \u672a\u6355\u83b7\u5f02\u5e38\uff0c\u6355\u83b7\u5168\u90e8\u5f02\u5e38\u548c\u5f02\u5e38\u8bf4\u660e\u7b26 \u00b6 By Alex on October 25 th , 2008 | last modified by nascardriver on June 19 th , 2020 By now, you should have a reasonable idea of how exceptions work. In this lesson, we\u2019ll cover a few more interesting exception cases. Uncaught exceptions In the past few examples, there are quite a few cases where a function assumes its caller (or another function somewhere up the call stack) will handle the exception. In the following example, mySqrt() assumes someone will handle the exception that it throws -- but what happens if nobody actually does? Here\u2019s our square root program again, minus the try block in main(): #include <iostream> #include <cmath> // for sqrt() function // A modular square root function double mySqrt ( double x ) { // If the user entered a negative number, this is an error condition if ( x < 0.0 ) throw \"Can not take sqrt of negative number\" ; // throw exception of type const char* return sqrt ( x ); } int main () { std :: cout << \"Enter a number: \" ; double x ; std :: cin >> x ; // Look ma, no exception handler! std :: cout << \"The sqrt of \" << x << \" is \" << mySqrt ( x ) << '\\n' ; return 0 ; } Now, let\u2019s say the user enters -4, and mySqrt(-4) raises an exception. Function mySqrt() doesn\u2019t handle the exception, so the program stack unwinds and control returns to main(). But there\u2019s no exception handler here either, so main() terminates. At this point, we just terminated our application! When main() terminates with an unhandled exception, the operating system will generally notify you that an unhandled exception error has occurred. How it does this depends on the operating system, but possibilities include printing an error message, popping up an error dialog, or simply crashing. Some OSes are less graceful than others. Generally this is something you want to avoid altogether! Catch-all handlers And now we find ourselves in a conundrum: functions can potentially throw exceptions of any data type, and if an exception is not caught, it will propagate to the top of your program and cause it to terminate. Since it\u2019s possible to call functions without knowing how they are even implemented (and thus, what type of exceptions they may throw), how can we possibly prevent this from happening? Fortunately, C++ provides us with a mechanism to catch all types of exceptions. This is known as a catch-all handler. A catch-all handler works just like a normal catch block, except that instead of using a specific type to catch, it uses the ellipses operator (\u2026) as the type to catch. If you recall from lesson 7.14 on ellipses and why to avoid them, ellipses were previously used to pass arguments of any type to a function. In this context, they represent exceptions of any data type. Here\u2019s an simple example: #include <iostream> int main () { try { throw 5 ; // throw an int exception } catch ( double x ) { std :: cout << \"We caught an exception of type double: \" << x << '\\n' ; } catch (...) // catch-all handler { std :: cout << \"We caught an exception of an undetermined type \\n \" ; } } Because there is no specific exception handler for type int, the catch-all handler catches this exception. This example produces the following result: We caught an exception of an undetermined type The catch-all handler should be placed last in the catch block chain. This is to ensure that exceptions can be caught by exception handlers tailored to specific data types if those handlers exist. Visual Studio enforces this constraint -- I am unsure if other compilers do. (Per reader Lonami in the comments below, GCC does too). Often, the catch-all handler block is left empty: catch (...) {} // ignore any unanticipated exceptions This will catch any unanticipated exceptions and prevent them from stack unwinding to the top of your program, but does no specific error handling. Using the catch-all handler to wrap main() One interesting use for the catch-all handler is to wrap the contents of main(): #include <iostream> int main () { try { runGame (); } catch (...) { std :: cerr << \"Abnormal termination \\n \" ; } saveState (); // Save user's game return 1 ; } In this case, if runGame() or any of the functions it calls throws an exception that is not caught, that exception will unwind up the stack and eventually get caught by this catch-all handler. This will prevent main() from terminating, and gives us a chance to print an error of our choosing and then save the user\u2019s state before exiting. This can be useful to catch and handle problems that may be unanticipated. Optional reading Dynamic exception specifiers This subsection should be considered optional reading because exception specifiers are rarely used in practice and have been removed from C++ in C++17 and C++20. Exception specifiers are a mechanism that allows us to use a function declaration to specify whether a function may or will not throw exceptions. This can be useful in determining whether a function call needs to be put inside a try block or not. There are three types of exception specifiers, all of which use what is called the throw (\u2026) syntax. First, we can use an empty throw statement to denote that a function does not throw any exceptions outside of itself: int doSomething () throw (); // does not throw exceptions Note that doSomething() can still use exceptions as long as they are handled internally. Any function that is declared with throw() is supposed to cause the program to terminate immediately if it does try to throw an exception outside of itself, but implementation is spotty. Second, we can use a specific throw statement to denote that a function may throw a particular type of exception: int doSomething () throw ( double ); // may throw a double Finally, we can use a catch-all throw statement to denote that a function may throw an unspecified type of exception: int doSomething () throw (...); // may throw anything Due to the incomplete compiler implementation, the fact that exception specifiers are more like statements of intent than guarantees, some incompatibility with template functions, and the fact that most C++ programmers are unaware of their existence, I recommend you do not bother using dynamic exception specifiers. They were deprecated in C++11, and have been removed from the language in later versions. noexcept C++11 added a fourth exception specifier that is actually getting some use: noexcept. Noexcept is a exception specifier that is used to indicate that a function can not throw an exception. Semantically, it allows you to see at a glance that a function will not throw an exception. It also potentially enables some compiler optimizations. Destructors are generally implicitly noexcept (as they can\u2019t throw an exception). If a noexcept function does try to throw an exception, then std::terminate is called to terminate the application. Proper application of noexcept is non-trivial, and probably warrants its own lesson, so we\u2019ll leave it here -- as a mention that it exists, but as a topic for advanced users to explore further.","title":"14.4 \u672a\u6355\u83b7\u5f02\u5e38\uff0c\u6355\u83b7\u5168\u90e8\u5f02\u5e38\u548c\u5f02\u5e38\u8bf4\u660e\u7b26"},{"location":"14-exceptions/14.4-uncaught-exceptions-catch-all-handlers-and-exception-specifiers/#144","text":"By Alex on October 25 th , 2008 | last modified by nascardriver on June 19 th , 2020 By now, you should have a reasonable idea of how exceptions work. In this lesson, we\u2019ll cover a few more interesting exception cases. Uncaught exceptions In the past few examples, there are quite a few cases where a function assumes its caller (or another function somewhere up the call stack) will handle the exception. In the following example, mySqrt() assumes someone will handle the exception that it throws -- but what happens if nobody actually does? Here\u2019s our square root program again, minus the try block in main(): #include <iostream> #include <cmath> // for sqrt() function // A modular square root function double mySqrt ( double x ) { // If the user entered a negative number, this is an error condition if ( x < 0.0 ) throw \"Can not take sqrt of negative number\" ; // throw exception of type const char* return sqrt ( x ); } int main () { std :: cout << \"Enter a number: \" ; double x ; std :: cin >> x ; // Look ma, no exception handler! std :: cout << \"The sqrt of \" << x << \" is \" << mySqrt ( x ) << '\\n' ; return 0 ; } Now, let\u2019s say the user enters -4, and mySqrt(-4) raises an exception. Function mySqrt() doesn\u2019t handle the exception, so the program stack unwinds and control returns to main(). But there\u2019s no exception handler here either, so main() terminates. At this point, we just terminated our application! When main() terminates with an unhandled exception, the operating system will generally notify you that an unhandled exception error has occurred. How it does this depends on the operating system, but possibilities include printing an error message, popping up an error dialog, or simply crashing. Some OSes are less graceful than others. Generally this is something you want to avoid altogether! Catch-all handlers And now we find ourselves in a conundrum: functions can potentially throw exceptions of any data type, and if an exception is not caught, it will propagate to the top of your program and cause it to terminate. Since it\u2019s possible to call functions without knowing how they are even implemented (and thus, what type of exceptions they may throw), how can we possibly prevent this from happening? Fortunately, C++ provides us with a mechanism to catch all types of exceptions. This is known as a catch-all handler. A catch-all handler works just like a normal catch block, except that instead of using a specific type to catch, it uses the ellipses operator (\u2026) as the type to catch. If you recall from lesson 7.14 on ellipses and why to avoid them, ellipses were previously used to pass arguments of any type to a function. In this context, they represent exceptions of any data type. Here\u2019s an simple example: #include <iostream> int main () { try { throw 5 ; // throw an int exception } catch ( double x ) { std :: cout << \"We caught an exception of type double: \" << x << '\\n' ; } catch (...) // catch-all handler { std :: cout << \"We caught an exception of an undetermined type \\n \" ; } } Because there is no specific exception handler for type int, the catch-all handler catches this exception. This example produces the following result: We caught an exception of an undetermined type The catch-all handler should be placed last in the catch block chain. This is to ensure that exceptions can be caught by exception handlers tailored to specific data types if those handlers exist. Visual Studio enforces this constraint -- I am unsure if other compilers do. (Per reader Lonami in the comments below, GCC does too). Often, the catch-all handler block is left empty: catch (...) {} // ignore any unanticipated exceptions This will catch any unanticipated exceptions and prevent them from stack unwinding to the top of your program, but does no specific error handling. Using the catch-all handler to wrap main() One interesting use for the catch-all handler is to wrap the contents of main(): #include <iostream> int main () { try { runGame (); } catch (...) { std :: cerr << \"Abnormal termination \\n \" ; } saveState (); // Save user's game return 1 ; } In this case, if runGame() or any of the functions it calls throws an exception that is not caught, that exception will unwind up the stack and eventually get caught by this catch-all handler. This will prevent main() from terminating, and gives us a chance to print an error of our choosing and then save the user\u2019s state before exiting. This can be useful to catch and handle problems that may be unanticipated. Optional reading Dynamic exception specifiers This subsection should be considered optional reading because exception specifiers are rarely used in practice and have been removed from C++ in C++17 and C++20. Exception specifiers are a mechanism that allows us to use a function declaration to specify whether a function may or will not throw exceptions. This can be useful in determining whether a function call needs to be put inside a try block or not. There are three types of exception specifiers, all of which use what is called the throw (\u2026) syntax. First, we can use an empty throw statement to denote that a function does not throw any exceptions outside of itself: int doSomething () throw (); // does not throw exceptions Note that doSomething() can still use exceptions as long as they are handled internally. Any function that is declared with throw() is supposed to cause the program to terminate immediately if it does try to throw an exception outside of itself, but implementation is spotty. Second, we can use a specific throw statement to denote that a function may throw a particular type of exception: int doSomething () throw ( double ); // may throw a double Finally, we can use a catch-all throw statement to denote that a function may throw an unspecified type of exception: int doSomething () throw (...); // may throw anything Due to the incomplete compiler implementation, the fact that exception specifiers are more like statements of intent than guarantees, some incompatibility with template functions, and the fact that most C++ programmers are unaware of their existence, I recommend you do not bother using dynamic exception specifiers. They were deprecated in C++11, and have been removed from the language in later versions. noexcept C++11 added a fourth exception specifier that is actually getting some use: noexcept. Noexcept is a exception specifier that is used to indicate that a function can not throw an exception. Semantically, it allows you to see at a glance that a function will not throw an exception. It also potentially enables some compiler optimizations. Destructors are generally implicitly noexcept (as they can\u2019t throw an exception). If a noexcept function does try to throw an exception, then std::terminate is called to terminate the application. Proper application of noexcept is non-trivial, and probably warrants its own lesson, so we\u2019ll leave it here -- as a mention that it exists, but as a topic for advanced users to explore further.","title":"14.4 \u672a\u6355\u83b7\u5f02\u5e38\uff0c\u6355\u83b7\u5168\u90e8\u5f02\u5e38\u548c\u5f02\u5e38\u8bf4\u660e\u7b26"},{"location":"14-exceptions/14.5-exceptions-classes-and-inheritance/","text":"14.5 \u5f02\u5e38\uff0c\u7c7b\u548c\u7ee7\u627f \u00b6 By Alex on October 26 th , 2008 | last modified by nascardriver on May 20 th , 2020 Exceptions and member functions Up to this point in the tutorial, you\u2019ve only seen exceptions used in non-member functions. However, exceptions are equally useful in member functions, and even moreso in overloaded operators. Consider the following overloaded [] operator as part of a simple integer array class: int & IntArray :: operator []( const int index ) { return m_data [ index ]; } Although this function will work great as long as index is a valid array index, this function is sorely lacking in some good error checking. We could add an assert statement to ensure the index is valid: int & IntArray :: operator []( const int index ) { assert ( index >= 0 && index < getLength ()); return m_data [ index ]; } Now if the user passes in an invalid index, the program will cause an assertion error. While this is useful to indicate to the user that something went wrong, sometimes the better course of action is to fail silently and let the caller know something went wrong so they can deal with it as appropriate. Unfortunately, because overloaded operators have specific requirements as to the number and type of parameter(s) they can take and return, there is no flexibility for passing back error codes or boolean values to the caller. However, since exceptions do not change the signature of a function, they can be put to great use here. Here\u2019s an example: int & IntArray :: operator []( const int index ) { if ( index < 0 || index >= getLength ()) throw index ; return m_data [ index ]; } Now, if the user passes in an invalid index, operator[] will throw an int exception. When constructors fail Constructors are another area of classes in which exceptions can be very useful. If a constructor must fail for some reason (e.g. the user passed in invalid input), simply throw an exception to indicate the object failed to create. In such a case, the object\u2019s construction is aborted, and all class members (which have already been created and initialized prior to the body of the constructor executing) are destructed as per usual. However, the class\u2019s destructor is never called (because the object never finished construction). Because the destructor never executes, you can not rely on said destructor to clean up any resources that have already been allocated. Any such cleanup can happen in the constructor prior to throwing the exception in the first place. However, even better, because the members of the class are destructed as per usual, if you do the resource allocations in the members themselves, then those members can clean up after themselves when they are destructed. Here\u2019s an example: #include <iostream> class Member { public : Member () { std :: cerr << \"Member allocated some resources \\n \" ; } ~ Member () { std :: cerr << \"Member cleaned up \\n \" ; } }; class A { private : int m_x ; Member m_member ; public : A ( int x ) : m_x { x } { if ( x <= 0 ) throw 1 ; } ~ A () { std :: cerr << \"~A \\n \" ; // should not be called } }; int main () { try { A a { 0 }; } catch ( int ) { std :: cerr << \"Oops \\n \" ; } return 0 ; } This prints: Member allocated some resources Member cleaned up Oops In the above program, when class A throws an exception, all of the members of A are destructed. This gives m_member an opportunity to clean up any resources that were allocated. This is part of the reason that RAII (reference: 8.7 -- Destructors) is advocated so highly -- even in abnormal circumstances, classes that implement RAII properly should be able to clean up after themselves. Exception classes One of the major problems with using basic data types (such as int) as exception types is that they are inherently vague. An even bigger problem is disambiguation of what an exception means when there are multiple statements or function calls within a try block. // Using the IntArray overloaded operator[] above try { int * value { new int { array [ index1 ] + array [ index2 ]} }; } catch ( int value ) { // What are we catching here? } In this example, if we were to catch an int exception, what does that really tell us? Was one of the array indexes out of bounds? Did operator+ cause integer overflow? Did operator new fail because it ran out of memory? Unfortunately, in this case, there\u2019s just no easy way to disambiguate. While we can throw const char* exceptions to solve the problem of identifying WHAT went wrong, this still does not provide us the ability to handle exceptions from various sources differently. One way to solve this problem is to use exception classes. An exception class is just a normal class that is designed specifically to be thrown as an exception. Let\u2019s design a simple exception class to be used with our IntArray class: #include <string> class ArrayException { private : std :: string m_error ; public : ArrayException ( std :: string error ) : m_error { error } { } const char * getError () const { return m_error . c_str (); } }; Here\u2019s a full program using this class: #include <iostream> #include <string> class ArrayException { private : std :: string m_error ; public : ArrayException ( std :: string error ) : m_error ( error ) { } const char * getError () const { return m_error . c_str (); } }; class IntArray { private : int m_data [ 3 ]; // assume array is length 3 for simplicity public : IntArray () {} int getLength () const { return 3 ; } int & operator []( const int index ) { if ( index < 0 || index >= getLength ()) throw ArrayException ( \"Invalid index\" ); return m_data [ index ]; } }; int main () { IntArray array ; try { int value { array [ 5 ] }; } catch ( const ArrayException & exception ) { std :: cerr << \"An array exception occurred (\" << exception . getError () << \") \\n \" ; } } Using such a class, we can have the exception return a description of the problem that occurred, which provides context for what went wrong. And since ArrayException is its own unique type, we can specifically catch exceptions thrown by the array class and treat them differently from other exceptions if we wish. Note that exception handlers should catch class exception objects by reference instead of by value. This prevents the compiler from making a copy of the exception, which can be expensive when the exception is a class object, and prevents object slicing when dealing with derived exception classes (which we\u2019ll talk about in a moment). Catching exceptions by pointer should generally be avoided unless you have a specific reason to do so. Exceptions and inheritance Since it\u2019s possible to throw classes as exceptions, and classes can be derived from other classes, we need to consider what happens when we use inherited classes as exceptions. As it turns out, exception handlers will not only match classes of a specific type, they\u2019ll also match classes derived from that specific type as well! Consider the following example: class Base { public : Base () {} }; class Derived : public Base { public : Derived () {} }; int main () { try { throw Derived (); } catch ( const Base & base ) { std :: cerr << \"caught Base\" ; } catch ( const Derived & derived ) { std :: cerr << \"caught Derived\" ; } return 0 ; } In the above example we throw an exception of type Derived. However, the output of this program is: caught Base What happened? First, as mentioned above, derived classes will be caught by handlers for the base type. Because Derived is derived from Base, Derived is-a Base (they have an is-a relationship). Second, when C++ is attempting to find a handler for a raised exception, it does so sequentially. Consequently, the first thing C++ does is check whether the exception handler for Base matches the Derived exception. Because Derived is-a Base, the answer is yes, and it executes the catch block for type Base! The catch block for Derived is never even tested in this case. In order to make this example work as expected, we need to flip the order of the catch blocks: class Base { public : Base () {} }; class Derived : public Base { public : Derived () {} }; int main () { try { throw Derived (); } catch ( const Derived & derived ) { std :: cerr << \"caught Derived\" ; } catch ( const Base & base ) { std :: cerr << \"caught Base\" ; } return 0 ; } This way, the Derived handler will get first shot at catching objects of type Derived (before the handler for Base can). Objects of type Base will not match the Derived handler (Derived is-a Base, but Base is not a Derived), and thus will \u201cfall through\u201d to the Base handler. Rule: Handlers for derived exception classes should be listed before those for base classes. The ability to use a handler to catch exceptions of derived types using a handler for the base class turns out to be exceedingly useful. std::exception Many of the classes and operators in the standard library throw exception classes on failure. For example, operator new can throw std::bad_alloc if it is unable to allocate enough memory. A failed dynamic_cast will throw std::bad_cast. And so on. As of C++17, there are 25 different exception classes that can be thrown, with more being added in each subsequent language standard. The good news is that all of these exception classes are derived from a single class called std::exception. std::exception is a small interface class designed to serve as a base class to any exception thrown by the C++ standard library. Much of the time, when an exception is thrown by the standard library, we won\u2019t care whether it\u2019s a bad allocation, a bad cast, or something else. We just care that something catastrophic went wrong and now our program is exploding. Thanks to std::exception, we can set up an exception handler to catch exceptions of type std::exception, and we\u2019ll end up catching std::exception and all (21+) of the derived exceptions together in one place. Easy! #include <iostream> #include <exception> // for std::exception #include <string> // for this example int main () { try { // Your code using standard library goes here // We'll trigger one of these exceptions intentionally for the sake of example std :: string s ; s . resize ( - 1 ); // will trigger a std::length_error } // This handler will catch std::exception and all the derived exceptions too catch ( const std :: exception & exception ) { std :: cerr << \"Standard exception: \" << exception . what () << '\\n' ; } return 0 ; } The above program prints: Standard exception: string too long The above example should be pretty straightforward. The one thing worth noting is that std::exception has a virtual member function named what() that returns a C-style string description of the exception. Most derived classes override the what() function to change the message. Note that this string is meant to be used for descriptive text only -- do not use it for comparisons, as it is not guaranteed to be the same across compilers. Sometimes we\u2019ll want to handle a specific type of exception differently. In this case, we can add a handler for that specific type, and let all the others \u201cfall through\u201d to the base handler. Consider: try { // code using standard library goes here } // This handler will catch std::length_error (and any exceptions derived from it) here catch ( const std :: length_error & exception ) { std :: cerr << \"You ran out of memory!\" << '\\n' ; } // This handler will catch std::exception (and any exception derived from it) that fall // through here catch ( const std :: exception & exception ) { std :: cerr << \"Standard exception: \" << exception . what () << '\\n' ; } In this example, exceptions of type std::length_error will be caught by the first handler and handled there. Exceptions of type std::exception and all of the other derived classes will be caught by the second handler. Such inheritance hierarchies allow us to use specific handlers to target specific derived exception classes, or to use base class handlers to catch the whole hierarchy of exceptions. This allows us a fine degree of control over what kind of exceptions we want to handle while ensuring we don\u2019t have to do too much work to catch \u201ceverything else\u201d in a hierarchy. Using the standard exceptions directly Nothing throws a std::exception directly, and neither should you. However, you should feel free to throw the other standard exception classes in the standard library if they adequately represent your needs. You can find a list of all the standard exceptions on cppreference. std::runtime_error (included as part of the stdexcept header) is a popular choice, because it has a generic name, and its constructor takes a customizable message: #include <iostream> #include <stdexcept> int main () { try { throw std :: runtime_error ( \"Bad things happened\" ); } // This handler will catch std::exception and all the derived exceptions too catch ( const std :: exception & exception ) { std :: cerr << \"Standard exception: \" << exception . what () << '\\n' ; } return 0 ; } This prints: Standard exception: Bad things happened Deriving your own classes from std::exception You can, of course, derive your own classes from std::exception, and override the virtual what() const member function. Here\u2019s the same program as above, with ArrayException derived from std::exception: #include <iostream> #include <string> #include <exception> // for std::exception class ArrayException : public std :: exception { private : std :: string m_error ; public : ArrayException ( std :: string error ) : m_error { error } { } // return the std::string as a const C-style string // const char* what() const { return m_error.c_str(); } // pre-C++11 version const char * what () const noexcept { return m_error . c_str (); } // C++11 version }; class IntArray { private : int m_data [ 3 ]; // assume array is length 3 for simplicity public : IntArray () {} int getLength () const { return 3 ; } int & operator []( const int index ) { if ( index < 0 || index >= getLength ()) throw ArrayException ( \"Invalid index\" ); return m_data [ index ]; } }; int main () { IntArray array ; try { int value { array [ 5 ] }; } catch ( const ArrayException & exception ) // derived catch blocks go first { std :: cerr << \"An array exception occurred (\" << exception . what () << \") \\n \" ; } catch ( const std :: exception & exception ) { std :: cerr << \"Some other std::exception occurred (\" << exception . what () << \") \\n \" ; } } In C++11, virtual function what() was updated to have specifier noexcept (which means the function promises not to throw exceptions itself). Therefore, in C++11 and beyond, our override should also have specifier noexcept. It\u2019s up to you whether you want create your own standalone exception classes, use the standard exception classes, or derive your own exception classes from std::exception. All are valid approaches depending on your aims.","title":"14.5 \u5f02\u5e38\uff0c\u7c7b\u548c\u7ee7\u627f"},{"location":"14-exceptions/14.5-exceptions-classes-and-inheritance/#145","text":"By Alex on October 26 th , 2008 | last modified by nascardriver on May 20 th , 2020 Exceptions and member functions Up to this point in the tutorial, you\u2019ve only seen exceptions used in non-member functions. However, exceptions are equally useful in member functions, and even moreso in overloaded operators. Consider the following overloaded [] operator as part of a simple integer array class: int & IntArray :: operator []( const int index ) { return m_data [ index ]; } Although this function will work great as long as index is a valid array index, this function is sorely lacking in some good error checking. We could add an assert statement to ensure the index is valid: int & IntArray :: operator []( const int index ) { assert ( index >= 0 && index < getLength ()); return m_data [ index ]; } Now if the user passes in an invalid index, the program will cause an assertion error. While this is useful to indicate to the user that something went wrong, sometimes the better course of action is to fail silently and let the caller know something went wrong so they can deal with it as appropriate. Unfortunately, because overloaded operators have specific requirements as to the number and type of parameter(s) they can take and return, there is no flexibility for passing back error codes or boolean values to the caller. However, since exceptions do not change the signature of a function, they can be put to great use here. Here\u2019s an example: int & IntArray :: operator []( const int index ) { if ( index < 0 || index >= getLength ()) throw index ; return m_data [ index ]; } Now, if the user passes in an invalid index, operator[] will throw an int exception. When constructors fail Constructors are another area of classes in which exceptions can be very useful. If a constructor must fail for some reason (e.g. the user passed in invalid input), simply throw an exception to indicate the object failed to create. In such a case, the object\u2019s construction is aborted, and all class members (which have already been created and initialized prior to the body of the constructor executing) are destructed as per usual. However, the class\u2019s destructor is never called (because the object never finished construction). Because the destructor never executes, you can not rely on said destructor to clean up any resources that have already been allocated. Any such cleanup can happen in the constructor prior to throwing the exception in the first place. However, even better, because the members of the class are destructed as per usual, if you do the resource allocations in the members themselves, then those members can clean up after themselves when they are destructed. Here\u2019s an example: #include <iostream> class Member { public : Member () { std :: cerr << \"Member allocated some resources \\n \" ; } ~ Member () { std :: cerr << \"Member cleaned up \\n \" ; } }; class A { private : int m_x ; Member m_member ; public : A ( int x ) : m_x { x } { if ( x <= 0 ) throw 1 ; } ~ A () { std :: cerr << \"~A \\n \" ; // should not be called } }; int main () { try { A a { 0 }; } catch ( int ) { std :: cerr << \"Oops \\n \" ; } return 0 ; } This prints: Member allocated some resources Member cleaned up Oops In the above program, when class A throws an exception, all of the members of A are destructed. This gives m_member an opportunity to clean up any resources that were allocated. This is part of the reason that RAII (reference: 8.7 -- Destructors) is advocated so highly -- even in abnormal circumstances, classes that implement RAII properly should be able to clean up after themselves. Exception classes One of the major problems with using basic data types (such as int) as exception types is that they are inherently vague. An even bigger problem is disambiguation of what an exception means when there are multiple statements or function calls within a try block. // Using the IntArray overloaded operator[] above try { int * value { new int { array [ index1 ] + array [ index2 ]} }; } catch ( int value ) { // What are we catching here? } In this example, if we were to catch an int exception, what does that really tell us? Was one of the array indexes out of bounds? Did operator+ cause integer overflow? Did operator new fail because it ran out of memory? Unfortunately, in this case, there\u2019s just no easy way to disambiguate. While we can throw const char* exceptions to solve the problem of identifying WHAT went wrong, this still does not provide us the ability to handle exceptions from various sources differently. One way to solve this problem is to use exception classes. An exception class is just a normal class that is designed specifically to be thrown as an exception. Let\u2019s design a simple exception class to be used with our IntArray class: #include <string> class ArrayException { private : std :: string m_error ; public : ArrayException ( std :: string error ) : m_error { error } { } const char * getError () const { return m_error . c_str (); } }; Here\u2019s a full program using this class: #include <iostream> #include <string> class ArrayException { private : std :: string m_error ; public : ArrayException ( std :: string error ) : m_error ( error ) { } const char * getError () const { return m_error . c_str (); } }; class IntArray { private : int m_data [ 3 ]; // assume array is length 3 for simplicity public : IntArray () {} int getLength () const { return 3 ; } int & operator []( const int index ) { if ( index < 0 || index >= getLength ()) throw ArrayException ( \"Invalid index\" ); return m_data [ index ]; } }; int main () { IntArray array ; try { int value { array [ 5 ] }; } catch ( const ArrayException & exception ) { std :: cerr << \"An array exception occurred (\" << exception . getError () << \") \\n \" ; } } Using such a class, we can have the exception return a description of the problem that occurred, which provides context for what went wrong. And since ArrayException is its own unique type, we can specifically catch exceptions thrown by the array class and treat them differently from other exceptions if we wish. Note that exception handlers should catch class exception objects by reference instead of by value. This prevents the compiler from making a copy of the exception, which can be expensive when the exception is a class object, and prevents object slicing when dealing with derived exception classes (which we\u2019ll talk about in a moment). Catching exceptions by pointer should generally be avoided unless you have a specific reason to do so. Exceptions and inheritance Since it\u2019s possible to throw classes as exceptions, and classes can be derived from other classes, we need to consider what happens when we use inherited classes as exceptions. As it turns out, exception handlers will not only match classes of a specific type, they\u2019ll also match classes derived from that specific type as well! Consider the following example: class Base { public : Base () {} }; class Derived : public Base { public : Derived () {} }; int main () { try { throw Derived (); } catch ( const Base & base ) { std :: cerr << \"caught Base\" ; } catch ( const Derived & derived ) { std :: cerr << \"caught Derived\" ; } return 0 ; } In the above example we throw an exception of type Derived. However, the output of this program is: caught Base What happened? First, as mentioned above, derived classes will be caught by handlers for the base type. Because Derived is derived from Base, Derived is-a Base (they have an is-a relationship). Second, when C++ is attempting to find a handler for a raised exception, it does so sequentially. Consequently, the first thing C++ does is check whether the exception handler for Base matches the Derived exception. Because Derived is-a Base, the answer is yes, and it executes the catch block for type Base! The catch block for Derived is never even tested in this case. In order to make this example work as expected, we need to flip the order of the catch blocks: class Base { public : Base () {} }; class Derived : public Base { public : Derived () {} }; int main () { try { throw Derived (); } catch ( const Derived & derived ) { std :: cerr << \"caught Derived\" ; } catch ( const Base & base ) { std :: cerr << \"caught Base\" ; } return 0 ; } This way, the Derived handler will get first shot at catching objects of type Derived (before the handler for Base can). Objects of type Base will not match the Derived handler (Derived is-a Base, but Base is not a Derived), and thus will \u201cfall through\u201d to the Base handler. Rule: Handlers for derived exception classes should be listed before those for base classes. The ability to use a handler to catch exceptions of derived types using a handler for the base class turns out to be exceedingly useful. std::exception Many of the classes and operators in the standard library throw exception classes on failure. For example, operator new can throw std::bad_alloc if it is unable to allocate enough memory. A failed dynamic_cast will throw std::bad_cast. And so on. As of C++17, there are 25 different exception classes that can be thrown, with more being added in each subsequent language standard. The good news is that all of these exception classes are derived from a single class called std::exception. std::exception is a small interface class designed to serve as a base class to any exception thrown by the C++ standard library. Much of the time, when an exception is thrown by the standard library, we won\u2019t care whether it\u2019s a bad allocation, a bad cast, or something else. We just care that something catastrophic went wrong and now our program is exploding. Thanks to std::exception, we can set up an exception handler to catch exceptions of type std::exception, and we\u2019ll end up catching std::exception and all (21+) of the derived exceptions together in one place. Easy! #include <iostream> #include <exception> // for std::exception #include <string> // for this example int main () { try { // Your code using standard library goes here // We'll trigger one of these exceptions intentionally for the sake of example std :: string s ; s . resize ( - 1 ); // will trigger a std::length_error } // This handler will catch std::exception and all the derived exceptions too catch ( const std :: exception & exception ) { std :: cerr << \"Standard exception: \" << exception . what () << '\\n' ; } return 0 ; } The above program prints: Standard exception: string too long The above example should be pretty straightforward. The one thing worth noting is that std::exception has a virtual member function named what() that returns a C-style string description of the exception. Most derived classes override the what() function to change the message. Note that this string is meant to be used for descriptive text only -- do not use it for comparisons, as it is not guaranteed to be the same across compilers. Sometimes we\u2019ll want to handle a specific type of exception differently. In this case, we can add a handler for that specific type, and let all the others \u201cfall through\u201d to the base handler. Consider: try { // code using standard library goes here } // This handler will catch std::length_error (and any exceptions derived from it) here catch ( const std :: length_error & exception ) { std :: cerr << \"You ran out of memory!\" << '\\n' ; } // This handler will catch std::exception (and any exception derived from it) that fall // through here catch ( const std :: exception & exception ) { std :: cerr << \"Standard exception: \" << exception . what () << '\\n' ; } In this example, exceptions of type std::length_error will be caught by the first handler and handled there. Exceptions of type std::exception and all of the other derived classes will be caught by the second handler. Such inheritance hierarchies allow us to use specific handlers to target specific derived exception classes, or to use base class handlers to catch the whole hierarchy of exceptions. This allows us a fine degree of control over what kind of exceptions we want to handle while ensuring we don\u2019t have to do too much work to catch \u201ceverything else\u201d in a hierarchy. Using the standard exceptions directly Nothing throws a std::exception directly, and neither should you. However, you should feel free to throw the other standard exception classes in the standard library if they adequately represent your needs. You can find a list of all the standard exceptions on cppreference. std::runtime_error (included as part of the stdexcept header) is a popular choice, because it has a generic name, and its constructor takes a customizable message: #include <iostream> #include <stdexcept> int main () { try { throw std :: runtime_error ( \"Bad things happened\" ); } // This handler will catch std::exception and all the derived exceptions too catch ( const std :: exception & exception ) { std :: cerr << \"Standard exception: \" << exception . what () << '\\n' ; } return 0 ; } This prints: Standard exception: Bad things happened Deriving your own classes from std::exception You can, of course, derive your own classes from std::exception, and override the virtual what() const member function. Here\u2019s the same program as above, with ArrayException derived from std::exception: #include <iostream> #include <string> #include <exception> // for std::exception class ArrayException : public std :: exception { private : std :: string m_error ; public : ArrayException ( std :: string error ) : m_error { error } { } // return the std::string as a const C-style string // const char* what() const { return m_error.c_str(); } // pre-C++11 version const char * what () const noexcept { return m_error . c_str (); } // C++11 version }; class IntArray { private : int m_data [ 3 ]; // assume array is length 3 for simplicity public : IntArray () {} int getLength () const { return 3 ; } int & operator []( const int index ) { if ( index < 0 || index >= getLength ()) throw ArrayException ( \"Invalid index\" ); return m_data [ index ]; } }; int main () { IntArray array ; try { int value { array [ 5 ] }; } catch ( const ArrayException & exception ) // derived catch blocks go first { std :: cerr << \"An array exception occurred (\" << exception . what () << \") \\n \" ; } catch ( const std :: exception & exception ) { std :: cerr << \"Some other std::exception occurred (\" << exception . what () << \") \\n \" ; } } In C++11, virtual function what() was updated to have specifier noexcept (which means the function promises not to throw exceptions itself). Therefore, in C++11 and beyond, our override should also have specifier noexcept. It\u2019s up to you whether you want create your own standalone exception classes, use the standard exception classes, or derive your own exception classes from std::exception. All are valid approaches depending on your aims.","title":"14.5 \u5f02\u5e38\uff0c\u7c7b\u548c\u7ee7\u627f"},{"location":"14-exceptions/14.6-rethrowing-exceptions/","text":"14.6 \u5f02\u5e38\u7684\u518d\u629b\u51fa \u00b6 By Alex on February 5 th , 2017 | last modified by Alex on January 23 rd , 2020 Occasionally you may run into a case where you want to catch an exception, but not want to (or have the ability to) fully handle it at the point where you catch it. This is common when you want to log an error, but pass the issue along to the caller to actually handle. When a function can use a return code, this is simple. Consider the following example: Database * createDatabase ( std :: string filename ) { try { Database * d = new Database ( filename ); d -> open (); // assume this throws an int exception on failure return d ; } catch ( int exception ) { // Database creation failed // Write an error to some global logfile g_log . logError ( \"Creation of Database failed\" ); } return nullptr ; } In the above code snippet, the function is tasked with creating a Database object, opening the database, and returning the Database object. In the case where something goes wrong (e.g. the wrong filename is passed in), the exception handler logs an error, and then reasonably returns a null pointer. Now consider the following function: int getIntValueFromDatabase ( Database * d , std :: string table , std :: string key ) { assert ( d ); try { return d -> getIntValue ( table , key ); // throws int exception on failure } catch ( int exception ) { // Write an error to some global logfile g_log . logError ( \"doSomethingImportant failed\" ); // However, we haven't actually handled this error // So what do we do here? } } In the case where this function succeeds, it returns an integer value -- any integer value could be a valid value. But what about the case where something goes wrong with getIntValue()? In that case, getIntValue() will throw an integer exception, which will be caught by the catch block in getIntValueFromDatabase(), which will log the error. But then how do we tell the caller of getIntValueFromDatabase() that something went wrong? Unlike the top example, there isn\u2019t a good return code we can use here (because any integer return value could be a valid one). Throwing a new exception One obvious solution is to throw a new exception. int getIntValueFromDatabase ( Database * d , std :: string table , std :: string key ) { assert ( d ); try { return d -> getIntValue ( table , key ); // throws int exception on failure } catch ( int exception ) { // Write an error to some global logfile g_log . logError ( \"doSomethingImportant failed\" ); throw 'q' ; // throw char exception 'q' up the stack to be handled by caller of getIntValueFromDatabase() } } In the example above, the program catches the int exception from getIntValue(), logs the error, and then throws a new exception with char value \u2018q\u2019. Although it may seem weird to throw an exception from a catch block, this is allowed. Remember, only exceptions thrown within a try block are eligible to be caught. This means that an exception thrown within a catch block will not be caught by the catch block it\u2019s in. Instead, it will be propagated up the stack to the caller. The exception thrown from the catch block can be an exception of any type -- it doesn\u2019t need to be the same type as the exception that was just caught. Rethrowing an exception (the wrong way) Another option is to rethrow the same exception. One way to do this is as follows: int getIntValueFromDatabase ( Database * d , std :: string table , std :: string key ) { assert ( d ); try { return d -> getIntValue ( table , key ); // throws int exception on failure } catch ( int exception ) { // Write an error to some global logfile g_log . logError ( \"doSomethingImportant failed\" ); throw exception ; } } Although this works, this method has a couple of downsides. First, this doesn\u2019t throw the exact same exception as the one that is caught -- rather, it throws a copy-initialized copy of variable exception. Although the compiler is free to elide the copy, it may not, so this could be less performant. But significantly, consider what happens in the following case: int getIntValueFromDatabase ( Database * d , std :: string table , std :: string key ) { assert ( d ); try { return d -> getIntValue ( table , key ); // throws Derived exception on failure } catch ( Base & exception ) { // Write an error to some global logfile g_log . logError ( \"doSomethingImportant failed\" ); throw exception ; // Danger: this throws a Base object, not a Derived object } } In this case, getIntValue() throws a Derived object, but the catch block is catching a Base reference. This is fine, as we know we can have a Base reference to a Derived object. However, when we throw exception, the thrown exception is copy-initialized from variable exception. Variable exception has type Base, so the copy-initialized exception also has type Base (not Derived!). In other words, our Derived() object has been sliced! You can see this in the following program: #include <iostream> class Base { public : Base () {} virtual void print () { std :: cout << \"Base\" ; } }; class Derived : public Base { public : Derived () {} virtual void print () { std :: cout << \"Derived\" ; } }; int main () { try { try { throw Derived (); } catch ( Base & b ) { std :: cout << \"Caught Base b, which is actually a \" ; b . print (); std :: cout << \" \\n \" ; throw b ; // the Derived object gets sliced here } } catch ( Base & b ) { std :: cout << \"Caught Base b, which is actually a \" ; b . print (); std :: cout << \" \\n \" ; } return 0 ; } This prints: Caught Base b, which is actually a Derived Caught Base b, which is actually a Base The fact that the second line indicates that Base is actually a Base rather than a Derived proves that the Derived object was sliced. Rethrowing an exception (the right way) Fortunately, C++ provides a way to rethrow the exact same exception as the one that was just caught. To do so, simply use the throw keyword from within the catch block (with no associated variable), like so: #include <iostream> class Base { public : Base () {} virtual void print () { std :: cout << \"Base\" ; } }; class Derived : public Base { public : Derived () {} virtual void print () { std :: cout << \"Derived\" ; } }; int main () { try { try { throw Derived (); } catch ( Base & b ) { std :: cout << \"Caught Base b, which is actually a \" ; b . print (); std :: cout << \" \\n \" ; throw ; // note: We're now rethrowing the object here } } catch ( Base & b ) { std :: cout << \"Caught Base b, which is actually a \" ; b . print (); std :: cout << \" \\n \" ; } return 0 ; } This prints: Caught Base b, which is actually a Derived Caught Base b, which is actually a Derived This throw keyword that doesn\u2019t appear to throw anything in particular actually re-throws the exact same exception that was just caught. No copies are made, meaning we don\u2019t have to worry about performance killing copies or slicing. If rethrowing an exception is required, this method should be preferred over the alternatives. Rule: When rethrowing the same exception, use the throw keyword by itself.","title":"14.6 \u5f02\u5e38\u7684\u518d\u629b\u51fa"},{"location":"14-exceptions/14.6-rethrowing-exceptions/#146","text":"By Alex on February 5 th , 2017 | last modified by Alex on January 23 rd , 2020 Occasionally you may run into a case where you want to catch an exception, but not want to (or have the ability to) fully handle it at the point where you catch it. This is common when you want to log an error, but pass the issue along to the caller to actually handle. When a function can use a return code, this is simple. Consider the following example: Database * createDatabase ( std :: string filename ) { try { Database * d = new Database ( filename ); d -> open (); // assume this throws an int exception on failure return d ; } catch ( int exception ) { // Database creation failed // Write an error to some global logfile g_log . logError ( \"Creation of Database failed\" ); } return nullptr ; } In the above code snippet, the function is tasked with creating a Database object, opening the database, and returning the Database object. In the case where something goes wrong (e.g. the wrong filename is passed in), the exception handler logs an error, and then reasonably returns a null pointer. Now consider the following function: int getIntValueFromDatabase ( Database * d , std :: string table , std :: string key ) { assert ( d ); try { return d -> getIntValue ( table , key ); // throws int exception on failure } catch ( int exception ) { // Write an error to some global logfile g_log . logError ( \"doSomethingImportant failed\" ); // However, we haven't actually handled this error // So what do we do here? } } In the case where this function succeeds, it returns an integer value -- any integer value could be a valid value. But what about the case where something goes wrong with getIntValue()? In that case, getIntValue() will throw an integer exception, which will be caught by the catch block in getIntValueFromDatabase(), which will log the error. But then how do we tell the caller of getIntValueFromDatabase() that something went wrong? Unlike the top example, there isn\u2019t a good return code we can use here (because any integer return value could be a valid one). Throwing a new exception One obvious solution is to throw a new exception. int getIntValueFromDatabase ( Database * d , std :: string table , std :: string key ) { assert ( d ); try { return d -> getIntValue ( table , key ); // throws int exception on failure } catch ( int exception ) { // Write an error to some global logfile g_log . logError ( \"doSomethingImportant failed\" ); throw 'q' ; // throw char exception 'q' up the stack to be handled by caller of getIntValueFromDatabase() } } In the example above, the program catches the int exception from getIntValue(), logs the error, and then throws a new exception with char value \u2018q\u2019. Although it may seem weird to throw an exception from a catch block, this is allowed. Remember, only exceptions thrown within a try block are eligible to be caught. This means that an exception thrown within a catch block will not be caught by the catch block it\u2019s in. Instead, it will be propagated up the stack to the caller. The exception thrown from the catch block can be an exception of any type -- it doesn\u2019t need to be the same type as the exception that was just caught. Rethrowing an exception (the wrong way) Another option is to rethrow the same exception. One way to do this is as follows: int getIntValueFromDatabase ( Database * d , std :: string table , std :: string key ) { assert ( d ); try { return d -> getIntValue ( table , key ); // throws int exception on failure } catch ( int exception ) { // Write an error to some global logfile g_log . logError ( \"doSomethingImportant failed\" ); throw exception ; } } Although this works, this method has a couple of downsides. First, this doesn\u2019t throw the exact same exception as the one that is caught -- rather, it throws a copy-initialized copy of variable exception. Although the compiler is free to elide the copy, it may not, so this could be less performant. But significantly, consider what happens in the following case: int getIntValueFromDatabase ( Database * d , std :: string table , std :: string key ) { assert ( d ); try { return d -> getIntValue ( table , key ); // throws Derived exception on failure } catch ( Base & exception ) { // Write an error to some global logfile g_log . logError ( \"doSomethingImportant failed\" ); throw exception ; // Danger: this throws a Base object, not a Derived object } } In this case, getIntValue() throws a Derived object, but the catch block is catching a Base reference. This is fine, as we know we can have a Base reference to a Derived object. However, when we throw exception, the thrown exception is copy-initialized from variable exception. Variable exception has type Base, so the copy-initialized exception also has type Base (not Derived!). In other words, our Derived() object has been sliced! You can see this in the following program: #include <iostream> class Base { public : Base () {} virtual void print () { std :: cout << \"Base\" ; } }; class Derived : public Base { public : Derived () {} virtual void print () { std :: cout << \"Derived\" ; } }; int main () { try { try { throw Derived (); } catch ( Base & b ) { std :: cout << \"Caught Base b, which is actually a \" ; b . print (); std :: cout << \" \\n \" ; throw b ; // the Derived object gets sliced here } } catch ( Base & b ) { std :: cout << \"Caught Base b, which is actually a \" ; b . print (); std :: cout << \" \\n \" ; } return 0 ; } This prints: Caught Base b, which is actually a Derived Caught Base b, which is actually a Base The fact that the second line indicates that Base is actually a Base rather than a Derived proves that the Derived object was sliced. Rethrowing an exception (the right way) Fortunately, C++ provides a way to rethrow the exact same exception as the one that was just caught. To do so, simply use the throw keyword from within the catch block (with no associated variable), like so: #include <iostream> class Base { public : Base () {} virtual void print () { std :: cout << \"Base\" ; } }; class Derived : public Base { public : Derived () {} virtual void print () { std :: cout << \"Derived\" ; } }; int main () { try { try { throw Derived (); } catch ( Base & b ) { std :: cout << \"Caught Base b, which is actually a \" ; b . print (); std :: cout << \" \\n \" ; throw ; // note: We're now rethrowing the object here } } catch ( Base & b ) { std :: cout << \"Caught Base b, which is actually a \" ; b . print (); std :: cout << \" \\n \" ; } return 0 ; } This prints: Caught Base b, which is actually a Derived Caught Base b, which is actually a Derived This throw keyword that doesn\u2019t appear to throw anything in particular actually re-throws the exact same exception that was just caught. No copies are made, meaning we don\u2019t have to worry about performance killing copies or slicing. If rethrowing an exception is required, this method should be preferred over the alternatives. Rule: When rethrowing the same exception, use the throw keyword by itself.","title":"14.6 \u5f02\u5e38\u7684\u518d\u629b\u51fa"},{"location":"14-exceptions/14.7-function-try-blocks/","text":"14.7 \u51fd\u6570\u7ea7\u7684 try \u4ee3\u7801\u5757 \u00b6 By Alex on February 6 th , 2017 | last modified by Alex on January 23 rd , 2020 Try and catch blocks work well enough in most cases, but there is one particular case in which they are not sufficient. Consider the following example: class A { private : int m_x ; public : A ( int x ) : m_x ( x ) { if ( x <= 0 ) throw 1 ; } }; class B : public A { public : B ( int x ) : A ( x ) { // What happens if creation of A fails and we want to handle it here? } }; int main () { try { B b ( 0 ); } catch ( int ) { std :: cout << \"Oops \\n \" ; } } In the above example, derived class B calls base class constructor A, which can throw an exception. Because the creation of object b has been placed inside a try block (in function main()), if A throws an exception, main\u2019s try block will catch it. Consequently, this program prints: Oops But what if we want to catch the exception inside of B? The call to base constructor A happens via the member initialization list, before the B constructor\u2019s body is called. There\u2019s no way to wrap a standard try block around it. In this situation, we have to use a slightly modified try block called a function try block. Function try blocks Function try blocks are designed to allow you to establish an exception handler around the body of an entire function, rather than around a block of code. The syntax for function try blocks is a little hard to describe, so we\u2019ll show by example: #include <iostream> class A { private : int m_x ; public : A ( int x ) : m_x ( x ) { if ( x <= 0 ) throw 1 ; } }; class B : public A { public : B ( int x ) try : A ( x ) // note addition of try keyword here { } catch (...) // note this is at same level of indentation as the function itself { // Exceptions from member initializer list or constructor body are caught here std :: cerr << \"Exception caught \\n \" ; // If an exception isn't explicitly thrown here, the current exception will be implicitly rethrown } }; int main () { try { B b ( 0 ); } catch ( int ) { std :: cout << \"Oops \\n \" ; } } When this program is run, it produces the output: Exception caught Oops Let\u2019s examine this program in more detail. First, note the addition of the \u201ctry\u201d keyword before the member initializer list. This indicates that everything after that point (until the end of the function) should be considered inside of the try block. Second, note that the associated catch block is at the same level of indentation as the entire function. Any exception thrown between the try keyword and the end of the function body will be eligible to be caught here. Finally, unlike normal catch blocks, which allow you to either resolve an exception, throw a new exception, or rethrow an existing exception, with function-level try blocks, you must throw or rethrow an exception. If you do not explicitly throw a new exception, or rethrow the current exception (using the throw keyword by itself), the exception will be implicitly rethrown up the stack. In the program above, because we did not explicitly throw an exception from the function-level catch block, the exception was implicitly rethrown, and was caught by the catch block in main(). This is the reason why the above program prints \u201cOops\u201d! Although function level try blocks can be used with non-member functions as well, they typically aren\u2019t because there\u2019s rarely a case where this would be needed. They are almost exclusively used with constructors! Function try blocks can catch both base and the current class exceptions In the above example, if either A or B\u2019s constructor throw an exception, it will be caught by the try block around B\u2019s constructor. We can see that in the following example, where we\u2019re throwing an exception from class B instead of class A: #include <iostream> class A { private : int m_x ; public : A ( int x ) : m_x ( x ) { } }; class B : public A { public : B ( int x ) try : A ( x ) // note addition of try keyword here { if ( x <= 0 ) // moved this from A to B throw 1 ; // and this too } catch (...) { std :: cerr << \"Exception caught \\n \" ; // If an exception isn't explicitly thrown here, the current exception will be implicitly rethrown } }; int main () { try { B b ( 0 ); } catch ( int ) { std :: cout << \"Oops \\n \" ; } } We get the same output: Exception caught Oops Don\u2019t use function try to clean up resources When construction of an object fails, the destructor of the class is not called. Consequently, you may be tempted to use a function try block as a way to clean up a class that had partially allocated resources before failing. However, referring to members of the failed object is considered undefined behavior since the object is \u201cdead\u201d before the catch block executes. This means that you can\u2019t use function try to clean up after a class. If you want to clean up after a class, follow the standard rules for cleaning up classes that throw exceptions (see the \u201cWhen constructor fail\u201d subsection of lesson 14.5 -- Exceptions, classes, and inheritance). Function try is useful primarily for either logging failures before passing the exception up the stack, or for changing the type of exception thrown","title":"14.7 \u51fd\u6570\u7ea7\u7684 try \u4ee3\u7801\u5757"},{"location":"14-exceptions/14.7-function-try-blocks/#147-try","text":"By Alex on February 6 th , 2017 | last modified by Alex on January 23 rd , 2020 Try and catch blocks work well enough in most cases, but there is one particular case in which they are not sufficient. Consider the following example: class A { private : int m_x ; public : A ( int x ) : m_x ( x ) { if ( x <= 0 ) throw 1 ; } }; class B : public A { public : B ( int x ) : A ( x ) { // What happens if creation of A fails and we want to handle it here? } }; int main () { try { B b ( 0 ); } catch ( int ) { std :: cout << \"Oops \\n \" ; } } In the above example, derived class B calls base class constructor A, which can throw an exception. Because the creation of object b has been placed inside a try block (in function main()), if A throws an exception, main\u2019s try block will catch it. Consequently, this program prints: Oops But what if we want to catch the exception inside of B? The call to base constructor A happens via the member initialization list, before the B constructor\u2019s body is called. There\u2019s no way to wrap a standard try block around it. In this situation, we have to use a slightly modified try block called a function try block. Function try blocks Function try blocks are designed to allow you to establish an exception handler around the body of an entire function, rather than around a block of code. The syntax for function try blocks is a little hard to describe, so we\u2019ll show by example: #include <iostream> class A { private : int m_x ; public : A ( int x ) : m_x ( x ) { if ( x <= 0 ) throw 1 ; } }; class B : public A { public : B ( int x ) try : A ( x ) // note addition of try keyword here { } catch (...) // note this is at same level of indentation as the function itself { // Exceptions from member initializer list or constructor body are caught here std :: cerr << \"Exception caught \\n \" ; // If an exception isn't explicitly thrown here, the current exception will be implicitly rethrown } }; int main () { try { B b ( 0 ); } catch ( int ) { std :: cout << \"Oops \\n \" ; } } When this program is run, it produces the output: Exception caught Oops Let\u2019s examine this program in more detail. First, note the addition of the \u201ctry\u201d keyword before the member initializer list. This indicates that everything after that point (until the end of the function) should be considered inside of the try block. Second, note that the associated catch block is at the same level of indentation as the entire function. Any exception thrown between the try keyword and the end of the function body will be eligible to be caught here. Finally, unlike normal catch blocks, which allow you to either resolve an exception, throw a new exception, or rethrow an existing exception, with function-level try blocks, you must throw or rethrow an exception. If you do not explicitly throw a new exception, or rethrow the current exception (using the throw keyword by itself), the exception will be implicitly rethrown up the stack. In the program above, because we did not explicitly throw an exception from the function-level catch block, the exception was implicitly rethrown, and was caught by the catch block in main(). This is the reason why the above program prints \u201cOops\u201d! Although function level try blocks can be used with non-member functions as well, they typically aren\u2019t because there\u2019s rarely a case where this would be needed. They are almost exclusively used with constructors! Function try blocks can catch both base and the current class exceptions In the above example, if either A or B\u2019s constructor throw an exception, it will be caught by the try block around B\u2019s constructor. We can see that in the following example, where we\u2019re throwing an exception from class B instead of class A: #include <iostream> class A { private : int m_x ; public : A ( int x ) : m_x ( x ) { } }; class B : public A { public : B ( int x ) try : A ( x ) // note addition of try keyword here { if ( x <= 0 ) // moved this from A to B throw 1 ; // and this too } catch (...) { std :: cerr << \"Exception caught \\n \" ; // If an exception isn't explicitly thrown here, the current exception will be implicitly rethrown } }; int main () { try { B b ( 0 ); } catch ( int ) { std :: cout << \"Oops \\n \" ; } } We get the same output: Exception caught Oops Don\u2019t use function try to clean up resources When construction of an object fails, the destructor of the class is not called. Consequently, you may be tempted to use a function try block as a way to clean up a class that had partially allocated resources before failing. However, referring to members of the failed object is considered undefined behavior since the object is \u201cdead\u201d before the catch block executes. This means that you can\u2019t use function try to clean up after a class. If you want to clean up after a class, follow the standard rules for cleaning up classes that throw exceptions (see the \u201cWhen constructor fail\u201d subsection of lesson 14.5 -- Exceptions, classes, and inheritance). Function try is useful primarily for either logging failures before passing the exception up the stack, or for changing the type of exception thrown","title":"14.7 \u51fd\u6570\u7ea7\u7684 try \u4ee3\u7801\u5757"},{"location":"14-exceptions/14.8-exception-dangers-and-downsides/","text":"14.8 \u5f02\u5e38\u7684\u5371\u9669\u548c\u7f3a\u70b9 \u00b6 By Alex on October 26 th , 2008 | last modified by nascardriver on July 2 nd , 2020 As with almost everything that has benefits, there are some potential downsides to exceptions as well. This article is not meant to be comprehensive, but just to point out some of the major issues that should be considered when using exceptions (or deciding whether to use them). Cleaning up resources One of the biggest problems that new programmers run into when using exceptions is the issue of cleaning up resources when an exception occurs. Consider the following example: try { openFile ( filename ); writeFile ( filename , data ); closeFile ( filename ); } catch ( const FileException & exception ) { std :: cerr << \"Failed to write to file: \" << exception . what () << '\\n' ; } What happens if WriteFile() fails and throws a FileException? At this point, we\u2019ve already opened the file, and now control flow jumps to the FileException handler, which prints an error and exits. Note that the file was never closed! This example should be rewritten as follows: try { openFile ( filename ); writeFile ( filename , data ); closeFile ( filename ); } catch ( const FileException & exception ) { // Make sure file is closed closeFile ( filename ); // Then write error std :: cerr << \"Failed to write to file: \" << exception . what () << '\\n' ; } This kind of error often crops up in another form when dealing with dynamically allocated memory: try { auto * john { new Person { \"John\" , 18 , PERSON_MALE } }; processPerson ( john ); delete john ; } catch ( const PersonException & exception ) { std :: cerr << \"Failed to process person: \" << exception . what () << '\\n' ; } If processPerson() throws an exception, control flow jumps to the catch handler. As a result, john is never deallocated! This example is a little more tricky than the previous one -- because john is local to the try block, it goes out of scope when the try block exits. That means the exception handler can not access john at all (its been destroyed already), so there\u2019s no way for it to deallocate the memory. However, there are two relatively easy ways to fix this. First, declare john outside of the try block so it does not go out of scope when the try block exits: Person * john { nullptr }; try { john = new Person ( \"John\" , 18 , PERSON_MALE ); processPerson ( john ); delete john ; } catch ( const PersonException & exception ) { delete john ; std :: cerr << \"Failed to process person: \" << exception . what () << '\\n' ; } Because john is declared outside the try block, it is accessible both within the try block and the catch handlers. This means the catch handler can do cleanup properly. The second way is to use a local variable of a class that knows how to cleanup itself when it goes out of scope (often called a \u201csmart pointer\u201d). The standard library provides a class called std::unique_ptr that can be used for this purpose. std::unique_ptr is a template class that holds a pointer, and deallocates it when it goes out of scope. #include <memory> // for std::unique_ptr try { auto * john { new Person ( \"John\" , 18 , PERSON_MALE ) }; std :: unique_ptr < Person > upJohn { john }; // upJohn now owns john ProcessPerson ( john ); // when upJohn goes out of scope, it will delete john } catch ( const PersonException & exception ) { std :: cerr << \"Failed to process person: \" << exception . what () << '\\n' ; } We\u2019ll talk more about smart pointers in the next chapter. Exceptions and destructors Unlike constructors, where throwing exceptions can be a useful way to indicate that object creation did not succeed, exceptions should never be thrown in destructors. The problem occurs when an exception is thrown from a destructor during the stack unwinding process. If that happens, the compiler is put in a situation where it doesn\u2019t know whether to continue the stack unwinding process or handle the new exception. The end result is that your program will be terminated immediately. Consequently, the best course of action is just to abstain from using exceptions in destructors altogether. Write a message to a log file instead. Performance concerns Exceptions do come with a small performance price to pay. They increase the size of your executable, and they may also cause it to run slower due to the additional checking that has to be performed. However, the main performance penalty for exceptions happens when an exception is actually thrown. In this case, the stack must be unwound and an appropriate exception handler found, which is a relatively expensive operation. As a note, some modern computer architectures support an exception model called zero-cost exceptions. Zero-cost exceptions, if supported, have no additional runtime cost in the non-error case (which is the case we most care about performance). However, they incur an even larger penalty in the case where an exception is found. So when should I use exceptions? Exception handling is best used when all of the following are true: The error being handled is likely to occur only infrequently. The error is serious and execution could not continue otherwise. The error cannot be handled at the place where it occurs. There isn\u2019t a good alternative way to return an error code back to the caller. As an example, let\u2019s consider the case where you\u2019ve written a function that expects the user to pass in the name of a file on disk. Your function will open this file, read some data, close the file, and pass back some result to the caller. Now, let\u2019s say the user passes in the name of a file that doesn\u2019t exist, or a null string. Is this a good candidate for an exception? In this case, the first two bullets above are trivially met -- this isn\u2019t something that\u2019s going to happen often, and your function can\u2019t calculate a result when it doesn\u2019t have any data to work with. The function can\u2019t handle the error either -- it\u2019s not the job of the function to re-prompt the user for a new filename, and that might not even be appropriate, depending on how your program is designed. The fourth bullet is the key -- is there a good alternative way to return an error code back to the caller? It depends on the details of your program. If so (e.g. you can return a null pointer, or a status code to indicate failure), that\u2019s probably the better choice. If not, then an exception would be reasonable.","title":"14.8 \u5f02\u5e38\u7684\u5371\u9669\u548c\u7f3a\u70b9"},{"location":"14-exceptions/14.8-exception-dangers-and-downsides/#148","text":"By Alex on October 26 th , 2008 | last modified by nascardriver on July 2 nd , 2020 As with almost everything that has benefits, there are some potential downsides to exceptions as well. This article is not meant to be comprehensive, but just to point out some of the major issues that should be considered when using exceptions (or deciding whether to use them). Cleaning up resources One of the biggest problems that new programmers run into when using exceptions is the issue of cleaning up resources when an exception occurs. Consider the following example: try { openFile ( filename ); writeFile ( filename , data ); closeFile ( filename ); } catch ( const FileException & exception ) { std :: cerr << \"Failed to write to file: \" << exception . what () << '\\n' ; } What happens if WriteFile() fails and throws a FileException? At this point, we\u2019ve already opened the file, and now control flow jumps to the FileException handler, which prints an error and exits. Note that the file was never closed! This example should be rewritten as follows: try { openFile ( filename ); writeFile ( filename , data ); closeFile ( filename ); } catch ( const FileException & exception ) { // Make sure file is closed closeFile ( filename ); // Then write error std :: cerr << \"Failed to write to file: \" << exception . what () << '\\n' ; } This kind of error often crops up in another form when dealing with dynamically allocated memory: try { auto * john { new Person { \"John\" , 18 , PERSON_MALE } }; processPerson ( john ); delete john ; } catch ( const PersonException & exception ) { std :: cerr << \"Failed to process person: \" << exception . what () << '\\n' ; } If processPerson() throws an exception, control flow jumps to the catch handler. As a result, john is never deallocated! This example is a little more tricky than the previous one -- because john is local to the try block, it goes out of scope when the try block exits. That means the exception handler can not access john at all (its been destroyed already), so there\u2019s no way for it to deallocate the memory. However, there are two relatively easy ways to fix this. First, declare john outside of the try block so it does not go out of scope when the try block exits: Person * john { nullptr }; try { john = new Person ( \"John\" , 18 , PERSON_MALE ); processPerson ( john ); delete john ; } catch ( const PersonException & exception ) { delete john ; std :: cerr << \"Failed to process person: \" << exception . what () << '\\n' ; } Because john is declared outside the try block, it is accessible both within the try block and the catch handlers. This means the catch handler can do cleanup properly. The second way is to use a local variable of a class that knows how to cleanup itself when it goes out of scope (often called a \u201csmart pointer\u201d). The standard library provides a class called std::unique_ptr that can be used for this purpose. std::unique_ptr is a template class that holds a pointer, and deallocates it when it goes out of scope. #include <memory> // for std::unique_ptr try { auto * john { new Person ( \"John\" , 18 , PERSON_MALE ) }; std :: unique_ptr < Person > upJohn { john }; // upJohn now owns john ProcessPerson ( john ); // when upJohn goes out of scope, it will delete john } catch ( const PersonException & exception ) { std :: cerr << \"Failed to process person: \" << exception . what () << '\\n' ; } We\u2019ll talk more about smart pointers in the next chapter. Exceptions and destructors Unlike constructors, where throwing exceptions can be a useful way to indicate that object creation did not succeed, exceptions should never be thrown in destructors. The problem occurs when an exception is thrown from a destructor during the stack unwinding process. If that happens, the compiler is put in a situation where it doesn\u2019t know whether to continue the stack unwinding process or handle the new exception. The end result is that your program will be terminated immediately. Consequently, the best course of action is just to abstain from using exceptions in destructors altogether. Write a message to a log file instead. Performance concerns Exceptions do come with a small performance price to pay. They increase the size of your executable, and they may also cause it to run slower due to the additional checking that has to be performed. However, the main performance penalty for exceptions happens when an exception is actually thrown. In this case, the stack must be unwound and an appropriate exception handler found, which is a relatively expensive operation. As a note, some modern computer architectures support an exception model called zero-cost exceptions. Zero-cost exceptions, if supported, have no additional runtime cost in the non-error case (which is the case we most care about performance). However, they incur an even larger penalty in the case where an exception is found. So when should I use exceptions? Exception handling is best used when all of the following are true: The error being handled is likely to occur only infrequently. The error is serious and execution could not continue otherwise. The error cannot be handled at the place where it occurs. There isn\u2019t a good alternative way to return an error code back to the caller. As an example, let\u2019s consider the case where you\u2019ve written a function that expects the user to pass in the name of a file on disk. Your function will open this file, read some data, close the file, and pass back some result to the caller. Now, let\u2019s say the user passes in the name of a file that doesn\u2019t exist, or a null string. Is this a good candidate for an exception? In this case, the first two bullets above are trivially met -- this isn\u2019t something that\u2019s going to happen often, and your function can\u2019t calculate a result when it doesn\u2019t have any data to work with. The function can\u2019t handle the error either -- it\u2019s not the job of the function to re-prompt the user for a new filename, and that might not even be appropriate, depending on how your program is designed. The fourth bullet is the key -- is there a good alternative way to return an error code back to the caller? It depends on the details of your program. If so (e.g. you can return a null pointer, or a status code to indicate failure), that\u2019s probably the better choice. If not, then an exception would be reasonable.","title":"14.8 \u5f02\u5e38\u7684\u5371\u9669\u548c\u7f3a\u70b9"},{"location":"15-move-semantics-and-smart-pointers/","text":"15 \u79fb\u52a8\u8bed\u4e49\u548c\u667a\u80fd\u6307\u9488 \u00b6","title":"15 \u79fb\u52a8\u8bed\u4e49\u548c\u667a\u80fd\u6307\u9488"},{"location":"15-move-semantics-and-smart-pointers/#15","text":"","title":"15 \u79fb\u52a8\u8bed\u4e49\u548c\u667a\u80fd\u6307\u9488"},{"location":"15-move-semantics-and-smart-pointers/15.1-intro-to-smart-pointers-and-move-semantics/","text":"15.1 \u667a\u80fd\u6307\u9488\u548c\u79fb\u52a8\u8bed\u4e49\u7684\u4ecb\u7ecd \u00b6 By Alex on February 17 th , 2017 | last modified by nascardriver on April 25 th , 2020 \u7ffb\u8bd1by dashjay 2020.7.14 \u601d\u8003\u4e0b\u5217\u51fd\u6570\uff0c\u5728\u8fd9\u4e2a\u51fd\u6570\u4e2d\u6211\u4eec\u52a8\u6001\u5206\u914d\u4e86\u4e00\u4e2a\u503c void someFunction () { Resource * ptr = new Resource ; // Resource is a struct or class \u3010\u8d44\u6e90\u662f\u4e00\u4e2a\u7ed3\u6784\u6216\u8005\u7c7b\u3011 // do stuff with ptr here \u3010\u4f7f\u7528\u6307\u9488\u5728\u8fd9\u91cc\u505a\u4e00\u4e9b\u4e8b\u3011 delete ptr ; } \u7ecf\u7ba1\u4ee5\u4e0a\u4ee3\u7801\u770b\u8d77\u6765\u5f88\u76f4\u63a5\u7b80\u5355\uff0c\u4f46\u662f\u4e5f\u76f8\u5f53\u5bb9\u6613\u5fd8\u8bb0\u53bb\u91ca\u653e\u6307\u9488\u3002\u5373\u4fbf\u4f60\u786e\u5b9e\u8bb0\u5f97\u5728\u51fd\u6570\u672b\u5c3e\u91ca\u653e\u6307\u9488\uff0c\u4e5f\u6709\u65e0\u6570\u79cd\u60c5\u51b5\u5bfc\u81f4\u6307\u9488\u6ca1\u6709\u88ab\u5220\u9664\uff0c\u5982\u679c\u51fd\u6570\u63d0\u524d\u9000\u51fa\u7684\u8bdd\u3002\u8fd9\u5f88\u53ef\u80fd\u53d1\u751f\u901a\u8fc7\u4e00\u4e2a early return : # include <iostream> void someFunction () { Resource * ptr = new Resource ; int x ; std :: cout << \"Enter an integer: \" ; std :: cin >> x ; if ( x == 0 ) return ; // the function returns early, and ptr won\u2019t be deleted! // do stuff with ptr here delete ptr ; } or via a thrown exception: \u6216\u8005\u901a\u8fc7\u4e00\u4e2a\u5f02\u5e38\u7684\u629b\u51fa # include <iostream> void someFunction () { Resource * ptr = new Resource ; int x ; std :: cout << \"Enter an integer: \" ; std :: cin >> x ; if ( x == 0 ) throw 0 ; // the function returns early, and ptr won\u2019t be deleted! // do stuff with ptr here delete ptr ; } \u5728\u4ee5\u4e0a\u7684\u4e24\u4e2a\u7a0b\u5e8f\u4e2d\uff0c\u63d0\u524d\u9000\u51fa\u6216\u8005\u629b\u51fa\u8bed\u53e5\u6267\u884c\u90fd\u4f1a\u9020\u6210\u51fd\u6570\u7ec8\u6b62\uff0c\u5e76\u4e14\u672a\u91ca\u653e ptr \u6307\u9488\u3002\u56e0\u6b64\uff0c\u4e3a\u53d8\u91cf ptr \u5206\u914d\u7684\u5185\u5b58\u5c31\u4f1a\u91ca\u653e\uff08\u5e76\u4e14\u5c06\u6bcf\u6b21\u8c03\u7528\u8be5\u51fd\u6570\u65f6\uff0c\u6cc4\u9732\u4e00\u6b21\uff0c\u5982\u679c\u63d0\u524d\u9000\u51fa\u7684\u8bdd\uff09\u3002 \u672c\u6307\u4e0a\uff0c\u8fd9\u4e9b\u79cd\u7c7b\u7684\u95ee\u9898\u4e4b\u6240\u4ee5\u4f1a\u53d1\u751f\uff0c\u662f\u662f\u56e0\u4e3a\u6307\u9488\u53d8\u91cf\u6ca1\u6709\u56fa\u6709\u7684\u673a\u5236\u6765\u6e05\u7406\u4ed6\u4eec\u81ea\u5df1\u3002 \u667a\u80fd\u6307\u9488\u80fd\u62ef\u6551\u4e00\u5207\u4e48 \u00b6 \u4e00\u4e2a\u7c7b\u6700\u68d2\u7684\u4e8b\u4e4b\u4e00\u5c31\u662f\u5305\u542b\u4e00\u4e2a\u89e3\u6784\u51fd\u6570\u4f1a\u81ea\u52a8\u6267\u884c\uff0c\u5f53\u8fd9\u4e2a\u7c7b\u5bf9\u8c61\u8131\u79bb\u4f5c\u7528\u57df\u540e\u3002\u56e0\u6b64\u5982\u679c\u4f60\u5206\u914d\uff08\u6216\u5f97\u5230\uff09\u5185\u5b58\u5728\u4f60\u7684\u6784\u9020\u51fd\u6570\u4e2d\uff0c\u4f60\u53ef\u4ee5\u91ca\u653e\u4ed6\u4eec\u5728\u4f60\u7684\u6790\u6784\u51fd\u6570\uff0c\u5e76\u4e14\u4fdd\u8bc1\u5185\u5b58\u5c06\u4f1a\u88ab\u91ca\u653e\u5f53\u8fd9\u4e2a\u5bf9\u8c61\u88ab\u9500\u6bc1\uff08\u53ef\u4ee5\u662f\u79bb\u5f00\u4f5c\u7528\u4e8e\u6216\u8005\u663e\u5f0f\u7684\u5220\u9664\uff0c\u7b49\u7b49\u2026\u2026\uff09\u3002\u8fd9\u662f RAII \u7f16\u7a0b\u7684\u6838\u5fc3\uff0c\u6211\u4eec\u5728 8.7 \u8bfe\u8ba8\u8bba\u8fc7\u7684 \u2014\u2014 \u7ed3\u6784\u51fd\u6570 \u3002 \u8fd9\u6837\u8bf4\u6765\uff0c\u6211\u4eec\u662f\u5426\u80fd\u7528\u4e00\u4e2a\u7c7b\u6765\u5e2e\u52a9\u6211\u4eec\u7ba1\u7406\u6216\u8005\u6e05\u7406\u6211\u4eec\u7684\u6307\u9488\uff1f\u5f53\u7136\u53ef\u4ee5\uff01 \u601d\u8003\u5982\u679c\u6709\u8fd9\u6837\u4e00\u4e2a\u7c7b\uff0c\u5b83\u6240\u6709\u7684\u5de5\u4f5c\u5c31\u662f\u6301\u6709\u548c\u201d\u62e5\u6709\u201c\u4e00\u4e2a\u4f20\u7ed9\u4ed6\u7684\u6307\u9488\uff0c\u5e76\u4e14\u5f53\u8be5\u7c7b\u7684\u5bf9\u8c61\u79bb\u5f00\u4f5c\u7528\u57df\u540e\u5c31\u4f1a\u91ca\u653e\u90a3\u4e2a\u6301\u6709\u7684\u6307\u9488\u3002\u53ea\u8981\u90a3\u4e2a\u7c7b\u7684\u5bf9\u8c61\u4ec5\u4ec5\u88ab\u521b\u5efa\u4f5c\u4e3a\u5c40\u90e8\u53d8\u91cf\uff0c\u6211\u4eec\u53ef\u4ee5\u4fdd\u8bc1\u8be5\u7c7b\u5c06\u4f1a\u4ee5\u6070\u5f53\u7684\u65b9\u5f0f\uff08properly\uff09\u7684\u79bb\u5f00\u4f5c\u7528\u57df\uff08\u53ef\u4ee5\u89c6\u4e3a\u6211\u4eec\u7684\u51fd\u6570\u4f55\u65f6\u6216\u8005\u5982\u4f55\u7ec8\u6b62\uff09\uff0c\u7136\u540e\u6301\u6709\u8be5\u6307\u9488\u7684\u5bf9\u8c61\u5c06\u4f1a\u88ab\u9500\u6bc1\u3002 \u8fd9\u662f\u8fd9\u4e2a\u60f3\u6cd5\u7684\u7b2c\u4e00\u4e2a\u8349\u7a3f # include <iostream> template < class T > class Auto_ptr1 { T * m_ptr ; public : // Pass in a pointer to \"own\" via the constructor Auto_ptr1 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } // The destructor will make sure it gets deallocated ~ Auto_ptr1 () { delete m_ptr ; } // Overload dereference and operator-> so we can use Auto_ptr1 like m_ptr. T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } }; // A sample class to prove the above works class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { Auto_ptr1 < Resource > res ( new Resource ); // Note the allocation of memory here // ... but no explicit delete needed // Also note that the Resource in angled braces doesn't need a * symbol, since that's supplied by the template return 0 ; } // res goes out of scope here, and destroys the allocated Resource for us \u8fd9\u4e2a\u7a0b\u5e8f\u4f1a\u6253\u5370\uff1a Resource acquired Resource destroyed \u601d\u8003\u8fd9\u4e2a\u7a0b\u5e8f\u548c\u7c7b\u662f\u5982\u4f55\u5de5\u4f5c\u7684\u3002\u9996\u5148\uff0c\u6211\u4eec\u52a8\u6001\u7684\u521b\u5efa\u4e00\u4e2a Resource \uff0c\u5e76\u4e14\u4f5c\u4e3a\u4e00\u4e2a\u53c2\u6570\u4f20\u7ed9\u6211\u4eec\u7684\u6a21\u677f\u7c7b Auto_ptr1 \u3002\u4ece\u90a3\u4e2a\u70b9\u5f00\u59cb\u5f80\u540e\u8d70\uff0c\u6211\u4eec\u7684 Auto_ptr \u53d8\u91cf res \u6301\u6709\u8fd9\u4e2a Resource \u5bf9\u8c61\uff08 Auto_ptr1 \u548c m_ptr \u6709\u7ec4\u6210\u7684\u5173\u7cfb\uff09\u3002\u56e0\u4e3a res \u88ab\u58f0\u660e\u4e3a\u4e00\u4e2a\u5c40\u90e8\u53d8\u91cf\uff0c\u6709\u4f5c\u7528\u57df\u3002\u5f53\u524d\u8bed\u53e5\u5757\u7ed3\u675f\u540e\uff0c\u5b83\u5c06\u4f1a\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5e76\u4e14\u88ab\u9500\u6bc1\uff08\u4e0d\u7528\u518d\u4f46\u56e0\u5fd8\u4e86\u91ca\u653e\u5b83\uff09\u3002\u5e76\u4e14\u56e0\u4e3a\u5b83\u662f\u4e00\u4e2a\u7c7b\uff0c\u5f53\u5b83\u88ab\u9500\u6bc1\u65f6\uff0c Auto_ptr1 \u7684\u6790\u6784\u51fd\u6570\u5c06\u4f1a\u88ab\u8c03\u7528\u3002\uff08Auto_ptr1\uff09\u7684\u6790\u6784\u51fd\u6570\u5c06\u4f1a\u786e\u4fdd\u5b83\u6301\u6709\u7684 Resource \u6307\u9488\u88ab\u5220\u9664\uff01 \u53ea\u8981 Auto_ptr1 \u88ab\u5b9a\u4e49\u4e3a\u4e00\u4e2a\u5c40\u90e8\u53d8\u91cf\uff08\u81ea\u52a8\u7684\u751f\u547d\u5468\u671f\uff0c\u56e0\u6b64 Auto \u624d\u4f5c\u4e3a\u7c7b\u540d\u7684\u4e00\u90e8\u5206\uff09\uff0c Resouce \u5c06\u5728\u88ab\u5b9a\u4e49\u7684\u8bed\u53e5\u672b\u5c3e\u4f1a\u88ab\u5220\u9664\u8fd9\u4ef6\u4e8b\u5f97\u5230\u4e86\u4fdd\u8bc1\uff0c\u4e0d\u7ba1\u51fd\u6570\u4f55\u65f6\u7ed3\u675f\uff08\u5373\u4fbf\u5b83\u63d0\u524d\u7ed3\u675f\uff09\u3002 \u8fd9\u6837\u7684\u7c7b\u88ab\u53eb\u505a\u667a\u80fd\u6307\u9488(Smart Pointer)\u3002\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u662f\u4e00\u4e2a\u590d\u5408\u7c7b\uff08composition class\uff09\uff0c\u4e13\u95e8\u88ab\u8bbe\u8ba1\u51fa\u6765\u7ba1\u7406\u7684\u52a8\u6001\u5185\u5b58\u7684\u5206\u914d\uff0c\u5e76\u4e14\u4fdd\u8bc1\u5f53\u667a\u80fd\u6307\u9488\u79bb\u5f00\u4f5c\u7528\u57df\u540e\u5185\u5b58\u88ab\u91ca\u653e\u3002\uff08\u4e8e\u6b64\u76f8\u5173\u7684\uff0c\u5185\u7f6e\u7684\u6307\u9488\u6709\u65f6\u5019\u4f1a\u88ab\u53eb\u505a\u201d\u7b28\u6307\u9488(dumb pointers)\u201c\uff0c\u56e0\u4e3a\u4ed6\u4eec\u4e0d\u80fd\u6e05\u7406\u4ed6\u4eec\u81ea\u5df1\u3002\uff09 \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u56de\u5230\u6211\u4eec\u4e0a\u65b9\u7684\u7684 someFunction() \u4f8b\u5b50\uff0c\u5e76\u4e14\u5c55\u793a\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u5982\u4f55\u6211\u4eec\u9047\u5230\u7684\u56f0\u96be\uff1a # include <iostream> template < class T > class Auto_ptr1 { T * m_ptr ; public : // Pass in a pointer to \"own\" via the constructor // \u901a\u8fc7\u6784\u9020\u51fd\u6570\u4f20\u5165\u4e00\u4e2a\u6307\u9488\u8ba9\u5b83\u201c\u6240\u6709\u201c Auto_ptr1 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } // The destructor will make sure it gets deallocated // \u6790\u6784\u51fd\u6570\u5c06\u4f1a\u4fdd\u8bc1\u5b83\u88ab\u9500\u6bc1 ~ Auto_ptr1 () { delete m_ptr ; } // Overload dereference and operator-> so we can use Auto_ptr1 like m_ptr. // \u91cd\u8f7d\u5f15\u7528\u548c -> \u64cd\u4f5c\u7b26\uff0c\u4ee5\u4fbf\u4e8e\u6211\u4eec\u53ef\u4ee5\u50cf m_ptr \u90a3\u6837\u4f7f\u7528 Auto_ptr1 T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } }; // A sample class to prove the above works // \u4e00\u4e2a\u7b80\u5355\u7684\u7c7b\u6765\u8bc1\u660e\u4e0a\u9762\u7684\u4ee3\u7801\u5de5\u4f5c class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } void sayHi () { std :: cout << \"Hi! \\n \" ; } }; void someFunction () { Auto_ptr1 < Resource > ptr ( new Resource ); // ptr now owns the Resource // \u6307\u9488\u73b0\u5728\u62e5\u6709\u4e86 Resource int x ; std :: cout << \"Enter an integer: \" ; std :: cin >> x ; if ( x == 0 ) return ; // the function returns early // \u51fd\u6570\u63d0\u524d\u8fd4\u56de // do stuff with ptr here // \u4f7f\u7528\u6307\u9488 ptr -> sayHi (); } int main () { someFunction (); return 0 ; } \u5982\u679c\u7528\u6237\u4f20\u5165\u4e86\u4e00\u4e2a\u975e\u96f6\u6574\u6570\uff0c\u4e0a\u9762\u7684\u7a0b\u5e8f\u5c06\u4f1a\u6253\u5370\uff1a Resource acquired Hi! Resource destroyed \u5982\u679c\u7528\u6237\u8f93\u51650\uff0c\u4e0a\u9762\u7684\u7684\u7a0b\u5e8f\u5c06\u4f1a\u63d0\u524d\u7ec8\u6b62\uff0c\u9000\u51fa\uff0c\u5e76\u4e14\u6253\u5370\uff1a Resource acquired Resource destroyed \u6ce8\u610f\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u5373\u4fbf\u7528\u6237\u8f93\u51650\u5bfc\u81f4\u7a0b\u5e8f\u63d0\u524d\u9000\u51fa\uff0c Resource \u4e5f\u4f1a\u5f97\u5230\u5408\u7406\u7684\u91ca\u653e\u3002 \u56e0\u4e3a\u6307\u9488\u53d8\u91cf\u662f\u4e00\u4e2a\u5c40\u90e8\u53d8\u91cf\uff0c\u6307\u9488\u5c06\u4f1a\u88ab\u91ca\u653e\u5f53\u51fd\u6570\u7ec8\u6b62\uff08\u4e0d\u7ba1\u5b83\u5982\u4f55\u505c\u6b62\uff09\u3002\u5e76\u4e14\u56e0\u4e3a Auto_ptr1 \u6790\u6784\u51fd\u6570\u5c06\u4f1a\u6e05\u7406 Resouce \uff0c\u6211\u4eec\u4fdd\u8bc1 Rresouce \u5c06\u4f1a\u88ab\u5408\u7406\u7684\u6e05\u7406\u3002 \u4e00\u4e2a\u5f88\u5173\u952e\u7684\u7f3a\u9677 \u00b6 Auto_ptr1 \u7c7b\u6709\u4e00\u4e2a\u81f4\u547d\u7684\u7f3a\u9677\u9690\u85cf\u5728\u4e00\u4e9b**\u81ea\u52a8\u751f\u6210**\u7684\u4ee3\u7801\u91cc\u3002\u5728\u8fdb\u4e00\u6b65\u9605\u8bfb\u4e4b\u524d\uff0c\u770b\u770b\u4f60\u662f\u5426\u80fd\u627e\u5230\u7b54\u6848\uff0c\u5feb\u60f3\u60f3\u5427\u2026\u2026 \uff08\u63d0\u793a\uff1a\u601d\u8003\u7c7b\u4e2d\u7684\u54ea\u4e2a\u90e8\u5206\u4f1a\u88ab\u81ea\u52a8\u751f\u6210\uff0c\u5982\u679c\u4f60\u4e0d\u63d0\u4f9b\uff09 \uff08\u7d27\u5f20\u7684\u97f3\u4e50\uff09 Okay, time\u2019s up. \u597d\u4e86\uff0c\u65f6\u95f4\u5230\u4e86\u3002 \u76f8\u6bd4\u8bb2\u7ed9\u4f60\u542c\uff0c\u6211\u4eec\u5c06\u76f4\u63a5\u5411\u4f60\u5c55\u793a\uff0c\u601d\u8003\u4e0b\u5217\u7a0b\u5e8f\uff1a # include <iostream> // Same as above template < class T > class Auto_ptr1 { T * m_ptr ; public : Auto_ptr1 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr1 () { delete m_ptr ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } }; class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { Auto_ptr1 < Resource > res1 ( new Resource ); Auto_ptr1 < Resource > res2 ( res1 ); // Alternatively, don't initialize res2 and then assign res2 = res1; return 0 ; } \u8fd9\u4e2a\u7a0b\u5e8f\u5c06\u4f1a\u6253\u5370 Resource acquired Resource destroyed Resource destroyed \u53ef\u80fd\uff08\u4f46\u4e0d\u662f\u4e00\u5b9a\uff09\u4f60\u7684\u7a0b\u5e8f\u5c06\u4f1a\u5728\u8fd9\u65f6\u9000\u51fa\u3002\u770b\u5230\u95ee\u9898\u4e86\u4e48\uff1f\u56e0\u4e3a\u6211\u4eec\u6ca1\u6709\u63d0\u4f9b\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u6216\u8005\u8d4b\u503c\u64cd\u4f5c\u7b26\uff0cC++ \u7ed9\u6211\u4eec\u63d0\u4f9b\u4e86\u4e00\u4e2a\u3002\u5e76\u4e14\u8be5\u51fd\u6570\u8fdb\u884c\u4e86\u6d45\u62f7\u8d1d\uff0c\u56e0\u6b64\u5f53\u6211\u4eec\u7528 res1 \u521d\u59cb\u5316 res2 \u65f6\uff0c \u4e24\u4e2a Auto_ptr1 \u53d8\u91cf\u901a\u77e5\u6307\u5411\u4e86\u540c\u6837\u7684 Resource \u3002\u5f53 res2 \u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u4ed6\u5c31\u4f1a\u5220\u9664 resouce \uff0c\u8ba9 res1 \u6210\u4e3a\u4e00\u4e2a\u60ac\u7a7a\u6307\u9488\uff0c\u5f53 res1 \u5220\u9664\u4ed6\u7684\uff08\u65e9\u5c31\u88ab\u5220\u9664\uff09\u7684 Resouce \u65f6\uff0c\u7a0b\u5e8f\u5d29\u6e83\uff01 \u4f60\u5b9e\u73b0\u53e6\u4e00\u4e2a\u7b80\u5355\u7684\u95ee\u9898\uff0c\u5f53\u50cf\u8fd9\u6837\u8c03\u7528\u51fd\u6570\u65f6\uff1a void passByValue ( Auto_ptr1 < Resource > res ) { } int main () { Auto_ptr1 < Resource > res1 ( new Resource ); passByValue ( res1 ) return 0 ; } \u5728\u8fd9\u4e2a\u7a0b\u5e8f\u4e2d\uff0c res1 \u5c06\u4f1a\u88ab\u503c\u62f7\u8d1d\u8fdb passByValue() \u7684\u53c2\u6570 res \uff0c\u5bfc\u81f4\u590d\u5236\u4e86\u4e00\u4efd Resouce \u6307\u9488\uff0c\u6700\u540e\u56e0\u4e3a\u540c\u6837\u7684\u95ee\u9898\u5d29\u6e83\u3002 \u597d\u7684\uff0c\u6211\u4eec\u6e05\u695a\u8fd9\u4e2a\u95ee\u9898\u4e86\u3002\u6211\u4eec\u5982\u4f55\u89e3\u51b3\u5b83\uff1f \u80fd\u591f\u89e3\u51b3\u7684\u65b9\u6cd5\u4e4b\u4e00\u5c31\u662f\u663e\u5f0f\u7684\u5b9a\u4e49\u5220\u9664\u62f7\u8d1d\u6784\u9020\u548c\u8d4b\u503c\u64cd\u4f5c\u7b26\uff0c\u4ece\u800c\u963b\u6b62\u4e86\u4efb\u4f55\u62f7\u8d1d\u4ece\u539f\u59cb\u5bf9\u8c61\u590d\u5236\u51fa\u6765\uff0c\u90a3\u4f1a\u963b\u6b62\u503c\u4f20\u503c\uff08\u90a3\u65f6\u5f88\u68d2\u7684\uff0c\u65e0\u8bba\u5982\u4f55\u6211\u4eec\u90fd\u4e0d\u5e94\u8be5\u5728\u8fd9\u4e2a\u60c5\u51b5\u4e0b\u4f7f\u7528\u503c\u4f20\u503c\uff09\u3002 \u4f46\u662f\u7d27\u63a5\u7740\u8fd4\u56de\u4e00\u4e2a Auto_ptr1 \u4ece\u4e00\u4e2a\u51fd\u6570\u8fd4\u56de\u5c06\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f ??? generateResource () { Resource * r = new Resource ; return Auto_ptr1 ( r ); } \u6211\u4eec\u4e0d\u80fd\u901a\u8fc7\u5f15\u7528\u8fd4\u56de Auto_ptr1 \uff0c\u56e0\u4e3a\u5c40\u90e8\u53d8\u91cf Auto_ptr1 \u5c06\u4f1a\u5728\u51fd\u6570\u7684\u672b\u5c3e\u88ab\u5220\u9664\uff0c\u5e76\u4e14\u8c03\u7528\u8005\u5c06\u4f1a\u5f97\u5230\u4e00\u4e2a\u60ac\u7a7a\u7684\u5f15\u7528\u3002\u901a\u8fc7\u5730\u5740\u8fd4\u56de\u6709\u540c\u6837\u7684\u95ee\u9898\u3002 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u5730\u5740\u8fd4\u56de\u6307\u9488 r \uff0c\u4f46\u662f\u6211\u4eec\u4e5f\u8bb8\u4f1a\u5fd8\u4e86\u4e4b\u540e\u5220\u9664 r \uff0c\u8fd9\u4e5f\u662f\u6211\u4eec\u4e4b\u6240\u4ee5\u4f7f\u7528\u667a\u80fd\u6307\u9488\u7684\u539f\u56e0\u3002\u56e0\u6b64\u90a3\u6beb\u65e0\u7591\u95ee\uff0c\u901a\u8fc7\u503c\u8fd4\u56de Auto_ptr1 \u662f\u552f\u4e00\u6709\u610f\u4e49\u7684\u9009\u9879 \u2014\u2014 \u4f46\u662f\u7d27\u63a5\u7740\u6211\u4eec\u5c31\u4f1a\u4ee5\u6d45\u62f7\u8d1d\uff0c\u590d\u5236\u6307\u9488\uff0c\u6700\u540e\u5d29\u6e83\u3002 \u53e6\u4e00\u4e2a\u9009\u9879\u5c31\u662f\u91cd\u5199\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u64cd\u4f5c\u7b26\u6765\u4fdd\u8bc1\u6df1\u62f7\u8d1d\u3002\u4ee5\u8fd9\u4e2a\u65b9\u5f0f\uff0c\u6211\u4eec\u81f3\u5c11\u80fd\u4fdd\u8bc1\u907f\u514d\u590d\u5236\u6307\u5411\u5171\u4e00\u4e2a\u5bf9\u8c61\u7684\u6307\u9488\u3002\u4f46\u662f\u6df1\u62f7\u8d1d\u662f\u6602\u8d35\u7684\uff08\u5e76\u4e14\u4e5f\u8bb8\u662f\u4e0d\u53ef\u53d6\u7684\u6216\u8005\u751a\u81f3\u662f\u4e0d\u53ef\u80fd\u7684\uff09\uff0c\u5e76\u4e14\u6211\u4eec\u4e0d\u60f3\u4e3a\u4e86\u4ece\u51fd\u6570\u4e2d\u8fd4\u56de Auto-ptr1 \u4ece\u800c\u5bf9\u5bf9\u8c61\u8fdb\u884c\u4e0d\u5fc5\u8981\u7684\u590d\u5236\u3002\u53e6\u5916\uff0c\u5206\u914d\u6216\u521d\u59cb\u5316\u4e00\u4e2a\u7b28\u6307\u9488\u5e76\u4e0d\u4f1a\u590d\u5236\u6240\u6307\u5411\u7684\u5bf9\u8c61\uff0c\u90a3\u4e48\u4e3a\u4ec0\u4e48\u6211\u4eec\u5e0c\u671b\u667a\u80fd\u6307\u9488\u7684\u884c\u4e3a\u6709\u6240\u4e0d\u540c\u5462\uff1f \u6211\u4eec\u8be5\u600e\u4e48\u529e\uff1f \u79fb\u52a8\u8bed\u4e49 \u00b6 \u5982\u679c\u4e0d\u662f\u8ba9\u590d\u5236\u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u8fd0\u7b97\u7b26\u590d\u5236\u6307\u9488\uff08\u201c\u590d\u5236\u8bed\u4e49\u201d\uff09\uff0c\u800c\u662f\u5c06\u6307\u9488\u7684\u6240\u6709\u6743\u4ece\u6e90\u5bf9\u8c61\u8f6c\u79fb/\u79fb\u52a8\u5230\u76ee\u6807\u5bf9\u8c61\u5462\uff1f\u8fd9\u662fmove\u8bed\u4e49\u80cc\u540e\u7684\u6838\u5fc3\u601d\u60f3\u3002\u79fb\u52a8\u8bed\u4e49\u610f\u5473\u7740\u7c7b\u5c06\u8f6c\u79fb\u5bf9\u8c61\u7684\u6240\u6709\u6743\uff0c\u800c\u4e0d\u662f\u8fdb\u884c\u590d\u5236\u3002 \u8ba9\u6211\u4eec\u4f60\u66f4\u65b0\u6211\u4eec\u7684 Auto_ptr1 \u7c7b\u6765\u5c55\u793a\u8fd9\u5982\u4f55\u5b8c\u6210\uff1a # include <iostream> template < class T > class Auto_ptr2 { T * m_ptr ; public : Auto_ptr2 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr2 () { delete m_ptr ; } // A copy constructor that implements move semantics Auto_ptr2 ( Auto_ptr2 & a ) // note: not const { m_ptr = a . m_ptr ; // transfer our dumb pointer from the source to our local object a . m_ptr = nullptr ; // make sure the source no longer owns the pointer } // An assignment operator that implements move semantics Auto_ptr2 & operator = ( Auto_ptr2 & a ) // note: not const { if ( & a == this ) return * this ; delete m_ptr ; // make sure we deallocate any pointer the destination is already holding first m_ptr = a . m_ptr ; // then transfer our dumb pointer from the source to the local object a . m_ptr = nullptr ; // make sure the source no longer owns the pointer return * this ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } bool isNull () const { return m_ptr == nullptr ; } }; class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { Auto_ptr2 < Resource > res1 ( new Resource ); Auto_ptr2 < Resource > res2 ; // Start as nullptr std :: cout << \"res1 is \" << ( res1 . isNull () ? \"null \\n \" : \"not null \\n \" ); std :: cout << \"res2 is \" << ( res2 . isNull () ? \"null \\n \" : \"not null \\n \" ); res2 = res1 ; // res2 assumes ownership, res1 is set to null std :: cout << \"Ownership transferred \\n \" ; std :: cout << \"res1 is \" << ( res1 . isNull () ? \"null \\n \" : \"not null \\n \" ); std :: cout << \"res2 is \" << ( res2 . isNull () ? \"null \\n \" : \"not null \\n \" ); return 0 ; } \u8fd9\u4e2a\u6253\u5370\u51fa\uff1a Resource acquired res1 is not null res2 is null Ownership transferred res1 is null res2 is not null Resource destroyed \u6ce8\u610f\u6211\u4eec\u91cd\u8f7d\u4e86 operator= \u5c06 m_ptr \u7684\u6240\u6709\u6743\u4ece res1 \u9012\u4ea4\u7ed9 res2 \uff01\u56e0\u6b64\u6211\u4eec\u4e0d\u4f1a\u590d\u5236\u6307\u9488\u7684\u62f7\u8d1d\uff0c\u5e76\u4e14\u6240\u6709\u4e8b\u90fd\u88ab\u6574\u9f50\u7684\u6e05\u7406\u5e72\u51c0\u3002 std::auto_ptr \u548c\u4e3a\u4f55\u907f\u514d\u4f7f\u7528 \u00b6 \u73b0\u5728\u662f\u5408\u9002\u7684\u5b9e\u673a\u6765\u8bb2 std::auto_ptr \u4e86\uff0c std::auto_ptr \uff0c\u5728 C++98 \u4e2d\u5f15\u8fdb\uff0c\u662f C++ \u7684\u7b2c\u4e00\u6b21\u5c1d\u8bd5\u5b9e\u73b0\u4e00\u4e2a\u6807\u51c6\u7684\u53ea\u80fd\u6307\u9488\u3002 std::auto_ptr \u9009\u62e9\u4e86\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\u5c31\u50cf Auto_ptr2 \u7c7b\u505a\u7684\u90a3\u6837\u3002 \u7136\u800c\uff0c std::auto_ptr \uff08\u548c\u6211\u4eec\u7684 Auto_ptr2 \u7c7b\u4e00\u6837\uff09\u6709\u4e00\u5927\u5806\u95ee\u9898\uff0c\u4f7f\u5f97\u7528\u8d77\u6765\u975e\u5e38\u7684\u5371\u9669\u3002 \u9996\u5148\uff1a \u7531\u4e8e std::auto_ptr \u901a\u8fc7copy\u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u8fd0\u7b97\u7b26\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49(move semantics)\uff0c\u56e0\u6b64\u6309\u503c\u5411\u51fd\u6570\u4f20\u9012 std::auto_ptr \u5c06\u5bfc\u81f4\u8d44\u6e90\u79fb\u52a8\u5230\u51fd\u6570\u53c2\u6570\uff08\u5f53\u51fd\u6570\u53c2\u6570\u79bb\u5f00\u4f5c\u7528\u57df\u540e\uff0c\u53c2\u6570\u5728\u51fd\u6570\u672b\u5c3e\u9500\u6bc1\uff09\u3002\u7136\u540e\u5f53\u4f60\u4ece\u8c03\u7528\u8005\u90a3\u91cc\u8bbf\u95ee\u4f60\u7684 auto_ptr \u53c2\u6570\u65f6\uff08\u6ca1\u6709\u610f\u8bc6\u5230\u5b83\u5df2\u7ecf\u88ab\u8f6c\u79fb\u548c\u5220\u9664\uff09\uff0c\u4f60\u7a81\u7136\u5bf9\u7a7a\u6307\u9488\u7684\u53d6\u503c\u3002\u5bfc\u81f4\u5d29\u6e83 \u7b2c\u4e8c\uff1a std::auto_ptr \u603b\u662f\u7528\u975e\u6570\u7ec4\u5220\u9664\u5b83\u7684\u5185\u5bb9\u3002\u8fd9\u610f\u5473\u8fd9 auto_ptr \u5728\u52a8\u6001\u5206\u914d\u6570\u7ec4\u5185\u5b58\u7684\u60c5\u51b5\u4e0b\uff0c\u4e0d\u80fd\u6b63\u786e\u7684\u5de5\u4f5c\uff0c\u56e0\u4e3a\u5b83\u4f7f\u7528\u4e86\u9519\u8bef\u7684\u91ca\u653e\u7b26\u53f7\u3002\u66f4\u7cdf\u7cd5\u7684\u662f\uff0c\u5b83\u4e0d\u5141\u8bb8\u4f60\u4f20\u4e00\u4e2a\u52a8\u6001\u7684\u6570\u7ec4\uff0c\u56e0\u4e3a\u8fd9\u6837\u505a\u5b83\u5c31\u4f1a\u5931\u53bb\u7ba1\u7406\uff0c\u5bfc\u81f4\u5185\u5b58\u6cc4\u9732\u3002 \u6700\u540e\uff1a std::auto_ptr \u4e0d\u80fd\u548c\u5176\u4ed6\u6807\u51c6\u5e93\u4e2d\u7684\u7c7b\u642d\u914d\u4f7f\u7528\uff0c\u5305\u62ec\u5927\u91cf\u7684\u5bb9\u5668\u548c\u7b97\u6cd5\u3002\u8fd9\u4f1a\u53d1\u751f\u5c31\u662f\u56e0\u4e3a\u90a3\u4e9b\u6807\u51c6\u5e93\u5047\u8bbe\u5f53\u4ed6\u4eec\u62f7\u8d1d\u4e00\u4e2a\u5bf9\u8c61\u7684\u65f6\u5019\uff0c\u5b9e\u9645\u4e0a\u662f\u62f7\u8d1d\u800c\u4e0d\u662f\u79fb\u52a8\u3002 \u56e0\u4e3a\u4ee5\u4e0a\u63d0\u5230\u7684\u7f3a\u70b9\uff0c std::auto_ptr \u5728 C++11 \u4e2d\u5df2\u7ecf\u88ab\u79fb\u9664\uff0c\u5e76\u4e14\u4e0d\u5e94\u8be5\u88ab\u4f7f\u7528\u3002\u4e8b\u5b9e\u4e0a std::auto_ptr \u5728 C++17 \u4e2d\u624d\u88ab\u4ece\u6807\u51c6\u5e93\u4e2d\u5b8c\u5168\u79fb\u9664\u3002 Rule: std::auto_ptr is deprecated and should not be used. (Use std::unique_ptr or std::shared_ptr instead).. \u89c4\u5219\uff1a std::auto_ptr \u662f\u88ab\u629b\u5f03\u7684\uff0c\u5e76\u4e14\u4e0d\u5e94\u8be5\u88ab\u4f7f\u7528\u3002\uff08\u4f7f\u7528 std::unique_ptr or std::shared_ptr \u66ff\u6362\u4ed6\uff09\u2026\u2026 \u5411\u524d\u770b \u00b6 \u5728 C++11 \u4e4b\u524d std::auto_ptr \u7684\u6838\u5fc3\u8bbe\u8ba1\u95ee\u9898\uff0c\u662f C++ \u8bed\u8a00\u6ca1\u6709\u4e00\u4e2a\u7b80\u5355\u7684\u673a\u5236\u6765\u5206\u8fa8\u62f7\u8d1d\u8bed\u4e49\u548c\u79fb\u52a8\u8bed\u4e49\u3002\u91cd\u5199\u62f7\u8d1d\u8bed\u4e49\u6765\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\uff0c\u65e0\u610f\u4e2d\u5f15\u8d77\u4e86\u95ee\u9898\u3002\u4f8b\u5982\uff0c\u4f60\u53ef\u4ee5\u5199 res1 = res2 \u5e76\u4e14\u6ca1\u529e\u6cd5\u77e5\u9053 res2 \u662f\u5426\u4f1a\u88ab\u6539\u53d8\uff01 \u56e0\u4e3a\u8fd9\u4e2a\uff0c\u5728 C++11\u4e2d\uff0c\u201d\u79fb\u52a8\u201d\u8fd9\u4e2a\u6982\u5ff5\u88ab\u6b63\u5f0f\u7684\u5b9a\u4e49\uff0c\u5e76\u4e14\u201d\u79fb\u52a8\u8bed\u4e49\u201c\u88ab\u6dfb\u52a0\u5230\u8bed\u8a00\u4e2d\u6765\u5408\u9002\u7684\u5206\u8fa8\u62f7\u8d1d(copying)\u548c\u79fb\u52a8(moving)\u3002\u65e2\u7136\u6211\u4eec\u5df2\u7ecf\u4e3a\"\u4e3a\u4f55\u79fb\u52a8\u8bed\u4e49\u662f\u6709\u7528\u7684\"\u505a\u597d\u4e86\u51c6\u5907\uff0c\u6211\u4eec\u5c06\u5728\u672c\u7ae0\u7684\u5176\u4f59\u90e8\u5206\u4e2d\u63a2\u8ba8\"\u79fb\u52a8\u8bed\u4e49\"\u7684\u4e3b\u9898\u3002\u6211\u4eec\u8fd8\u5c06\u4f7f\u7528move\u8bed\u4e49\u4fee\u590dAuto ptr2\u7c7b\u3002 \u5728 C++11\u4e2d\uff0c std::auto_ptr \u5df2\u7ecf\u88ab\u4e00\u5806\u5176\u4ed6\u7c7b\u578b\u7684\u201cmove-aware\u201d\u53ea\u80fd\u6307\u6b63\u6240\u66ff\u6362\uff1a std::unique_ptr \uff0c std::weak_ptr \uff0c\u548c std::shared_ptr \u3002\u6211\u4eec\u5c06\u4e5f\u63a2\u7d22\u8fd9\u4e9b\u4e2d\u6700\u8457\u540d\u7684\u4e24\u4e2a\uff1a unique_ptr (\u76f4\u63a5\u7528\u6765\u66ff\u6362 std::auto_ptr \u7684) \u548c shared_ptr .","title":"15.1 \u667a\u80fd\u6307\u9488\u548c\u79fb\u52a8\u8bed\u4e49\u7684\u4ecb\u7ecd"},{"location":"15-move-semantics-and-smart-pointers/15.1-intro-to-smart-pointers-and-move-semantics/#151","text":"By Alex on February 17 th , 2017 | last modified by nascardriver on April 25 th , 2020 \u7ffb\u8bd1by dashjay 2020.7.14 \u601d\u8003\u4e0b\u5217\u51fd\u6570\uff0c\u5728\u8fd9\u4e2a\u51fd\u6570\u4e2d\u6211\u4eec\u52a8\u6001\u5206\u914d\u4e86\u4e00\u4e2a\u503c void someFunction () { Resource * ptr = new Resource ; // Resource is a struct or class \u3010\u8d44\u6e90\u662f\u4e00\u4e2a\u7ed3\u6784\u6216\u8005\u7c7b\u3011 // do stuff with ptr here \u3010\u4f7f\u7528\u6307\u9488\u5728\u8fd9\u91cc\u505a\u4e00\u4e9b\u4e8b\u3011 delete ptr ; } \u7ecf\u7ba1\u4ee5\u4e0a\u4ee3\u7801\u770b\u8d77\u6765\u5f88\u76f4\u63a5\u7b80\u5355\uff0c\u4f46\u662f\u4e5f\u76f8\u5f53\u5bb9\u6613\u5fd8\u8bb0\u53bb\u91ca\u653e\u6307\u9488\u3002\u5373\u4fbf\u4f60\u786e\u5b9e\u8bb0\u5f97\u5728\u51fd\u6570\u672b\u5c3e\u91ca\u653e\u6307\u9488\uff0c\u4e5f\u6709\u65e0\u6570\u79cd\u60c5\u51b5\u5bfc\u81f4\u6307\u9488\u6ca1\u6709\u88ab\u5220\u9664\uff0c\u5982\u679c\u51fd\u6570\u63d0\u524d\u9000\u51fa\u7684\u8bdd\u3002\u8fd9\u5f88\u53ef\u80fd\u53d1\u751f\u901a\u8fc7\u4e00\u4e2a early return : # include <iostream> void someFunction () { Resource * ptr = new Resource ; int x ; std :: cout << \"Enter an integer: \" ; std :: cin >> x ; if ( x == 0 ) return ; // the function returns early, and ptr won\u2019t be deleted! // do stuff with ptr here delete ptr ; } or via a thrown exception: \u6216\u8005\u901a\u8fc7\u4e00\u4e2a\u5f02\u5e38\u7684\u629b\u51fa # include <iostream> void someFunction () { Resource * ptr = new Resource ; int x ; std :: cout << \"Enter an integer: \" ; std :: cin >> x ; if ( x == 0 ) throw 0 ; // the function returns early, and ptr won\u2019t be deleted! // do stuff with ptr here delete ptr ; } \u5728\u4ee5\u4e0a\u7684\u4e24\u4e2a\u7a0b\u5e8f\u4e2d\uff0c\u63d0\u524d\u9000\u51fa\u6216\u8005\u629b\u51fa\u8bed\u53e5\u6267\u884c\u90fd\u4f1a\u9020\u6210\u51fd\u6570\u7ec8\u6b62\uff0c\u5e76\u4e14\u672a\u91ca\u653e ptr \u6307\u9488\u3002\u56e0\u6b64\uff0c\u4e3a\u53d8\u91cf ptr \u5206\u914d\u7684\u5185\u5b58\u5c31\u4f1a\u91ca\u653e\uff08\u5e76\u4e14\u5c06\u6bcf\u6b21\u8c03\u7528\u8be5\u51fd\u6570\u65f6\uff0c\u6cc4\u9732\u4e00\u6b21\uff0c\u5982\u679c\u63d0\u524d\u9000\u51fa\u7684\u8bdd\uff09\u3002 \u672c\u6307\u4e0a\uff0c\u8fd9\u4e9b\u79cd\u7c7b\u7684\u95ee\u9898\u4e4b\u6240\u4ee5\u4f1a\u53d1\u751f\uff0c\u662f\u662f\u56e0\u4e3a\u6307\u9488\u53d8\u91cf\u6ca1\u6709\u56fa\u6709\u7684\u673a\u5236\u6765\u6e05\u7406\u4ed6\u4eec\u81ea\u5df1\u3002","title":"15.1 \u667a\u80fd\u6307\u9488\u548c\u79fb\u52a8\u8bed\u4e49\u7684\u4ecb\u7ecd"},{"location":"15-move-semantics-and-smart-pointers/15.1-intro-to-smart-pointers-and-move-semantics/#_1","text":"\u4e00\u4e2a\u7c7b\u6700\u68d2\u7684\u4e8b\u4e4b\u4e00\u5c31\u662f\u5305\u542b\u4e00\u4e2a\u89e3\u6784\u51fd\u6570\u4f1a\u81ea\u52a8\u6267\u884c\uff0c\u5f53\u8fd9\u4e2a\u7c7b\u5bf9\u8c61\u8131\u79bb\u4f5c\u7528\u57df\u540e\u3002\u56e0\u6b64\u5982\u679c\u4f60\u5206\u914d\uff08\u6216\u5f97\u5230\uff09\u5185\u5b58\u5728\u4f60\u7684\u6784\u9020\u51fd\u6570\u4e2d\uff0c\u4f60\u53ef\u4ee5\u91ca\u653e\u4ed6\u4eec\u5728\u4f60\u7684\u6790\u6784\u51fd\u6570\uff0c\u5e76\u4e14\u4fdd\u8bc1\u5185\u5b58\u5c06\u4f1a\u88ab\u91ca\u653e\u5f53\u8fd9\u4e2a\u5bf9\u8c61\u88ab\u9500\u6bc1\uff08\u53ef\u4ee5\u662f\u79bb\u5f00\u4f5c\u7528\u4e8e\u6216\u8005\u663e\u5f0f\u7684\u5220\u9664\uff0c\u7b49\u7b49\u2026\u2026\uff09\u3002\u8fd9\u662f RAII \u7f16\u7a0b\u7684\u6838\u5fc3\uff0c\u6211\u4eec\u5728 8.7 \u8bfe\u8ba8\u8bba\u8fc7\u7684 \u2014\u2014 \u7ed3\u6784\u51fd\u6570 \u3002 \u8fd9\u6837\u8bf4\u6765\uff0c\u6211\u4eec\u662f\u5426\u80fd\u7528\u4e00\u4e2a\u7c7b\u6765\u5e2e\u52a9\u6211\u4eec\u7ba1\u7406\u6216\u8005\u6e05\u7406\u6211\u4eec\u7684\u6307\u9488\uff1f\u5f53\u7136\u53ef\u4ee5\uff01 \u601d\u8003\u5982\u679c\u6709\u8fd9\u6837\u4e00\u4e2a\u7c7b\uff0c\u5b83\u6240\u6709\u7684\u5de5\u4f5c\u5c31\u662f\u6301\u6709\u548c\u201d\u62e5\u6709\u201c\u4e00\u4e2a\u4f20\u7ed9\u4ed6\u7684\u6307\u9488\uff0c\u5e76\u4e14\u5f53\u8be5\u7c7b\u7684\u5bf9\u8c61\u79bb\u5f00\u4f5c\u7528\u57df\u540e\u5c31\u4f1a\u91ca\u653e\u90a3\u4e2a\u6301\u6709\u7684\u6307\u9488\u3002\u53ea\u8981\u90a3\u4e2a\u7c7b\u7684\u5bf9\u8c61\u4ec5\u4ec5\u88ab\u521b\u5efa\u4f5c\u4e3a\u5c40\u90e8\u53d8\u91cf\uff0c\u6211\u4eec\u53ef\u4ee5\u4fdd\u8bc1\u8be5\u7c7b\u5c06\u4f1a\u4ee5\u6070\u5f53\u7684\u65b9\u5f0f\uff08properly\uff09\u7684\u79bb\u5f00\u4f5c\u7528\u57df\uff08\u53ef\u4ee5\u89c6\u4e3a\u6211\u4eec\u7684\u51fd\u6570\u4f55\u65f6\u6216\u8005\u5982\u4f55\u7ec8\u6b62\uff09\uff0c\u7136\u540e\u6301\u6709\u8be5\u6307\u9488\u7684\u5bf9\u8c61\u5c06\u4f1a\u88ab\u9500\u6bc1\u3002 \u8fd9\u662f\u8fd9\u4e2a\u60f3\u6cd5\u7684\u7b2c\u4e00\u4e2a\u8349\u7a3f # include <iostream> template < class T > class Auto_ptr1 { T * m_ptr ; public : // Pass in a pointer to \"own\" via the constructor Auto_ptr1 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } // The destructor will make sure it gets deallocated ~ Auto_ptr1 () { delete m_ptr ; } // Overload dereference and operator-> so we can use Auto_ptr1 like m_ptr. T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } }; // A sample class to prove the above works class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { Auto_ptr1 < Resource > res ( new Resource ); // Note the allocation of memory here // ... but no explicit delete needed // Also note that the Resource in angled braces doesn't need a * symbol, since that's supplied by the template return 0 ; } // res goes out of scope here, and destroys the allocated Resource for us \u8fd9\u4e2a\u7a0b\u5e8f\u4f1a\u6253\u5370\uff1a Resource acquired Resource destroyed \u601d\u8003\u8fd9\u4e2a\u7a0b\u5e8f\u548c\u7c7b\u662f\u5982\u4f55\u5de5\u4f5c\u7684\u3002\u9996\u5148\uff0c\u6211\u4eec\u52a8\u6001\u7684\u521b\u5efa\u4e00\u4e2a Resource \uff0c\u5e76\u4e14\u4f5c\u4e3a\u4e00\u4e2a\u53c2\u6570\u4f20\u7ed9\u6211\u4eec\u7684\u6a21\u677f\u7c7b Auto_ptr1 \u3002\u4ece\u90a3\u4e2a\u70b9\u5f00\u59cb\u5f80\u540e\u8d70\uff0c\u6211\u4eec\u7684 Auto_ptr \u53d8\u91cf res \u6301\u6709\u8fd9\u4e2a Resource \u5bf9\u8c61\uff08 Auto_ptr1 \u548c m_ptr \u6709\u7ec4\u6210\u7684\u5173\u7cfb\uff09\u3002\u56e0\u4e3a res \u88ab\u58f0\u660e\u4e3a\u4e00\u4e2a\u5c40\u90e8\u53d8\u91cf\uff0c\u6709\u4f5c\u7528\u57df\u3002\u5f53\u524d\u8bed\u53e5\u5757\u7ed3\u675f\u540e\uff0c\u5b83\u5c06\u4f1a\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5e76\u4e14\u88ab\u9500\u6bc1\uff08\u4e0d\u7528\u518d\u4f46\u56e0\u5fd8\u4e86\u91ca\u653e\u5b83\uff09\u3002\u5e76\u4e14\u56e0\u4e3a\u5b83\u662f\u4e00\u4e2a\u7c7b\uff0c\u5f53\u5b83\u88ab\u9500\u6bc1\u65f6\uff0c Auto_ptr1 \u7684\u6790\u6784\u51fd\u6570\u5c06\u4f1a\u88ab\u8c03\u7528\u3002\uff08Auto_ptr1\uff09\u7684\u6790\u6784\u51fd\u6570\u5c06\u4f1a\u786e\u4fdd\u5b83\u6301\u6709\u7684 Resource \u6307\u9488\u88ab\u5220\u9664\uff01 \u53ea\u8981 Auto_ptr1 \u88ab\u5b9a\u4e49\u4e3a\u4e00\u4e2a\u5c40\u90e8\u53d8\u91cf\uff08\u81ea\u52a8\u7684\u751f\u547d\u5468\u671f\uff0c\u56e0\u6b64 Auto \u624d\u4f5c\u4e3a\u7c7b\u540d\u7684\u4e00\u90e8\u5206\uff09\uff0c Resouce \u5c06\u5728\u88ab\u5b9a\u4e49\u7684\u8bed\u53e5\u672b\u5c3e\u4f1a\u88ab\u5220\u9664\u8fd9\u4ef6\u4e8b\u5f97\u5230\u4e86\u4fdd\u8bc1\uff0c\u4e0d\u7ba1\u51fd\u6570\u4f55\u65f6\u7ed3\u675f\uff08\u5373\u4fbf\u5b83\u63d0\u524d\u7ed3\u675f\uff09\u3002 \u8fd9\u6837\u7684\u7c7b\u88ab\u53eb\u505a\u667a\u80fd\u6307\u9488(Smart Pointer)\u3002\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u662f\u4e00\u4e2a\u590d\u5408\u7c7b\uff08composition class\uff09\uff0c\u4e13\u95e8\u88ab\u8bbe\u8ba1\u51fa\u6765\u7ba1\u7406\u7684\u52a8\u6001\u5185\u5b58\u7684\u5206\u914d\uff0c\u5e76\u4e14\u4fdd\u8bc1\u5f53\u667a\u80fd\u6307\u9488\u79bb\u5f00\u4f5c\u7528\u57df\u540e\u5185\u5b58\u88ab\u91ca\u653e\u3002\uff08\u4e8e\u6b64\u76f8\u5173\u7684\uff0c\u5185\u7f6e\u7684\u6307\u9488\u6709\u65f6\u5019\u4f1a\u88ab\u53eb\u505a\u201d\u7b28\u6307\u9488(dumb pointers)\u201c\uff0c\u56e0\u4e3a\u4ed6\u4eec\u4e0d\u80fd\u6e05\u7406\u4ed6\u4eec\u81ea\u5df1\u3002\uff09 \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u56de\u5230\u6211\u4eec\u4e0a\u65b9\u7684\u7684 someFunction() \u4f8b\u5b50\uff0c\u5e76\u4e14\u5c55\u793a\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u5982\u4f55\u6211\u4eec\u9047\u5230\u7684\u56f0\u96be\uff1a # include <iostream> template < class T > class Auto_ptr1 { T * m_ptr ; public : // Pass in a pointer to \"own\" via the constructor // \u901a\u8fc7\u6784\u9020\u51fd\u6570\u4f20\u5165\u4e00\u4e2a\u6307\u9488\u8ba9\u5b83\u201c\u6240\u6709\u201c Auto_ptr1 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } // The destructor will make sure it gets deallocated // \u6790\u6784\u51fd\u6570\u5c06\u4f1a\u4fdd\u8bc1\u5b83\u88ab\u9500\u6bc1 ~ Auto_ptr1 () { delete m_ptr ; } // Overload dereference and operator-> so we can use Auto_ptr1 like m_ptr. // \u91cd\u8f7d\u5f15\u7528\u548c -> \u64cd\u4f5c\u7b26\uff0c\u4ee5\u4fbf\u4e8e\u6211\u4eec\u53ef\u4ee5\u50cf m_ptr \u90a3\u6837\u4f7f\u7528 Auto_ptr1 T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } }; // A sample class to prove the above works // \u4e00\u4e2a\u7b80\u5355\u7684\u7c7b\u6765\u8bc1\u660e\u4e0a\u9762\u7684\u4ee3\u7801\u5de5\u4f5c class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } void sayHi () { std :: cout << \"Hi! \\n \" ; } }; void someFunction () { Auto_ptr1 < Resource > ptr ( new Resource ); // ptr now owns the Resource // \u6307\u9488\u73b0\u5728\u62e5\u6709\u4e86 Resource int x ; std :: cout << \"Enter an integer: \" ; std :: cin >> x ; if ( x == 0 ) return ; // the function returns early // \u51fd\u6570\u63d0\u524d\u8fd4\u56de // do stuff with ptr here // \u4f7f\u7528\u6307\u9488 ptr -> sayHi (); } int main () { someFunction (); return 0 ; } \u5982\u679c\u7528\u6237\u4f20\u5165\u4e86\u4e00\u4e2a\u975e\u96f6\u6574\u6570\uff0c\u4e0a\u9762\u7684\u7a0b\u5e8f\u5c06\u4f1a\u6253\u5370\uff1a Resource acquired Hi! Resource destroyed \u5982\u679c\u7528\u6237\u8f93\u51650\uff0c\u4e0a\u9762\u7684\u7684\u7a0b\u5e8f\u5c06\u4f1a\u63d0\u524d\u7ec8\u6b62\uff0c\u9000\u51fa\uff0c\u5e76\u4e14\u6253\u5370\uff1a Resource acquired Resource destroyed \u6ce8\u610f\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u5373\u4fbf\u7528\u6237\u8f93\u51650\u5bfc\u81f4\u7a0b\u5e8f\u63d0\u524d\u9000\u51fa\uff0c Resource \u4e5f\u4f1a\u5f97\u5230\u5408\u7406\u7684\u91ca\u653e\u3002 \u56e0\u4e3a\u6307\u9488\u53d8\u91cf\u662f\u4e00\u4e2a\u5c40\u90e8\u53d8\u91cf\uff0c\u6307\u9488\u5c06\u4f1a\u88ab\u91ca\u653e\u5f53\u51fd\u6570\u7ec8\u6b62\uff08\u4e0d\u7ba1\u5b83\u5982\u4f55\u505c\u6b62\uff09\u3002\u5e76\u4e14\u56e0\u4e3a Auto_ptr1 \u6790\u6784\u51fd\u6570\u5c06\u4f1a\u6e05\u7406 Resouce \uff0c\u6211\u4eec\u4fdd\u8bc1 Rresouce \u5c06\u4f1a\u88ab\u5408\u7406\u7684\u6e05\u7406\u3002","title":"\u667a\u80fd\u6307\u9488\u80fd\u62ef\u6551\u4e00\u5207\u4e48"},{"location":"15-move-semantics-and-smart-pointers/15.1-intro-to-smart-pointers-and-move-semantics/#_2","text":"Auto_ptr1 \u7c7b\u6709\u4e00\u4e2a\u81f4\u547d\u7684\u7f3a\u9677\u9690\u85cf\u5728\u4e00\u4e9b**\u81ea\u52a8\u751f\u6210**\u7684\u4ee3\u7801\u91cc\u3002\u5728\u8fdb\u4e00\u6b65\u9605\u8bfb\u4e4b\u524d\uff0c\u770b\u770b\u4f60\u662f\u5426\u80fd\u627e\u5230\u7b54\u6848\uff0c\u5feb\u60f3\u60f3\u5427\u2026\u2026 \uff08\u63d0\u793a\uff1a\u601d\u8003\u7c7b\u4e2d\u7684\u54ea\u4e2a\u90e8\u5206\u4f1a\u88ab\u81ea\u52a8\u751f\u6210\uff0c\u5982\u679c\u4f60\u4e0d\u63d0\u4f9b\uff09 \uff08\u7d27\u5f20\u7684\u97f3\u4e50\uff09 Okay, time\u2019s up. \u597d\u4e86\uff0c\u65f6\u95f4\u5230\u4e86\u3002 \u76f8\u6bd4\u8bb2\u7ed9\u4f60\u542c\uff0c\u6211\u4eec\u5c06\u76f4\u63a5\u5411\u4f60\u5c55\u793a\uff0c\u601d\u8003\u4e0b\u5217\u7a0b\u5e8f\uff1a # include <iostream> // Same as above template < class T > class Auto_ptr1 { T * m_ptr ; public : Auto_ptr1 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr1 () { delete m_ptr ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } }; class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { Auto_ptr1 < Resource > res1 ( new Resource ); Auto_ptr1 < Resource > res2 ( res1 ); // Alternatively, don't initialize res2 and then assign res2 = res1; return 0 ; } \u8fd9\u4e2a\u7a0b\u5e8f\u5c06\u4f1a\u6253\u5370 Resource acquired Resource destroyed Resource destroyed \u53ef\u80fd\uff08\u4f46\u4e0d\u662f\u4e00\u5b9a\uff09\u4f60\u7684\u7a0b\u5e8f\u5c06\u4f1a\u5728\u8fd9\u65f6\u9000\u51fa\u3002\u770b\u5230\u95ee\u9898\u4e86\u4e48\uff1f\u56e0\u4e3a\u6211\u4eec\u6ca1\u6709\u63d0\u4f9b\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u6216\u8005\u8d4b\u503c\u64cd\u4f5c\u7b26\uff0cC++ \u7ed9\u6211\u4eec\u63d0\u4f9b\u4e86\u4e00\u4e2a\u3002\u5e76\u4e14\u8be5\u51fd\u6570\u8fdb\u884c\u4e86\u6d45\u62f7\u8d1d\uff0c\u56e0\u6b64\u5f53\u6211\u4eec\u7528 res1 \u521d\u59cb\u5316 res2 \u65f6\uff0c \u4e24\u4e2a Auto_ptr1 \u53d8\u91cf\u901a\u77e5\u6307\u5411\u4e86\u540c\u6837\u7684 Resource \u3002\u5f53 res2 \u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u4ed6\u5c31\u4f1a\u5220\u9664 resouce \uff0c\u8ba9 res1 \u6210\u4e3a\u4e00\u4e2a\u60ac\u7a7a\u6307\u9488\uff0c\u5f53 res1 \u5220\u9664\u4ed6\u7684\uff08\u65e9\u5c31\u88ab\u5220\u9664\uff09\u7684 Resouce \u65f6\uff0c\u7a0b\u5e8f\u5d29\u6e83\uff01 \u4f60\u5b9e\u73b0\u53e6\u4e00\u4e2a\u7b80\u5355\u7684\u95ee\u9898\uff0c\u5f53\u50cf\u8fd9\u6837\u8c03\u7528\u51fd\u6570\u65f6\uff1a void passByValue ( Auto_ptr1 < Resource > res ) { } int main () { Auto_ptr1 < Resource > res1 ( new Resource ); passByValue ( res1 ) return 0 ; } \u5728\u8fd9\u4e2a\u7a0b\u5e8f\u4e2d\uff0c res1 \u5c06\u4f1a\u88ab\u503c\u62f7\u8d1d\u8fdb passByValue() \u7684\u53c2\u6570 res \uff0c\u5bfc\u81f4\u590d\u5236\u4e86\u4e00\u4efd Resouce \u6307\u9488\uff0c\u6700\u540e\u56e0\u4e3a\u540c\u6837\u7684\u95ee\u9898\u5d29\u6e83\u3002 \u597d\u7684\uff0c\u6211\u4eec\u6e05\u695a\u8fd9\u4e2a\u95ee\u9898\u4e86\u3002\u6211\u4eec\u5982\u4f55\u89e3\u51b3\u5b83\uff1f \u80fd\u591f\u89e3\u51b3\u7684\u65b9\u6cd5\u4e4b\u4e00\u5c31\u662f\u663e\u5f0f\u7684\u5b9a\u4e49\u5220\u9664\u62f7\u8d1d\u6784\u9020\u548c\u8d4b\u503c\u64cd\u4f5c\u7b26\uff0c\u4ece\u800c\u963b\u6b62\u4e86\u4efb\u4f55\u62f7\u8d1d\u4ece\u539f\u59cb\u5bf9\u8c61\u590d\u5236\u51fa\u6765\uff0c\u90a3\u4f1a\u963b\u6b62\u503c\u4f20\u503c\uff08\u90a3\u65f6\u5f88\u68d2\u7684\uff0c\u65e0\u8bba\u5982\u4f55\u6211\u4eec\u90fd\u4e0d\u5e94\u8be5\u5728\u8fd9\u4e2a\u60c5\u51b5\u4e0b\u4f7f\u7528\u503c\u4f20\u503c\uff09\u3002 \u4f46\u662f\u7d27\u63a5\u7740\u8fd4\u56de\u4e00\u4e2a Auto_ptr1 \u4ece\u4e00\u4e2a\u51fd\u6570\u8fd4\u56de\u5c06\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f ??? generateResource () { Resource * r = new Resource ; return Auto_ptr1 ( r ); } \u6211\u4eec\u4e0d\u80fd\u901a\u8fc7\u5f15\u7528\u8fd4\u56de Auto_ptr1 \uff0c\u56e0\u4e3a\u5c40\u90e8\u53d8\u91cf Auto_ptr1 \u5c06\u4f1a\u5728\u51fd\u6570\u7684\u672b\u5c3e\u88ab\u5220\u9664\uff0c\u5e76\u4e14\u8c03\u7528\u8005\u5c06\u4f1a\u5f97\u5230\u4e00\u4e2a\u60ac\u7a7a\u7684\u5f15\u7528\u3002\u901a\u8fc7\u5730\u5740\u8fd4\u56de\u6709\u540c\u6837\u7684\u95ee\u9898\u3002 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u5730\u5740\u8fd4\u56de\u6307\u9488 r \uff0c\u4f46\u662f\u6211\u4eec\u4e5f\u8bb8\u4f1a\u5fd8\u4e86\u4e4b\u540e\u5220\u9664 r \uff0c\u8fd9\u4e5f\u662f\u6211\u4eec\u4e4b\u6240\u4ee5\u4f7f\u7528\u667a\u80fd\u6307\u9488\u7684\u539f\u56e0\u3002\u56e0\u6b64\u90a3\u6beb\u65e0\u7591\u95ee\uff0c\u901a\u8fc7\u503c\u8fd4\u56de Auto_ptr1 \u662f\u552f\u4e00\u6709\u610f\u4e49\u7684\u9009\u9879 \u2014\u2014 \u4f46\u662f\u7d27\u63a5\u7740\u6211\u4eec\u5c31\u4f1a\u4ee5\u6d45\u62f7\u8d1d\uff0c\u590d\u5236\u6307\u9488\uff0c\u6700\u540e\u5d29\u6e83\u3002 \u53e6\u4e00\u4e2a\u9009\u9879\u5c31\u662f\u91cd\u5199\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u64cd\u4f5c\u7b26\u6765\u4fdd\u8bc1\u6df1\u62f7\u8d1d\u3002\u4ee5\u8fd9\u4e2a\u65b9\u5f0f\uff0c\u6211\u4eec\u81f3\u5c11\u80fd\u4fdd\u8bc1\u907f\u514d\u590d\u5236\u6307\u5411\u5171\u4e00\u4e2a\u5bf9\u8c61\u7684\u6307\u9488\u3002\u4f46\u662f\u6df1\u62f7\u8d1d\u662f\u6602\u8d35\u7684\uff08\u5e76\u4e14\u4e5f\u8bb8\u662f\u4e0d\u53ef\u53d6\u7684\u6216\u8005\u751a\u81f3\u662f\u4e0d\u53ef\u80fd\u7684\uff09\uff0c\u5e76\u4e14\u6211\u4eec\u4e0d\u60f3\u4e3a\u4e86\u4ece\u51fd\u6570\u4e2d\u8fd4\u56de Auto-ptr1 \u4ece\u800c\u5bf9\u5bf9\u8c61\u8fdb\u884c\u4e0d\u5fc5\u8981\u7684\u590d\u5236\u3002\u53e6\u5916\uff0c\u5206\u914d\u6216\u521d\u59cb\u5316\u4e00\u4e2a\u7b28\u6307\u9488\u5e76\u4e0d\u4f1a\u590d\u5236\u6240\u6307\u5411\u7684\u5bf9\u8c61\uff0c\u90a3\u4e48\u4e3a\u4ec0\u4e48\u6211\u4eec\u5e0c\u671b\u667a\u80fd\u6307\u9488\u7684\u884c\u4e3a\u6709\u6240\u4e0d\u540c\u5462\uff1f \u6211\u4eec\u8be5\u600e\u4e48\u529e\uff1f","title":"\u4e00\u4e2a\u5f88\u5173\u952e\u7684\u7f3a\u9677"},{"location":"15-move-semantics-and-smart-pointers/15.1-intro-to-smart-pointers-and-move-semantics/#_3","text":"\u5982\u679c\u4e0d\u662f\u8ba9\u590d\u5236\u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u8fd0\u7b97\u7b26\u590d\u5236\u6307\u9488\uff08\u201c\u590d\u5236\u8bed\u4e49\u201d\uff09\uff0c\u800c\u662f\u5c06\u6307\u9488\u7684\u6240\u6709\u6743\u4ece\u6e90\u5bf9\u8c61\u8f6c\u79fb/\u79fb\u52a8\u5230\u76ee\u6807\u5bf9\u8c61\u5462\uff1f\u8fd9\u662fmove\u8bed\u4e49\u80cc\u540e\u7684\u6838\u5fc3\u601d\u60f3\u3002\u79fb\u52a8\u8bed\u4e49\u610f\u5473\u7740\u7c7b\u5c06\u8f6c\u79fb\u5bf9\u8c61\u7684\u6240\u6709\u6743\uff0c\u800c\u4e0d\u662f\u8fdb\u884c\u590d\u5236\u3002 \u8ba9\u6211\u4eec\u4f60\u66f4\u65b0\u6211\u4eec\u7684 Auto_ptr1 \u7c7b\u6765\u5c55\u793a\u8fd9\u5982\u4f55\u5b8c\u6210\uff1a # include <iostream> template < class T > class Auto_ptr2 { T * m_ptr ; public : Auto_ptr2 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr2 () { delete m_ptr ; } // A copy constructor that implements move semantics Auto_ptr2 ( Auto_ptr2 & a ) // note: not const { m_ptr = a . m_ptr ; // transfer our dumb pointer from the source to our local object a . m_ptr = nullptr ; // make sure the source no longer owns the pointer } // An assignment operator that implements move semantics Auto_ptr2 & operator = ( Auto_ptr2 & a ) // note: not const { if ( & a == this ) return * this ; delete m_ptr ; // make sure we deallocate any pointer the destination is already holding first m_ptr = a . m_ptr ; // then transfer our dumb pointer from the source to the local object a . m_ptr = nullptr ; // make sure the source no longer owns the pointer return * this ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } bool isNull () const { return m_ptr == nullptr ; } }; class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { Auto_ptr2 < Resource > res1 ( new Resource ); Auto_ptr2 < Resource > res2 ; // Start as nullptr std :: cout << \"res1 is \" << ( res1 . isNull () ? \"null \\n \" : \"not null \\n \" ); std :: cout << \"res2 is \" << ( res2 . isNull () ? \"null \\n \" : \"not null \\n \" ); res2 = res1 ; // res2 assumes ownership, res1 is set to null std :: cout << \"Ownership transferred \\n \" ; std :: cout << \"res1 is \" << ( res1 . isNull () ? \"null \\n \" : \"not null \\n \" ); std :: cout << \"res2 is \" << ( res2 . isNull () ? \"null \\n \" : \"not null \\n \" ); return 0 ; } \u8fd9\u4e2a\u6253\u5370\u51fa\uff1a Resource acquired res1 is not null res2 is null Ownership transferred res1 is null res2 is not null Resource destroyed \u6ce8\u610f\u6211\u4eec\u91cd\u8f7d\u4e86 operator= \u5c06 m_ptr \u7684\u6240\u6709\u6743\u4ece res1 \u9012\u4ea4\u7ed9 res2 \uff01\u56e0\u6b64\u6211\u4eec\u4e0d\u4f1a\u590d\u5236\u6307\u9488\u7684\u62f7\u8d1d\uff0c\u5e76\u4e14\u6240\u6709\u4e8b\u90fd\u88ab\u6574\u9f50\u7684\u6e05\u7406\u5e72\u51c0\u3002","title":"\u79fb\u52a8\u8bed\u4e49"},{"location":"15-move-semantics-and-smart-pointers/15.1-intro-to-smart-pointers-and-move-semantics/#stdauto_ptr","text":"\u73b0\u5728\u662f\u5408\u9002\u7684\u5b9e\u673a\u6765\u8bb2 std::auto_ptr \u4e86\uff0c std::auto_ptr \uff0c\u5728 C++98 \u4e2d\u5f15\u8fdb\uff0c\u662f C++ \u7684\u7b2c\u4e00\u6b21\u5c1d\u8bd5\u5b9e\u73b0\u4e00\u4e2a\u6807\u51c6\u7684\u53ea\u80fd\u6307\u9488\u3002 std::auto_ptr \u9009\u62e9\u4e86\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\u5c31\u50cf Auto_ptr2 \u7c7b\u505a\u7684\u90a3\u6837\u3002 \u7136\u800c\uff0c std::auto_ptr \uff08\u548c\u6211\u4eec\u7684 Auto_ptr2 \u7c7b\u4e00\u6837\uff09\u6709\u4e00\u5927\u5806\u95ee\u9898\uff0c\u4f7f\u5f97\u7528\u8d77\u6765\u975e\u5e38\u7684\u5371\u9669\u3002 \u9996\u5148\uff1a \u7531\u4e8e std::auto_ptr \u901a\u8fc7copy\u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u8fd0\u7b97\u7b26\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49(move semantics)\uff0c\u56e0\u6b64\u6309\u503c\u5411\u51fd\u6570\u4f20\u9012 std::auto_ptr \u5c06\u5bfc\u81f4\u8d44\u6e90\u79fb\u52a8\u5230\u51fd\u6570\u53c2\u6570\uff08\u5f53\u51fd\u6570\u53c2\u6570\u79bb\u5f00\u4f5c\u7528\u57df\u540e\uff0c\u53c2\u6570\u5728\u51fd\u6570\u672b\u5c3e\u9500\u6bc1\uff09\u3002\u7136\u540e\u5f53\u4f60\u4ece\u8c03\u7528\u8005\u90a3\u91cc\u8bbf\u95ee\u4f60\u7684 auto_ptr \u53c2\u6570\u65f6\uff08\u6ca1\u6709\u610f\u8bc6\u5230\u5b83\u5df2\u7ecf\u88ab\u8f6c\u79fb\u548c\u5220\u9664\uff09\uff0c\u4f60\u7a81\u7136\u5bf9\u7a7a\u6307\u9488\u7684\u53d6\u503c\u3002\u5bfc\u81f4\u5d29\u6e83 \u7b2c\u4e8c\uff1a std::auto_ptr \u603b\u662f\u7528\u975e\u6570\u7ec4\u5220\u9664\u5b83\u7684\u5185\u5bb9\u3002\u8fd9\u610f\u5473\u8fd9 auto_ptr \u5728\u52a8\u6001\u5206\u914d\u6570\u7ec4\u5185\u5b58\u7684\u60c5\u51b5\u4e0b\uff0c\u4e0d\u80fd\u6b63\u786e\u7684\u5de5\u4f5c\uff0c\u56e0\u4e3a\u5b83\u4f7f\u7528\u4e86\u9519\u8bef\u7684\u91ca\u653e\u7b26\u53f7\u3002\u66f4\u7cdf\u7cd5\u7684\u662f\uff0c\u5b83\u4e0d\u5141\u8bb8\u4f60\u4f20\u4e00\u4e2a\u52a8\u6001\u7684\u6570\u7ec4\uff0c\u56e0\u4e3a\u8fd9\u6837\u505a\u5b83\u5c31\u4f1a\u5931\u53bb\u7ba1\u7406\uff0c\u5bfc\u81f4\u5185\u5b58\u6cc4\u9732\u3002 \u6700\u540e\uff1a std::auto_ptr \u4e0d\u80fd\u548c\u5176\u4ed6\u6807\u51c6\u5e93\u4e2d\u7684\u7c7b\u642d\u914d\u4f7f\u7528\uff0c\u5305\u62ec\u5927\u91cf\u7684\u5bb9\u5668\u548c\u7b97\u6cd5\u3002\u8fd9\u4f1a\u53d1\u751f\u5c31\u662f\u56e0\u4e3a\u90a3\u4e9b\u6807\u51c6\u5e93\u5047\u8bbe\u5f53\u4ed6\u4eec\u62f7\u8d1d\u4e00\u4e2a\u5bf9\u8c61\u7684\u65f6\u5019\uff0c\u5b9e\u9645\u4e0a\u662f\u62f7\u8d1d\u800c\u4e0d\u662f\u79fb\u52a8\u3002 \u56e0\u4e3a\u4ee5\u4e0a\u63d0\u5230\u7684\u7f3a\u70b9\uff0c std::auto_ptr \u5728 C++11 \u4e2d\u5df2\u7ecf\u88ab\u79fb\u9664\uff0c\u5e76\u4e14\u4e0d\u5e94\u8be5\u88ab\u4f7f\u7528\u3002\u4e8b\u5b9e\u4e0a std::auto_ptr \u5728 C++17 \u4e2d\u624d\u88ab\u4ece\u6807\u51c6\u5e93\u4e2d\u5b8c\u5168\u79fb\u9664\u3002 Rule: std::auto_ptr is deprecated and should not be used. (Use std::unique_ptr or std::shared_ptr instead).. \u89c4\u5219\uff1a std::auto_ptr \u662f\u88ab\u629b\u5f03\u7684\uff0c\u5e76\u4e14\u4e0d\u5e94\u8be5\u88ab\u4f7f\u7528\u3002\uff08\u4f7f\u7528 std::unique_ptr or std::shared_ptr \u66ff\u6362\u4ed6\uff09\u2026\u2026","title":"std::auto_ptr \u548c\u4e3a\u4f55\u907f\u514d\u4f7f\u7528"},{"location":"15-move-semantics-and-smart-pointers/15.1-intro-to-smart-pointers-and-move-semantics/#_4","text":"\u5728 C++11 \u4e4b\u524d std::auto_ptr \u7684\u6838\u5fc3\u8bbe\u8ba1\u95ee\u9898\uff0c\u662f C++ \u8bed\u8a00\u6ca1\u6709\u4e00\u4e2a\u7b80\u5355\u7684\u673a\u5236\u6765\u5206\u8fa8\u62f7\u8d1d\u8bed\u4e49\u548c\u79fb\u52a8\u8bed\u4e49\u3002\u91cd\u5199\u62f7\u8d1d\u8bed\u4e49\u6765\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\uff0c\u65e0\u610f\u4e2d\u5f15\u8d77\u4e86\u95ee\u9898\u3002\u4f8b\u5982\uff0c\u4f60\u53ef\u4ee5\u5199 res1 = res2 \u5e76\u4e14\u6ca1\u529e\u6cd5\u77e5\u9053 res2 \u662f\u5426\u4f1a\u88ab\u6539\u53d8\uff01 \u56e0\u4e3a\u8fd9\u4e2a\uff0c\u5728 C++11\u4e2d\uff0c\u201d\u79fb\u52a8\u201d\u8fd9\u4e2a\u6982\u5ff5\u88ab\u6b63\u5f0f\u7684\u5b9a\u4e49\uff0c\u5e76\u4e14\u201d\u79fb\u52a8\u8bed\u4e49\u201c\u88ab\u6dfb\u52a0\u5230\u8bed\u8a00\u4e2d\u6765\u5408\u9002\u7684\u5206\u8fa8\u62f7\u8d1d(copying)\u548c\u79fb\u52a8(moving)\u3002\u65e2\u7136\u6211\u4eec\u5df2\u7ecf\u4e3a\"\u4e3a\u4f55\u79fb\u52a8\u8bed\u4e49\u662f\u6709\u7528\u7684\"\u505a\u597d\u4e86\u51c6\u5907\uff0c\u6211\u4eec\u5c06\u5728\u672c\u7ae0\u7684\u5176\u4f59\u90e8\u5206\u4e2d\u63a2\u8ba8\"\u79fb\u52a8\u8bed\u4e49\"\u7684\u4e3b\u9898\u3002\u6211\u4eec\u8fd8\u5c06\u4f7f\u7528move\u8bed\u4e49\u4fee\u590dAuto ptr2\u7c7b\u3002 \u5728 C++11\u4e2d\uff0c std::auto_ptr \u5df2\u7ecf\u88ab\u4e00\u5806\u5176\u4ed6\u7c7b\u578b\u7684\u201cmove-aware\u201d\u53ea\u80fd\u6307\u6b63\u6240\u66ff\u6362\uff1a std::unique_ptr \uff0c std::weak_ptr \uff0c\u548c std::shared_ptr \u3002\u6211\u4eec\u5c06\u4e5f\u63a2\u7d22\u8fd9\u4e9b\u4e2d\u6700\u8457\u540d\u7684\u4e24\u4e2a\uff1a unique_ptr (\u76f4\u63a5\u7528\u6765\u66ff\u6362 std::auto_ptr \u7684) \u548c shared_ptr .","title":"\u5411\u524d\u770b"},{"location":"15-move-semantics-and-smart-pointers/15.2-r-value-reference/","text":"15.2 \u53f3\u503c\u5f15\u7528 \u00b6 By Alex on February 20 th , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 7-17 \u56de\u5230 \u7b2c\u4e00\u7ae0 \u6211\u4eec\u8ba8\u8bba\u4e86\u5de6\u503c\u548c\u53f3\u503c\uff0c\u7136\u540e\u544a\u8bc9\u4f60\u4e0d\u8981\u592a\u62c5\u5fc3\u4ed6\u4eec\u3002\u5728 C++11 \u4e4b\u524d\uff0c\u8fd9\u662f\u4e00\u4e2a\u516c\u5e73\u7684\u5efa\u8bae\u3002\u4f46\u662f\u7406\u89e3 C++11 \u4e2d\u7684\u79fb\u52a8\u8bed\u4e49\u9700\u8981\u5bf9\u8fd9\u4e2a\u4e3b\u9898\u8fdb\u884c\u91cd\u65b0\u5b66\u4e60\u3002\u6240\u4ee5\u73b0\u5728\u5c31\u5f00\u59cb\u5427\u3002 \u5de6\u503c\u548c\u53f3\u503c \u00b6 \u5c3d\u7ba1\u540d\u79f0\u4e2d\u6709 \u201c\u503c\u201d \u4e00\u8bcd\uff0c\u4f46 \u5de6\u503c \u548c \u53f3\u503c \u5b9e\u9645\u4e0a\u4e0d\u662f \u503c \u7684\u5c5e\u6027\uff0c\u800c\u662f\u8868\u8fbe\u5f0f\u7684\u5c5e\u6027\u3002 C++\u4e2d\u7684\u6bcf\u4e2a\u8868\u8fbe\u5f0f\u90fd\u6709\u4e24\u4e2a\u5c5e\u6027\uff1a\u4e00\u4e2a\u7c7b\u578b\uff08\u7528\u4e8e\u7c7b\u578b\u68c0\u67e5\uff09\u548c\u4e00\u4e2a\u503c\u7c7b\u522b\uff08\u7528\u4e8e\u67d0\u4e9b\u7c7b\u578b\u7684\u8bed\u6cd5\u68c0\u67e5\uff0c\u4f8b\u5982\u8868\u8fbe\u5f0f\u7684\u7ed3\u679c\u662f\u5426\u53ef\u4ee5\u5206\u914d\uff09\u3002\u5728C++ 03\u548c\u66f4\u65e9\u7684\u65f6\u5019\uff0c\u5de6\u503c\u548c\u53f3\u503c\u662f\u4ec5\u6709\u7684\u4e24\u4e2a\u53ef\u7528\u7684\u503c\u7c7b\u522b\u3002 \u5bf9\u4e8e\u54ea\u4e9b\u8868\u8fbe\u5f0f\u662f\u5de6\u503c\uff0c\u54ea\u4e9b\u662f\u53f3\u503c\u7684\u5b9e\u9645\u5b9a\u4e49\u975e\u5e38\u590d\u6742\uff0c\u56e0\u6b64\u6211\u4eec\u5c06\u5bf9\u8fd9\u4e2a\u4e3b\u9898\u91c7\u53d6\u7b80\u5316\u7684\u89c2\u70b9\uff0c\u8fd9\u5728\u5f88\u5927\u7a0b\u5ea6\u4e0a\u6ee1\u8db3\u4e86\u6211\u4eec\u7684\u76ee\u7684\u3002 \u7b80\u5355\u70b9\u53ef\u4ee5\u8ba4\u4e3a\u5de6\u503c\uff08\u4e5f\u79f0\u4e3a\u5b9a\u4f4d\u5668\u503c[locator value]\uff09\u662f\u51fd\u6570\u6216\u5bf9\u8c61\uff08\u6216\u8ba1\u7b97\u4e3a\u51fd\u6570\u6216\u5bf9\u8c61\u7684\u8868\u8fbe\u5f0f\uff09\u6240\u6709\u5de6\u503c\u90fd\u5206\u914d\u4e86\u5185\u5b58\u5730\u5740\u3002 \u5f53\u5de6\u503c\u6700\u521d\u88ab\u5b9a\u4e49\u65f6\uff0c\u5b83\u4eec\u88ab\u5b9a\u4e49\u4e3a\u201c\u9002\u5408\u4f4d\u4e8e\u8d4b\u503c\u8868\u8fbe\u5f0f\u5de6\u4fa7\u7684\u503c\u201d\u3002\u7136\u800c\uff0c\u540e\u6765\uff0cconst\u5173\u952e\u5b57\u88ab\u6dfb\u52a0\u5230\u8bed\u8a00\u4e2d\uff0c\u5e76\u4e14\u5de6\u503c\u88ab\u5206\u4e3a\u4e24\u4e2a\u5b50\u7c7b\uff1a\u53ef\u4fee\u6539\u7684\u5de6\u503c\uff08\u53ef\u4ee5\u66f4\u6539\uff09\u548c\u4e0d\u53ef\u4fee\u6539\u7684\u5de6\u503c\uff08const\uff09\u3002 It\u2019s simplest to think of an r-value as \u201ceverything that is not an l-value\u201d. This notably includes literals (e.g. 5), temporary values (e.g. x+1), and anonymous objects (e.g. Fraction(5, 2)). r-values are typically evaluated for their values, have expression scope (they die at the end of the expression they are in), and cannot be assigned to. This non-assignment rule makes sense, because assigning a value applies a side-effect to the object. Since r-values have expression scope, if we were to assign a value to an r-value, then the r-value would either go out of scope before we had a chance to use the assigned value in the next expression (which makes the assignment useless) or we\u2019d have to use a variable with a side effect applied more than once in an expression (which by now you should know causes undefined behavior!). \u6700\u7b80\u5355\u7684\u65b9\u6cd5\u662f\u628a\u53f3\u503c\u770b\u4f5c\u201c\u4e0d\u662fl\u503c\u7684\u6240\u6709\u4e1c\u897f\u201d\u3002\u8fd9\u7279\u522b\u5305\u62ec\u5b57\u9762\u503c\uff08\u4f8b\u5982 5 \uff09\u3001\u4e34\u65f6\u503c\uff08\u4f8b\u5982 x+1 \uff09\u548c\u533f\u540d\u5bf9\u8c61\uff08\u4f8b\u5982 Fraction(5, 2) \uff09\u3002\u53f3\u503c\u901a\u5e38\u662f\u9488\u5bf9\u5176\u503c\u8fdb\u884c\u6c42\u503c\u7684\uff0c\u5177\u6709\u8868\u8fbe\u5f0f\u8303\u56f4\uff08\u5b83\u4eec\u5728\u5176\u6240\u5728\u8868\u8fbe\u5f0f\u7684\u7ed3\u5c3e\u5904\u6d88\u4ea1\uff09\uff0c\u5e76\u4e14\u4e0d\u80fd\u88ab\u8d4b\u503c\u3002\u8fd9\u4e2a\u975e\u8d4b\u503c\u89c4\u5219\u662f\u6709\u610f\u4e49\u7684\uff0c\u56e0\u4e3a\u8d4b\u503c\u4f1a\u7ed9\u5bf9\u8c61\u5e26\u6765\u526f\u4f5c\u7528\u3002\u56e0\u4e3a\u53f3\u503c\u6709\u8868\u8fbe\u5f0f\u8303\u56f4\uff0c\u5982\u679c\u6211\u4eec\u8981\u7ed9\u53f3\u503c\u8d4b\u503c\uff0c\u90a3\u4e48\u53f3\u503c\u4f1a\u5728\u6211\u4eec\u6709\u673a\u4f1a\u5728\u4e0b\u4e00\u4e2a\u8868\u8fbe\u5f0f\u4e2d\u4f7f\u7528\u4e0a\u6b21\u8d4b\u503c\u4e4b\u524d\u5c31\u8d85\u51fa\u4e86\u8303\u56f4\uff08\u8fd9\u4f7f\u5f97\u8d4b\u503c\u6beb\u65e0\u7528\u5904\uff09\uff0c\u8981\u4e48\u6211\u4eec\u5fc5\u987b\u4f7f\u7528\u4e00\u4e2a\u53d8\u91cf\uff0c\u5728\u4e00\u4e2a\u8868\u8fbe\u5f0f\u4e2d\u591a\u6b21\u5e94\u7528\u4e00\u4e2a\u526f\u4f5c\u7528\uff08\u73b0\u5728\u60a8\u5e94\u8be5\u77e5\u9053\u8fd9\u4f1a\u5bfc\u81f4\u672a\u5b9a\u4e49\u7684\u884c\u4e3a\uff01\uff09\u3002 In order to support move semantics, C++11 introduces 3 new value categories: pr-values, x-values, and gl-values. We will largely ignore these since understanding them isn\u2019t necessary to learn about or use move semantics effectively. If you\u2019re interested, cppreference.com has an extensive list of expressions that qualify for each of the various value categories, as well as more detail about them. L-value references Prior to C++11, only one type of reference existed in C++, and so it was just called a \u201creference\u201d. However, in C++11, it\u2019s sometimes called an l-value reference. L-value references can only be initialized with modifiable l-values. L-value reference Can be initialized with Can modify Modifiable l-values Yes Yes Non-modifiable l-values No No R-values No No L-value references to const objects can be initialized with l-values and r-values alike. However, those values can\u2019t be modified. L-value reference to const Can be initialized with Can modify Modifiable l-values Yes No Non-modifiable l-values Yes No R-values Yes No L-value references to const objects are particularly useful because they allow us to pass any type of argument (l-value or r-value) into a function without making a copy of the argument. R-value references C++11 adds a new type of reference called an r-value reference. An r-value reference is a reference that is designed to be initialized with an r-value (only). While an l-value reference is created using a single ampersand, an r-value reference is created using a double ampersand: int x { 5 }; int & lref { x }; // l-value reference initialized with l-value x int && rref { 5 }; // r-value reference initialized with r-value 5 R-value reference Can be initialized with Can modify Modifiable l-values No No Non-modifiable l-values No No R-values Yes Yes R-value reference to const Can be initialized with Can modify Modifiable l-values No No Non-modifiable l-values No No R-values Yes No R-value references have two properties that are useful. First, r-value references extend the lifespan of the object they are initialized with to the lifespan of the r-value reference (l-value references to const objects can do this too). Second, non-const r-value references allow you to modify the r-value! Let\u2019s take a look at some examples: # include <iostream> class Fraction { private : int m_numerator ; int m_denominator ; public : Fraction ( int numerator = 0 , int denominator = 1 ) : m_numerator { numerator }, m_denominator { denominator } { } friend std :: ostream & operator << ( std :: ostream & out , const Fraction & f1 ) { out << f1 . m_numerator << '/' << f1 . m_denominator ; return out ; } }; int main () { auto && rref { Fraction { 3 , 5 } }; // r-value reference to temporary Fraction // f1 of operator<< binds to the temporary, no copies are created. std :: cout << rref << '\\n' ; return 0 ; } // rref (and the temporary Fraction) goes out of scope here This program prints: \u2157 As an anonymous object, Fraction(3, 5) would normally go out of scope at the end of the expression in which it is defined. However, since we\u2019re initializing an r-value reference with it, its duration is extended until the end of the block. We can then use that r-value reference to print the Fraction\u2019s value. Now let\u2019s take a look at a less intuitive example: # include <iostream> int main () { int && rref { 5 }; // because we're initializing an r-value reference with a literal, a temporary with value 5 is created here rref = 10 ; std :: cout << rref << '\\n' ; return 0 ; } This program prints: 10 While it may seem weird to initialize an r-value reference with a literal value and then be able to change that value, when initializing an r-value with a literal, a temporary is constructed from the literal so that the reference is referencing a temporary object, not a literal value. R-value references are not very often used in either of the manners illustrated above. R-value references as function parameters R-value references are more often used as function parameters. This is most useful for function overloads when you want to have different behavior for l-value and r-value arguments. void fun ( const int & lref ) // l-value arguments will select this function { std :: cout << \"l-value reference to const \\n \" ; } void fun ( int && rref ) // r-value arguments will select this function { std :: cout << \"r-value reference \\n \" ; } int main () { int x { 5 }; fun ( x ); // l-value argument calls l-value version of function fun ( 5 ); // r-value argument calls r-value version of function return 0 ; } This prints: l-value reference to const r-value reference As you can see, when passed an l-value, the overloaded function resolved to the version with the l-value reference. When passed an r-value, the overloaded function resolved to the version with the r-value reference (this is considered a better match than a l-value reference to const). Why would you ever want to do this? We\u2019ll discuss this in more detail in the next lesson. Needless to say, it\u2019s an important part of move semantics. One interesting note: int && ref { 5 }; fun ( ref ); actually calls the l-value version of the function! Although variable ref has type r-value reference to an integer, it is actually an l-value itself (as are all named variables). The confusion stems from the use of the term r-value in two different contexts. Think of it this way: Named-objects are l-values. Anonymous objects are r-values. The type of the named object or anonymous object is independent from whether it\u2019s an l-value or r-value. Or, put another way, if r-value reference had been called anything else, this confusion wouldn\u2019t exist. Returning an r-value reference You should almost never return an r-value reference, for the same reason you should almost never return an l-value reference. In most cases, you\u2019ll end up returning a hanging reference when the referenced object goes out of scope at the end of the function. Quiz time 1) State which of the following lettered statements will not compile: int main () { int x {}; // l-value references int & ref1 { x }; // A int & ref2 { 5 }; // B const int & ref3 { x }; // C const int & ref4 { 5 }; // D // r-value references int && ref5 { x }; // E int && ref6 { 5 }; // F const int && ref7 { x }; // G const int && ref8 { 5 }; // H return 0 ; } Hide Solution B, E, and G won\u2019t compile.","title":"15.2 \u53f3\u503c\u5f15\u7528"},{"location":"15-move-semantics-and-smart-pointers/15.2-r-value-reference/#152","text":"By Alex on February 20 th , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 7-17 \u56de\u5230 \u7b2c\u4e00\u7ae0 \u6211\u4eec\u8ba8\u8bba\u4e86\u5de6\u503c\u548c\u53f3\u503c\uff0c\u7136\u540e\u544a\u8bc9\u4f60\u4e0d\u8981\u592a\u62c5\u5fc3\u4ed6\u4eec\u3002\u5728 C++11 \u4e4b\u524d\uff0c\u8fd9\u662f\u4e00\u4e2a\u516c\u5e73\u7684\u5efa\u8bae\u3002\u4f46\u662f\u7406\u89e3 C++11 \u4e2d\u7684\u79fb\u52a8\u8bed\u4e49\u9700\u8981\u5bf9\u8fd9\u4e2a\u4e3b\u9898\u8fdb\u884c\u91cd\u65b0\u5b66\u4e60\u3002\u6240\u4ee5\u73b0\u5728\u5c31\u5f00\u59cb\u5427\u3002","title":"15.2 \u53f3\u503c\u5f15\u7528"},{"location":"15-move-semantics-and-smart-pointers/15.2-r-value-reference/#_1","text":"\u5c3d\u7ba1\u540d\u79f0\u4e2d\u6709 \u201c\u503c\u201d \u4e00\u8bcd\uff0c\u4f46 \u5de6\u503c \u548c \u53f3\u503c \u5b9e\u9645\u4e0a\u4e0d\u662f \u503c \u7684\u5c5e\u6027\uff0c\u800c\u662f\u8868\u8fbe\u5f0f\u7684\u5c5e\u6027\u3002 C++\u4e2d\u7684\u6bcf\u4e2a\u8868\u8fbe\u5f0f\u90fd\u6709\u4e24\u4e2a\u5c5e\u6027\uff1a\u4e00\u4e2a\u7c7b\u578b\uff08\u7528\u4e8e\u7c7b\u578b\u68c0\u67e5\uff09\u548c\u4e00\u4e2a\u503c\u7c7b\u522b\uff08\u7528\u4e8e\u67d0\u4e9b\u7c7b\u578b\u7684\u8bed\u6cd5\u68c0\u67e5\uff0c\u4f8b\u5982\u8868\u8fbe\u5f0f\u7684\u7ed3\u679c\u662f\u5426\u53ef\u4ee5\u5206\u914d\uff09\u3002\u5728C++ 03\u548c\u66f4\u65e9\u7684\u65f6\u5019\uff0c\u5de6\u503c\u548c\u53f3\u503c\u662f\u4ec5\u6709\u7684\u4e24\u4e2a\u53ef\u7528\u7684\u503c\u7c7b\u522b\u3002 \u5bf9\u4e8e\u54ea\u4e9b\u8868\u8fbe\u5f0f\u662f\u5de6\u503c\uff0c\u54ea\u4e9b\u662f\u53f3\u503c\u7684\u5b9e\u9645\u5b9a\u4e49\u975e\u5e38\u590d\u6742\uff0c\u56e0\u6b64\u6211\u4eec\u5c06\u5bf9\u8fd9\u4e2a\u4e3b\u9898\u91c7\u53d6\u7b80\u5316\u7684\u89c2\u70b9\uff0c\u8fd9\u5728\u5f88\u5927\u7a0b\u5ea6\u4e0a\u6ee1\u8db3\u4e86\u6211\u4eec\u7684\u76ee\u7684\u3002 \u7b80\u5355\u70b9\u53ef\u4ee5\u8ba4\u4e3a\u5de6\u503c\uff08\u4e5f\u79f0\u4e3a\u5b9a\u4f4d\u5668\u503c[locator value]\uff09\u662f\u51fd\u6570\u6216\u5bf9\u8c61\uff08\u6216\u8ba1\u7b97\u4e3a\u51fd\u6570\u6216\u5bf9\u8c61\u7684\u8868\u8fbe\u5f0f\uff09\u6240\u6709\u5de6\u503c\u90fd\u5206\u914d\u4e86\u5185\u5b58\u5730\u5740\u3002 \u5f53\u5de6\u503c\u6700\u521d\u88ab\u5b9a\u4e49\u65f6\uff0c\u5b83\u4eec\u88ab\u5b9a\u4e49\u4e3a\u201c\u9002\u5408\u4f4d\u4e8e\u8d4b\u503c\u8868\u8fbe\u5f0f\u5de6\u4fa7\u7684\u503c\u201d\u3002\u7136\u800c\uff0c\u540e\u6765\uff0cconst\u5173\u952e\u5b57\u88ab\u6dfb\u52a0\u5230\u8bed\u8a00\u4e2d\uff0c\u5e76\u4e14\u5de6\u503c\u88ab\u5206\u4e3a\u4e24\u4e2a\u5b50\u7c7b\uff1a\u53ef\u4fee\u6539\u7684\u5de6\u503c\uff08\u53ef\u4ee5\u66f4\u6539\uff09\u548c\u4e0d\u53ef\u4fee\u6539\u7684\u5de6\u503c\uff08const\uff09\u3002 It\u2019s simplest to think of an r-value as \u201ceverything that is not an l-value\u201d. This notably includes literals (e.g. 5), temporary values (e.g. x+1), and anonymous objects (e.g. Fraction(5, 2)). r-values are typically evaluated for their values, have expression scope (they die at the end of the expression they are in), and cannot be assigned to. This non-assignment rule makes sense, because assigning a value applies a side-effect to the object. Since r-values have expression scope, if we were to assign a value to an r-value, then the r-value would either go out of scope before we had a chance to use the assigned value in the next expression (which makes the assignment useless) or we\u2019d have to use a variable with a side effect applied more than once in an expression (which by now you should know causes undefined behavior!). \u6700\u7b80\u5355\u7684\u65b9\u6cd5\u662f\u628a\u53f3\u503c\u770b\u4f5c\u201c\u4e0d\u662fl\u503c\u7684\u6240\u6709\u4e1c\u897f\u201d\u3002\u8fd9\u7279\u522b\u5305\u62ec\u5b57\u9762\u503c\uff08\u4f8b\u5982 5 \uff09\u3001\u4e34\u65f6\u503c\uff08\u4f8b\u5982 x+1 \uff09\u548c\u533f\u540d\u5bf9\u8c61\uff08\u4f8b\u5982 Fraction(5, 2) \uff09\u3002\u53f3\u503c\u901a\u5e38\u662f\u9488\u5bf9\u5176\u503c\u8fdb\u884c\u6c42\u503c\u7684\uff0c\u5177\u6709\u8868\u8fbe\u5f0f\u8303\u56f4\uff08\u5b83\u4eec\u5728\u5176\u6240\u5728\u8868\u8fbe\u5f0f\u7684\u7ed3\u5c3e\u5904\u6d88\u4ea1\uff09\uff0c\u5e76\u4e14\u4e0d\u80fd\u88ab\u8d4b\u503c\u3002\u8fd9\u4e2a\u975e\u8d4b\u503c\u89c4\u5219\u662f\u6709\u610f\u4e49\u7684\uff0c\u56e0\u4e3a\u8d4b\u503c\u4f1a\u7ed9\u5bf9\u8c61\u5e26\u6765\u526f\u4f5c\u7528\u3002\u56e0\u4e3a\u53f3\u503c\u6709\u8868\u8fbe\u5f0f\u8303\u56f4\uff0c\u5982\u679c\u6211\u4eec\u8981\u7ed9\u53f3\u503c\u8d4b\u503c\uff0c\u90a3\u4e48\u53f3\u503c\u4f1a\u5728\u6211\u4eec\u6709\u673a\u4f1a\u5728\u4e0b\u4e00\u4e2a\u8868\u8fbe\u5f0f\u4e2d\u4f7f\u7528\u4e0a\u6b21\u8d4b\u503c\u4e4b\u524d\u5c31\u8d85\u51fa\u4e86\u8303\u56f4\uff08\u8fd9\u4f7f\u5f97\u8d4b\u503c\u6beb\u65e0\u7528\u5904\uff09\uff0c\u8981\u4e48\u6211\u4eec\u5fc5\u987b\u4f7f\u7528\u4e00\u4e2a\u53d8\u91cf\uff0c\u5728\u4e00\u4e2a\u8868\u8fbe\u5f0f\u4e2d\u591a\u6b21\u5e94\u7528\u4e00\u4e2a\u526f\u4f5c\u7528\uff08\u73b0\u5728\u60a8\u5e94\u8be5\u77e5\u9053\u8fd9\u4f1a\u5bfc\u81f4\u672a\u5b9a\u4e49\u7684\u884c\u4e3a\uff01\uff09\u3002 In order to support move semantics, C++11 introduces 3 new value categories: pr-values, x-values, and gl-values. We will largely ignore these since understanding them isn\u2019t necessary to learn about or use move semantics effectively. If you\u2019re interested, cppreference.com has an extensive list of expressions that qualify for each of the various value categories, as well as more detail about them. L-value references Prior to C++11, only one type of reference existed in C++, and so it was just called a \u201creference\u201d. However, in C++11, it\u2019s sometimes called an l-value reference. L-value references can only be initialized with modifiable l-values. L-value reference Can be initialized with Can modify Modifiable l-values Yes Yes Non-modifiable l-values No No R-values No No L-value references to const objects can be initialized with l-values and r-values alike. However, those values can\u2019t be modified. L-value reference to const Can be initialized with Can modify Modifiable l-values Yes No Non-modifiable l-values Yes No R-values Yes No L-value references to const objects are particularly useful because they allow us to pass any type of argument (l-value or r-value) into a function without making a copy of the argument. R-value references C++11 adds a new type of reference called an r-value reference. An r-value reference is a reference that is designed to be initialized with an r-value (only). While an l-value reference is created using a single ampersand, an r-value reference is created using a double ampersand: int x { 5 }; int & lref { x }; // l-value reference initialized with l-value x int && rref { 5 }; // r-value reference initialized with r-value 5 R-value reference Can be initialized with Can modify Modifiable l-values No No Non-modifiable l-values No No R-values Yes Yes R-value reference to const Can be initialized with Can modify Modifiable l-values No No Non-modifiable l-values No No R-values Yes No R-value references have two properties that are useful. First, r-value references extend the lifespan of the object they are initialized with to the lifespan of the r-value reference (l-value references to const objects can do this too). Second, non-const r-value references allow you to modify the r-value! Let\u2019s take a look at some examples: # include <iostream> class Fraction { private : int m_numerator ; int m_denominator ; public : Fraction ( int numerator = 0 , int denominator = 1 ) : m_numerator { numerator }, m_denominator { denominator } { } friend std :: ostream & operator << ( std :: ostream & out , const Fraction & f1 ) { out << f1 . m_numerator << '/' << f1 . m_denominator ; return out ; } }; int main () { auto && rref { Fraction { 3 , 5 } }; // r-value reference to temporary Fraction // f1 of operator<< binds to the temporary, no copies are created. std :: cout << rref << '\\n' ; return 0 ; } // rref (and the temporary Fraction) goes out of scope here This program prints: \u2157 As an anonymous object, Fraction(3, 5) would normally go out of scope at the end of the expression in which it is defined. However, since we\u2019re initializing an r-value reference with it, its duration is extended until the end of the block. We can then use that r-value reference to print the Fraction\u2019s value. Now let\u2019s take a look at a less intuitive example: # include <iostream> int main () { int && rref { 5 }; // because we're initializing an r-value reference with a literal, a temporary with value 5 is created here rref = 10 ; std :: cout << rref << '\\n' ; return 0 ; } This program prints: 10 While it may seem weird to initialize an r-value reference with a literal value and then be able to change that value, when initializing an r-value with a literal, a temporary is constructed from the literal so that the reference is referencing a temporary object, not a literal value. R-value references are not very often used in either of the manners illustrated above. R-value references as function parameters R-value references are more often used as function parameters. This is most useful for function overloads when you want to have different behavior for l-value and r-value arguments. void fun ( const int & lref ) // l-value arguments will select this function { std :: cout << \"l-value reference to const \\n \" ; } void fun ( int && rref ) // r-value arguments will select this function { std :: cout << \"r-value reference \\n \" ; } int main () { int x { 5 }; fun ( x ); // l-value argument calls l-value version of function fun ( 5 ); // r-value argument calls r-value version of function return 0 ; } This prints: l-value reference to const r-value reference As you can see, when passed an l-value, the overloaded function resolved to the version with the l-value reference. When passed an r-value, the overloaded function resolved to the version with the r-value reference (this is considered a better match than a l-value reference to const). Why would you ever want to do this? We\u2019ll discuss this in more detail in the next lesson. Needless to say, it\u2019s an important part of move semantics. One interesting note: int && ref { 5 }; fun ( ref ); actually calls the l-value version of the function! Although variable ref has type r-value reference to an integer, it is actually an l-value itself (as are all named variables). The confusion stems from the use of the term r-value in two different contexts. Think of it this way: Named-objects are l-values. Anonymous objects are r-values. The type of the named object or anonymous object is independent from whether it\u2019s an l-value or r-value. Or, put another way, if r-value reference had been called anything else, this confusion wouldn\u2019t exist. Returning an r-value reference You should almost never return an r-value reference, for the same reason you should almost never return an l-value reference. In most cases, you\u2019ll end up returning a hanging reference when the referenced object goes out of scope at the end of the function. Quiz time 1) State which of the following lettered statements will not compile: int main () { int x {}; // l-value references int & ref1 { x }; // A int & ref2 { 5 }; // B const int & ref3 { x }; // C const int & ref4 { 5 }; // D // r-value references int && ref5 { x }; // E int && ref6 { 5 }; // F const int && ref7 { x }; // G const int && ref8 { 5 }; // H return 0 ; } Hide Solution B, E, and G won\u2019t compile.","title":"\u5de6\u503c\u548c\u53f3\u503c"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/","text":"15.3 \u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c \u00b6 By Alex on February 26 th , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.17 \u5728\u8bfe\u7a0b 15.1 \u667a\u80fd\u6307\u9488\u548c\u79fb\u52a8\u8bed\u4e49\u7684\u4ecb\u7ecd \u4e2d, \u6211\u4eec\u4e86\u89e3\u5230\u4e86 std::auto ptr \uff0c\u8ba8\u8bba\u4e86\u5bf9\u79fb\u52a8\u8bed\u4e49\u7684\u9700\u6c42\uff0c\u5e76\u7814\u7a76\u4e86\u4e3a\u590d\u5236\u8bed\u4e49\u8bbe\u8ba1\u7684\u51fd\u6570\uff08\u590d\u5236\u6784\u9020\u51fd\u6570\u548c\u590d\u5236\u8d4b\u503c\u8fd0\u7b97\u7b26\uff09\uff0c\u4ee5\u53ca\u88ab\u91cd\u65b0\u5b9a\u4e49\u4e3a\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\u65f6\u51fa\u73b0\u7684\u4e00\u4e9b\u7f3a\u70b9\u3002 \u5728\u8fd9\u5802\u8bfe\u4e2d\uff0c\u6211\u4eec\u5c06\u6df1\u5165\u4e86\u89e3 C++11 \u662f\u5982\u4f55\u901a\u8fc7 \u79fb\u52a8\u6784\u9020\u51fd\u6570 \u548c \u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97 \u6765\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\u3002 \u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c \u00b6 \u9996\u5148\uff0c\u8ba9\u6211\u4eec\u590d\u4e60\u4e00\u4e0b\u62f7\u8d1d\u8bed\u4e49( copy semantics )\u3002 \u62f7\u8d1d\u6784\u9020\u51fd\u6570 \u901a\u8fc7\u521b\u5efa\u4e00\u4efd\u8be5\u7c7b\u7684\u62f7\u8d1d\u6765\u521d\u59cb\u5316\u4e00\u4e2a\u7c7b\u3002 \u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26 \u901a\u8fc7\u62f7\u8d1d\u4e00\u4e2a\u5df2\u5b58\u5728\u7c7b\u5bf9\u8c61\uff0c\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5bf9\u8c61\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u4e00\u4e2a\u7c7b\u6ca1\u6709\u663e\u5f0f\u7684\u63d0\u4f9b\uff0cC++ \u5c06\u4f1a\u9ed8\u8ba4\u63d0\u4f9b\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u3002\u8fd9\u4e9b\u7531\u7f16\u8bd1\u5668\u63d0\u4f9b\u7684\u51fd\u6570\u4ec5\u5b9e\u73b0\u4e86\u6d45\u62f7\u8d1d\uff0c\u5728\u8fdb\u884c\u52a8\u6001\u5206\u914d\u5185\u5b58\u7684\u7c7b\u5bf9\u8c61\u4e0a\u4f7f\u7528\u53ef\u80fd\u9020\u6210\u95ee\u9898\u3002\u56e0\u6b64\u5728\u6d89\u53ca\u52a8\u6001\u5185\u5b58\u5206\u914d\u7684\u7c7b\u5fc5\u987b\u901a\u8fc7\u91cd\u5199\u8fd9\u4e9b\u51fd\u6570\u6765\u8fdb\u884c\u6df1\u62f7\u8d1d\u3002 \u56de\u5230\u6211\u4eec\u672c\u7ae0\u7684\u524d\u4e9b\u8bfe\u4e2d\u63d0\u5230\u7684 Auto_ptr \u667a\u80fd\u6307\u9488\u7c7b\u7684\u4f8b\u5b50\uff0c\u8ba9\u6211\u4eec\u770b\u4e00\u773c\u5b9e\u73b0\u6df1\u62f7\u8d1d\u7684\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\uff0c\u8fd8\u6709\u4e00\u4e2a\u7b80\u5355\u7684\u7a0b\u5e8f\u6765\u6d4b\u8bd5\u4ed6\u4eec\uff1a template < class T > class Auto_ptr3 { T * m_ptr ; public : Auto_ptr3 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr3 () { delete m_ptr ; } // Copy constructor \u62f7\u8d1d\u6784\u9020\u51fd\u6570 // Do deep copy of a.m_ptr to m_ptr // \u4ece a.m_ptr \u5230 m_ptr \u8fdb\u884c\u6df1\u62f7\u8d1d Auto_ptr3 ( const Auto_ptr3 & a ) { m_ptr = new T ; * m_ptr = * a . m_ptr ; } // Copy assignment // \u62f7\u8d1d\u8d4b\u503c\u51fd\u6570 // Do deep copy of a.m_ptr to m_ptr // \u4ece a.m_ptr \u5230 m_ptr \u8fdb\u884c\u6df1\u62f7\u8d1d Auto_ptr3 & operator = ( const Auto_ptr3 & a ) { // Self-assignment detection // \u81ea\u8d4b\u503c\u68c0\u6d4b if ( & a == this ) return * this ; // \u91ca\u653e\u6240\u6709\u6301\u6709\u7684\u8d44\u6e90 // Release any resource we're holding delete m_ptr ; // \u62f7\u8d1d\u8d44\u6e90 // Copy the resource m_ptr = new T ; * m_ptr = * a . m_ptr ; return * this ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } bool isNull () const { return m_ptr == nullptr ; } }; class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; Auto_ptr3 < Resource > generateResource () { Auto_ptr3 < Resource > res ( new Resource ); return res ; // this return value will invoke the copy constructor // \u8fd9\u4e2a\u8fd4\u56de\u503c\u5c06\u4f1a\u89e6\u53d1\u62f7\u8d1d\u6784\u9020\u51fd\u6570 } int main () { Auto_ptr3 < Resource > mainres ; mainres = generateResource (); // this assignment will invoke the copy assignment // \u8fd9\u4e2a\u8d4b\u503c\u5c06\u4f1a\u89e6\u53d1\u8d4b\u503c\u8d4b\u503c\u51fd\u6570 return 0 ; } \u5728\u8fd9\u4e2a\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u4e00\u4e2a\u53eb\u505a generateResource() \u7684\u51fd\u6570\u6765\u521b\u5efa\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u5c01\u88c5\u7684 Resource \uff0c\u5e76\u4e14\u5c06\u5b83\u4f20\u56de\u5230 main \u51fd\u6570\u4e2d\u3002 main \u51fd\u6570\u7d27\u63a5\u7740\u5c06\u5176\u8d4b\u503c\u7ed9\u5df2\u7ecf\u5b58\u5728\u7684 Auto_ptr3 \u5bf9\u8c61 mainres \u3002 \u5f53\u8fd9\u4e2a\u7a0b\u5e8f\u8fd0\u884c\u7684\u65f6\u5019\uff0c\u6253\u5370\uff1a Resource acquired Resource acquired Resource destroyed Resource acquired Resource destroyed Resource destroyed \uff08\u6ce8\u610f\uff1a\u4f60\u53ef\u80fd\u53ea\u5f97\u52304\u4e2a\u8f93\u51fa\uff0c\u5982\u679c\u4f60\u7684\u7f16\u8bd1\u5668 \u7701\u7565\\\u4f18\u5316 \u4e86 generateResource() \u7684\u8fd4\u56de\u503c\uff09 \u90a3\u4f1a\u6709\u5f88\u591a\u6b21\u521b\u5efa\u548c\u9500\u6bc1\uff0c\u4ec5\u4ec5\u4e3a\u4e86\u8fd9\u6837\u4e00\u4e2a\u7b80\u5355\u7684\u7a0b\u5e8f\uff01\u53d1\u751f\u4e86\u4ec0\u4e48\uff1f \u8ba9\u6211\u4eec\u4ed4\u7ec6\u770b\u770b\uff0c\u7a0b\u5e8f\u91cc\u6709 6 \u4e2a\u5173\u952e\u6b65\u9aa4\uff08\u6bcf\u6b21\u6253\u5370\u90fd\u53d1\u751f\u4e00\u4ef6\uff09\uff1a 1; \u5728 generateResource() \u4e2d\uff0c\u5c40\u90e8\u53d8\u91cf res \u88ab\u521b\u5efa\u5e76\u7528\u521d\u59cb\u5316\u4e3a\u4e00\u4e2a\u52a8\u6001\u5206\u914d\u7684 Resource \u3002 2; Res \u503c\u8fd4\u56de\u5230 main() \u3002\u901a\u8fc7\u503c\u8fd4\u56de\u7684\u539f\u56e0\u662f\uff0c res \u662f\u4e00\u4e2a\u5c40\u90e8\u53d8\u91cf \u2014\u2014 \u5b83\u4e0d\u80fd\u88ab\u901a\u8fc7\u5730\u5740\u6216\u5f15\u7528\u8fd4\u56de\uff0c\u56e0\u4e3a res \u5c06\u4f1a\u5728 generateResource() \u51fd\u6570\u7ed3\u675f\u524d\u88ab\u9500\u6bc1 \u7ed3\u675f\u3002\u56e0\u4e3a res \u662f\u62f7\u8d1d\u6784\u9020\uff0c\u505a\u4e86\u4e00\u6b21\u6df1\u62f7\u8d1d\uff0c\u4e00\u4e2a\u65b0\u7684 Resource \u5728\u8fd9\u88ab\u5206\u914d\uff0c\u89e6\u53d1\u4e86\u7b2c\u4e8c\u6b21 \"Resource acquired\"\u3002 3; Res \u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u9500\u6bc1\u4e4b\u524d\u521b\u5efa\u7684 Resource \uff0c\u8fd9\u89e6\u53d1\u4e86\u7b2c\u4e00\u4e2a \"Resource destroyed\"\u3002 4; \u4e34\u65f6\u5bf9\u8c61\u88ab\u8d4b\u503c\u8fdb mainres \u901a\u8fc7\u62f7\u8d1d\u8d4b\u503c\u3002\u56e0\u4e3a\u6211\u4eec\u7684\u62f7\u8d1d\u8d4b\u503c\u4e5f\u505a\u4e86\u4e00\u6b21\u6df1\u62f7\u8d1d\uff0c\u4e00\u4e2a\u65b0\u7684 Reource \u88ab\u5206\u914d\uff0c\u89e6\u53d1\u4e86\u53e6\u4e00\u4e2a \"Resource acquired\"\u3002 5; \u8d4b\u503c\u8868\u8fbe\u5f0f\u7ed3\u5c3e\uff0c\u4e34\u65f6\u5bf9\u8c61\u79bb\u5f00\u4e86\u8868\u8fbe\u5f0f\u4f5c\u7528\u57df\u5e76\u4e14\u88ab\u9500\u6bc1\uff0c\u89e6\u53d1\u4e86\u4e00\u4e2a \"Resource acquired\"\u3002 6; \u5728 main() \u7684\u672b\u5c3e\uff0c mainres \u79bb\u5f00\u4e86\u4f5c\u7528\u57df\uff0c\u5e76\u4e14\u89e6\u53d1\u4e86\u6700\u540e\u4e00\u4e2a \"Resource destroyed\"\u3002 \u56e0\u6b64\uff0c\u7b80\u800c\u8a00\u4e4b\uff0c\u56e0\u4e3a\u6211\u4eec\u8c03\u7528\u4e86\u4e00\u6b21\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u6765\u62f7\u8d1d\u6784\u9020 res \u6210\u4e00\u4e2a\u4e34\u65f6\u53d8\u91cf\uff0c\u5e76\u8c03\u7528\u4e86\u4e00\u6b21\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u6765\u62f7\u8d1d\u4e34\u65f6\u53d8\u91cf\u8fdb\u5165 mainres \uff0c\u6211\u4eec\u6700\u7ec8\u5206\u914d\u548c\u9500\u6bc1\u4e863\u4e2a\u72ec\u7acb\u7684 objects \u603b\u8ba1\u3002 \u8fd9\u662f\u4f4e\u6548\u7684\uff0c\u4f46\u662f\u5b83\u81f3\u5c11\u4e0d\u4f1a\u5d29\u6e83\u3002 \u7136\u800c\u5982\u679c\u7528\u79fb\u52a8\u8bed\u4e49\uff0c\u6211\u4eec\u53ef\u4ee5\u505a\u7684\u66f4\u597d\u3002 \u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c \u00b6 C++ \u5b9a\u4e49\u4e86\u4e24\u4e2a\u65b0\u7684\u51fd\u6570\u6765\u5b9e\u73b0 \u201c\u79fb\u52a8\u8bed\u4e49\u201d \uff1a\u4e00\u4e2a\u662f \u79fb\u52a8\u6784\u9020\u51fd\u6570 \uff0c\u4e00\u4e2a\u662f \u79fb\u52a8\u8d4b\u503c\u64cd\u4f5c\u7b26 \u3002\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u7684\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u7684\u76ee\u6807\u662f\u521b\u5efa\u4e00\u4efd\u5bf9\u8c61\u7684\u62f7\u8d1d\u5230\u53e6\u4e00\u4e2a\u5bf9\u8c61\uff0c\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u8d4b\u503c\u8d4b\u503c\u8fd0\u7b97\u7b26\u662f\u6765\u79fb\u52a8\u8d44\u6e90\u7684 \u6240\u6709\u6743(ownership) \uff0c\u4ece\u4e00\u4e2a\u5bf9\u8c61\u5230\u53e6\u4e00\u4e2a\u5bf9\u8c61\uff08\u8fd9\u6837\u505a\u6d88\u8017\u7684\u8d44\u6e90\u5c11\u5f88\u591a\uff09\u3002 \u5b9a\u4e49\u4e00\u4e2a\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u4e00\u4e2a\u79fb\u52a8\u8d4b\u503c\u51fd\u6570\u548c\u62f7\u8d1d\u7684\u540c\u7c7b\u51fd\u6570\u6240\u5b9e\u73b0\u7684\u76ee\u7684\u76f8\u4f3c\u3002\u7136\u800c\uff0c\u8fd9\u4e9b\u590d\u5236\u51fd\u6570\u7684\u98ce\u683c\u91c7\u7528 \u5e38\u91cf\u5de6\u503c\u5f15\u7528 \u53c2\u6570\uff0c\u79fb\u52a8\u51fd\u6570\u7684\u98ce\u683c\u4f7f\u7528\u4e86 \u975e\u5e38\u91cf\u53f3\u503c\u5f15\u7528 \u53c2\u6570\u3002 \u6709\u4e00\u4e2a\u548c\u4e4b\u524d\u7684 Auto_ptr3 \u76f8\u540c\u7684\u7c7b\uff0c\u6dfb\u52a0\u4e86\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u4e1c\u8d4b\u503c\u64cd\u4f5c\u7b26\u3002\u6211\u4eec\u7559\u4e0b\u4e86\u8fdb\u884c \u6df1\u62f7\u8d1d \u7684\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u64cd\u4f5c\u7b26\u4ec5\u4ec5\u4e3a\u4e86\u4f5c\u6bd4\u8f83\u3002 # include <iostream> template < class T > class Auto_ptr4 { T * m_ptr ; public : Auto_ptr4 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr4 () { delete m_ptr ; } // Copy constructor // Do deep copy of a.m_ptr to m_ptr Auto_ptr4 ( const Auto_ptr4 & a ) { m_ptr = new T ; * m_ptr = * a . m_ptr ; } // Move constructor // Transfer ownership of a.m_ptr to m_ptr Auto_ptr4 ( Auto_ptr4 && a ) : m_ptr ( a . m_ptr ) { a . m_ptr = nullptr ; // we'll talk more about this line below } // Copy assignment // Do deep copy of a.m_ptr to m_ptr Auto_ptr4 & operator = ( const Auto_ptr4 & a ) { // Self-assignment detection if ( & a == this ) return * this ; // Release any resource we're holding delete m_ptr ; // Copy the resource m_ptr = new T ; * m_ptr = * a . m_ptr ; return * this ; } // Move assignment // Transfer ownership of a.m_ptr to m_ptr Auto_ptr4 & operator = ( Auto_ptr4 && a ) { // Self-assignment detection if ( & a == this ) return * this ; // Release any resource we're holding delete m_ptr ; // Transfer ownership of a.m_ptr to m_ptr m_ptr = a . m_ptr ; a . m_ptr = nullptr ; // we'll talk more about this line below return * this ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } bool isNull () const { return m_ptr == nullptr ; } }; class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; Auto_ptr4 < Resource > generateResource () { Auto_ptr4 < Resource > res ( new Resource ); return res ; // this return value will invoke the move constructor } int main () { Auto_ptr4 < Resource > mainres ; mainres = generateResource (); // this assignment will invoke the move assignment return 0 ; } \u79fb\u52a8\u6784\u9020\u51fd\u6570 \u548c \u79fb\u52a8\u8d4b\u503c\u64cd\u4f5c\u7b26 \u975e\u5e38\u7b80\u5355\u3002\u4e0d\u518d\u5bf9\u539f\u5bf9\u8c61\u8fdb\u884c\u6df1\u62f7\u8d1d\u5230\u4e00\u4e2a\u4e0d\u540c\u7684\u5bf9\u8c61\uff0c\u4ec5\u4ec5\u7b80\u5355\u5730\u4ece\u6e90\u5bf9\u8c61 \u79fb\u52a8\uff08\u5077\uff09 \u5230\u76ee\u6807\u5bf9\u8c61\u3002\u5176\u5b9e\u5c31\u662f\u6d89\u53ca\u4e86\u4ece\u539f\u6307\u9488\u5230\u76ee\u5bf9\u8c61\u7684\u6d45\u62f7\u8d1d\uff0c\u7136\u540e\u539f\u6307\u9488\u8bbe\u5b9a\u4e3a null \u3002 \u6211\u4eec\u8fd0\u884c\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u5c06\u6253\u5370\uff1a Resource acquired Resource destroyed \u90a3\u597d\u5f97\u591a\uff1a \u7a0b\u5e8f\u7684\u6d41\u7a0b\u548c\u4ee5\u524d\u76f8\u4f3c\uff0c\u7136\u800c\uff0c\u4e0d\u518d\u8c03\u7528\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\uff0c\u800c\u8fd9\u4e2a\u7a0b\u5e8f\u8c03\u7528\u4e86\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26\u3002\u8ba9\u6211\u4eec\u6df1\u5165\u6765\u770b\uff1a 1; \u5728 generateResource() \u4e2d\uff0c\u5c40\u90e8\u53d8\u91cf res \u88ab\u7528\u52a8\u6001\u5206\u914d\u521b\u5efa\u548c\u521d\u59cb\u5316\u3002 2; Res \u901a\u8fc7\u503c\u8fd4\u56de\u5230 main() \u3002 Res \u88ab\u79fb\u52a8\u6784\u9020\u8fdb\u4e00\u4e2a\u4e34\u65f6\u5bf9\u8c61\uff0c\u8f6c\u4e49\u8fd9\u4e2a\u5728 res \u4e2d\u52a8\u6001\u521b\u5efa\u7684\u5bf9\u8c61\uff0c\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u65b9\u8ba8\u8bba\u4e3a\u4f55\u8fd9\u6837\u505a\u3002 3; Res \u79bb\u5f00\u4f5c\u7528\u4e8e\u3002\u56e0\u4e3a res \u4e0d\u518d\u7ba1\u7406\u6307\u9488\uff08\u5df2\u7ecf\u88ab\u79fb\u52a8\u5230\u4e34\u65f6\u533a\uff09\uff0c\u6ca1\u4ec0\u4e48\u5176\u4ed6\u7684\u53d1\u751f\uff08delete nullptr \u4e0d\u4f1a\u53d1\u751f\u4ec0\u4e48\uff09\u3002 4; \u4e34\u65f6\u5bf9\u8c61\u88ab\u79fb\u52a8\u8d4b\u503c\u7ed9 mainres \u3002\u8fd9\u6b21\u8f6c\u79fb\u4e86\u52a8\u6001\u521b\u5efa\u5e76\u50a8\u5b58\u5728\u4e34\u65f6\u533a\u7684\u5bf9\u8c61\u7ed9 mainres \u3002 5; \u5728\u590d\u5236\u8868\u8fbe\u5f0f\u7ed3\u5c3e\uff0c\u4e34\u65f6\u7684\u5bf9\u8c61\u79bb\u5f00\u4e86\u8868\u8fbe\u5f0f\u4f5c\u7528\u4e8e\uff0c\u5e76\u4e14\u88ab\u9500\u6bc1\u3002\u7136\u800c\u56e0\u4e3a\u4e34\u65f6\u533a\u4e0d\u518d\u7ba1\u7406\u6307\u9488\uff08\u88ab\u79fb\u52a8\u5230\u4e86 mainres \u4e0a\uff09\uff0c\u56e0\u6b64\u8fd9\u4e00\u6b65\u4e5f\u4ec0\u4e48\u90fd\u4e0d\u4f1a\u53d1\u751f\u3002 6; \u5728 main() \u51fd\u6570\u7684\u672b\u5c3e\uff0c mainres \u79bb\u5f00\u4e86\u4f5c\u7528\u4e8e\uff0c\u89e6\u53d1\u4e86\u6700\u540e\u4e00\u4e2a \u201cResource destroyed\u201d \u6253\u5370\u5728\u5c4f\u5e55\u4e0a\u3002 \u56e0\u6b64\uff0c\u4e0d\u518d\u62f7\u8d1d Resource \u4e24\u6b21\uff08\u4e00\u6b21\u4e3a\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u4e00\u6b21\u4e3a\u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26\uff09\uff0c\u6211\u4eec\u79fb\u52a8\u4e86\u5b83\u4e24\u6b21\u3002\u8fd9\u66f4\u9ad8\u6548\uff0c\u56e0\u4e3a Resource \u4ec5\u4ec5\u88ab\u6784\u9020\u548c\u9500\u6bc1\u4e00\u6b21\uff0c\u800c\u4e0d\u662f\u4e09\u6b21\u3002 \u4f55\u65f6\u8c03\u7528\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26 \u00b6 \u5f53\u90a3\u4e9b\u51fd\u6570\u88ab\u8c03\u7528\uff0c\u5e76\u4e14\u6784\u9020\u51fd\u6570\u6216\u8005\u8d4b\u503c\u8fd0\u7b97\u7b26\u7684\u53c2\u6570\u662f\u4e00\u4e2a\u53f3\u503c\u65f6\uff0c\u4f1a\u8c03\u7528\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26\u3002\u6700\u5178\u578b\u7684\u662f\uff0c\u53f3\u503c\u4f1a\u662f\u4e00\u4e2a\u5b57\u9762\u91cf(literal)\u6216\u4e00\u4e2a\u4e34\u65f6\u503c\u3002 \u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c \u79fb\u52a8\u6784\u9020\u51fd\u6570 \u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26\u4e0d\u4f1a\u88ab\u9ed8\u8ba4\u63d0\u4f9b\uff0c\u9664\u975e\u8be5\u7c7b\u6ca1\u6709\u5b9a\u4e49\u4efb\u4f55 \u62f7\u8d1d\u6784\u9020\u51fd\u6570 \uff0c\u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26\uff0c \u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26 \uff0c\u6216\u8005**\u6790\u6784\u51fd\u6570** \u3002\u7136\u800c\uff0c\u9ed8\u8ba4\u7684 \u79fb\u52a8\u6784\u9020\u51fd\u6570 \u548c \u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26 \u53ea\u4f1a\u505a\u548c\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26\u76f8\u4f3c\u7684\u4e8b\u60c5\uff08\u5236\u4f5c\u62f7\u8d1d\uff0c\u4e0d\u79fb\u52a8\uff09\u3002 \u89c4\u5b9a\uff1a\u5982\u679c\u4f60\u60f3\u8981\u4e00\u4e2a\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26\u6765\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\uff0c\u4f60\u9700\u8981\u81ea\u5df1\u5b9e\u73b0\u4e00\u4e2a\u3002 \u79fb\u52a8\u8bed\u4e49\u80cc\u540e\u7684\u5173\u8fdb\u56e0\u7d20 \u00b6 \u4f60\u73b0\u5728\u4e86\u89e3\u4e86\u8db3\u591f\u591a\u7684\u4e0a\u4e0b\u6587\uff0c\u7406\u89e3\u79fb\u52a8\u8bed\u4e49\u80cc\u540e\u7684\u5173\u952e\u56e0\u7d20\u3002 \u5982\u679c\u6211\u4eec\u6784\u9020\u4e00\u4e2a\u5bf9\u8c61\u6216\u8005\u8fdb\u884c\u4e00\u6b21\u8d4b\u503c\u65f6\uff0c\u5f53\u53c2\u6570\u662f\u4e00\u4e2a\u5de6\u503c\uff0c\u6211\u4eec\u552f\u4e00\u80fd\u505a\u7684\u5c31\u662f\u62f7\u8d1d\u8fd9\u4e2a\u5de6\u503c\u3002\u6211\u4eec\u4e0d\u80fd\u5047\u8bbe\u4fee\u6539\u5b83\u662f\u5b89\u5168\u7684\uff0c\u56e0\u4e3a\u5b83\u53ef\u80fd\u5728\u4e4b\u540e\u7684\u7a0b\u5e8f\u4e2d\u88ab\u4f7f\u7528\u3002\u5c31\u597d\u50cf\u5982\u679c\u6709\u4e00\u4e2a\u8868\u8fbe\u5f0f a = b \uff0c \u6211\u4eec\u65e0\u8bba\u5982\u4f55\u4e0d\u4f1a\u671f\u5f85b\u88ab\u6539\u53d8 \u3002 \u7136\u800c\uff0c\u5982\u679c\u6211\u4eec\u6784\u9020\u4e00\u4e2a\u5bf9\u8c61\u6216\u8005\u505a\u4e00\u6b21\u8d4b\u503c\u65f6\uff0c\u53c2\u6570\u662f\u4e00\u4e2a\u53f3\u503c\uff0c\u6211\u4eec\u77e5\u9053\u53f3\u503c\u4ec5\u4ec5\u662f\u4e00\u4e2a\u67d0\u4e2a\u7c7b\u578b\u7684\u4e34\u65f6\u503c\u3002\u76f8\u6bd4\u62f7\u8d1d\u4ed6\uff08\u82b1\u8d39\u66f4\u591a\u8d44\u6e90\uff09\uff0c\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u7684\u79fb\u52a8\u5b83\u7684\u8d44\u6e90\uff08\u82b1\u8d39\u975e\u5e38\u5c11\uff09\u7ed9\u6211\u4eec\u6b63\u5728\u521b\u5efa\u6216\u8005\u8d4b\u503c\u7684\u8d44\u6e90\u3002\u8fd9\u662f\u5b9e\u73b0\u8d77\u6765\u662f\u5b89\u5168\u7684\uff0c\u56e0\u4e3a\u4e34\u65f6\u503c\u5c06\u4f1a\u88ab\u9500\u6bc1\u5728\u8868\u8fbe\u5f0f\u7684\u7ed3\u5c3e\uff0c\u56e0\u6b64\u6211\u4eec\u77e5\u9053\u5b83\u5c06\u6c38\u8fdc\u4e0d\u4f1a\u518d\u88ab\u518d\u6b21\u4f7f\u7528\uff01 C++11\uff0c\u901a\u8fc7\u53f3\u503c\u5f15\u7528\uff0c\u7ed9\u6211\u4eec\u80fd\u529b\u6765\u63d0\u4f9b\u4e00\u4e2a\u4e0d\u540c\u7684\u5b9e\u73b0\uff0c\u5f53\u53c2\u6570\u662f\u4e00\u4e2a\u53f3\u503c\u6216\u4e00\u4e2a\u5de6\u503c\uff0c\u6709\u4e86\u8fd9\u4e2a\u80fd\u529b\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u66f4\u7b80\u5355\uff0c\u66f4\u9ad8\u6548\u7684\u51b3\u5b9a\u6211\u4eec\u7f16\u5199\u7684\u5bf9\u8c61\u7684\u884c\u4e3a\u3002 \u79fb\u52a8\u51fd\u6570\u5e94\u59cb\u7ec8\u4f7f\u4e24\u4e2a\u5bf9\u8c61\u5904\u4e8e\u5b9a\u4e49\u826f\u597d\u7684\u72b6\u6001 \u00b6 \u5728\u4ee5\u4e0a\u7684\u4f8b\u5b50\u4e2d\uff0c\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c\u51fd\u6570\u8bbe\u7f6e a.m_ptr \u4e3a nullptr \u3002\u8fd9\u662f\u770b\u8d77\u6765\u4f3c\u4e4e\u662f\u6ca1\u4ec0\u4e48\u7528\u2014\u2014\u2014\u2014\u6bd5\u7adf\uff0c\u5982\u679c \u201ca\u201d \u662f\u4e00\u4e2a\u4e34\u65f6\u53f3\u503c\uff0c\u4e3a\u4ec0\u4e48\u963b\u6b62\u201c\u6e05\u7406\u201d\uff0c\u5982\u679c \u201ca\u201d \u65e0\u8bba\u5982\u4f55\u90fd\u4f1a\u88ab\u9500\u6bc1\u3002 \u8fd9\u4e2a\u95ee\u9898\u7684\u7b54\u6848\u5f88\u7b80\u5355\uff1a\u5f53 \u201ca\u201d \u79bb\u5f00\u4f5c\u7528\u57df\uff0c \"a\" \u7684\u6790\u6784\u51fd\u6570\u5c06\u4f1a\u88ab\u8c03\u7528\uff0c\u5e76\u4e14 a.m_ptr \u5c06\u4f1a\u88ab\u5220\u9664\u3002\u5982\u679c\u5728\u90a3\u65f6 a.m_ptr \u4ecd\u7136\u6307\u7740\u548c m_ptr \u76f8\u540c\u7684\u7684\u8d44\u6e90\uff0c m_ptr \u5c31\u4f1a\u6210\u4e3a\u4e00\u4e2a\u60ac\u7a7a\u6307\u9488\u3002\u5f53\u5bf9\u8c61\u5bf9\u8c61\u5305\u542b\u7684 m_ptr \u6700\u7ec8\u88ab\u4f7f\u7528\uff08\u6216\u8005\u9500\u6bc1\uff09\uff0c\u5c06\u4f1a\u53d1\u751f\u672a\u5b9a\u4e49\u64cd\u4f5c(undefiend behavior)\u3002 \u53e6\u5916\uff0c\u5728\u4e0b\u8282\u8bfe\u4e2d\u6211\u4eec\u5c06\u4f1a\u770b\u5230\u4e00\u4e9b\u4f8b\u5b50\u5f53 a \u53ef\u4ee5\u662f\u4e00\u4e2a\u5de6\u503c\u65f6\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c a \u5c06\u4e0d\u4f1a\u88ab\u7acb\u5373\u9500\u6bc1\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u5176\u58f0\u660e\u5468\u671f\u7ed3\u675f\u524d\u67e5\u8be2\u3002 \u5de6\u503c\u901a\u8fc7\u79fb\u52a8\u503c\u8fd4\u56de\uff0c\u66ff\u4ee3\u590d\u5236\u8fd4\u56de \u00b6 \u5728 \u4e4b\u524d\u7684\u4f8b\u5b50\u91cc\uff0c Auto_ptr4 \u4e2d\u7684 generateResource() \uff0c\u5f53\u53d8\u91cf res \u88ab\u901a\u8fc7\u503c\u8fd4\u56de\uff0c\u5b83\u88ab\u79fb\u52a8\u800c\u4e0d\u662f\u62f7\u8d1d\uff0c\u5373\u4fbf res \u59cb\u7ec8\u662f\u4e00\u4e2a\u5de6\u503c\u3002C++ \u89c4\u8303\u4e2d\u6709\u4e00\u4e2a\u7279\u4f8b\u8fd9\u6837\u63cf\u8ff0\uff1a\u901a\u8fc7\u503c\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5bf9\u8c61\u5c06\u81ea\u52a8\u4f7f\u7528\u79fb\u52a8\u8bed\u4e49\uff0c\u5373\u4fbf\u4ed6\u4eec\u662f\u4e00\u4e2a\u5de6\u503c\u3002\u8fd9\u5f88\u6709\u610f\u4e49\uff0c\u56e0\u4e3a res \u65e0\u8bba\u5982\u4f55\u5373\u5c06\u88ab\u9500\u6bc1\u5728\u51fd\u6570\u7684\u672b\u5c3e\uff01\u6211\u4eec\u53ef\u4ee5\u4e5f\u5077\u8d70\u5b83\u7684\u8d44\u6e90\u800c\u4e0d\u662f\u505a\u6ca1\u5fc5\u8981\u7684\u62f7\u8d1d\u3002 \u5c3d\u7ba1\u7f16\u8bd1\u5668\u53ef\u4ee5\u79fb\u52a8\u5de6\u503c\u4f5c\u4e3a\u51fd\u6570\u7684\u8fd4\u56de\u503c\uff08Although the compiler can move l-value return values\uff09\uff0c\u5728\u4e00\u4e9b\u4f8b\u5b50\u4e2d\uff0c\u53ef\u4ee5\u505a\u7684\u66f4\u597d\uff0c\u901a\u8fc7\u7b80\u5355\u7684\u6dd8\u6c70\u5b8c\u5168\u62f7\u8d1d\uff08\u907f\u514d\u62f7\u8d1d\u800c\u6216\u5168\u90e8\u4f7f\u7528\u79fb\u52a8\uff09\u3002\u5728\u8fd9\u6837\u7684\u4f8b\u5b50\u4e2d\uff0c\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u6784\u9020\u51fd\u6570\u90fd\u4e0d\u4f1a\u88ab\u8c03\u7528\u3002 \u7981\u7528\u62f7\u8d1d \u00b6 \u5728 \u4e0a\u65b9\u7684 Auto_ptr4 \u7c7b\u4e2d\uff0c\u6211\u4eec\u7559\u4e0b\u4e86 copy \u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u64cd\u4f5c\u7b26\u4e3a\u4e86\u6bd4\u8f83\u7684\u76ee\u7684\u3002\u4f46\u5728\u5f00\u542f\u79fb\u52a8(mode-enabled)\u66f4\u613f\u610f\u5220\u9664\u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u6765\u786e\u4fdd\u62f7\u8d1d\u4e0d\u4f1a\u53d1\u751f\u3002\u5728\u63a5\u4e0b\u6765\u7684\u4f8b\u5b50\u4e2d Auto_ptr \u7c7b\uff0c\u6211\u4eec\u60f3\u8981\u62f7\u8d1d\u6211\u4eec\u7684 templated \u5bf9\u8c61 T \u2014\u2014\u2014\u2014 \u4e0d\u4ec5\u56e0\u4e3a\u5b83\u7684\u5f00\u9500\u5f88\u5927\uff0c\u800c\u4e14 T \u7c7b\u53ef\u80fd\u751a\u81f3\u4e0d\u652f\u6301\u62f7\u8d1d\uff01 \u8fd9\u662f Auto_ptr \u652f\u6301\u79fb\u52a8\u8bed\u4e49\uff0c\u4f46\u662f\u4e0d\u652f\u6301\u62f7\u8d1d\u8bed\u4e49\u7684\u7248\u672c\u3002 # include <iostream> template < class T > class Auto_ptr5 { T * m_ptr ; public : Auto_ptr5 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr5 () { delete m_ptr ; } // Copy constructor -- no copying allowed! Auto_ptr5 ( const Auto_ptr5 & a ) = delete ; // Move constructor // Transfer ownership of a.m_ptr to m_ptr Auto_ptr5 ( Auto_ptr5 && a ) : m_ptr ( a . m_ptr ) { a . m_ptr = nullptr ; } // Copy assignment -- no copying allowed! Auto_ptr5 & operator = ( const Auto_ptr5 & a ) = delete ; // Move assignment // Transfer ownership of a.m_ptr to m_ptr Auto_ptr5 & operator = ( Auto_ptr5 && a ) { // Self-assignment detection if ( & a == this ) return * this ; // Release any resource we're holding delete m_ptr ; // Transfer ownership of a.m_ptr to m_ptr m_ptr = a . m_ptr ; a . m_ptr = nullptr ; return * this ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } bool isNull () const { return m_ptr == nullptr ; } }; \u5982\u679c\u4f60\u5c1d\u8bd5\u901a\u8fc7\u5de6\u503c\u4f20\u4e00\u4e2a Auto_ptr5 \u5230\u4e00\u4e2a\u51fd\u6570\uff0c\u7f16\u8bd1\u5668\u5c06\u4f1a\u62a5\u9519\u544a\u8bc9\u4f60\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u662f\u5fc5\u987b\u7684\uff0c\u7528\u6765\u521d\u59cb\u5316\u62f7\u8d1d\u6784\u9020\u53c2\u6570\u5df2\u7ecf\u88ab\u5220\u9664\u3002\u8fd9\u5c31\u5bf9\u4e86\uff0c\u56e0\u4e3a\u6211\u4eec\u5e94\u8be5\u901a\u8fc7\u5e38\u5de6\u503c\u5f15\u7528\u4f20\u9012 Auto_ptr5 \uff01 Auto_ptr5 \u662f\uff08\u7ec8\u6781\uff09\u4e00\u4e2a\u5f88\u597d\u7684\u53ea\u80fd\u6307\u6b63\u7c7b\u3002\u5e76\u4e14\u4e8b\u5b9e\u4e0a\uff0c\u6807\u51c6\u5e93\u5305\u542b\u7684\u7c7b\u5df2\u7ecf\u975e\u5e38\u50cf\u8fd9\u4e2a\uff08\u4f60\u5e94\u8be5\u7528\u6807\u51c6\uff09\uff0c\u88ab\u53eb\u505a std::unique_ptr \u3002\u6211\u4eec\u5c06\u8ba8\u8bba\u66f4\u591a\u6709\u5173 std::unique_ptr \u5728\u7a0d\u540e\u7684\u7ae0\u8282\u4e2d\u3002 \u53e6\u4e00\u4e2a\u4f8b\u5b50 \u00b6 \u8ba9\u6211\u4eec\u770b\u4e00\u773c\u53e6\u4e00\u4e2a\u7c7b\u4f7f\u7528\u4e86\u52a8\u6001\u5185\u5b58\u5206\u914d\uff1a\u4e00\u4e2a\u7b80\u5355\u7684\u52a8\u6001\u6a21\u677f\u6570\u7ec4\u3002\u8fd9\u4e2a\u7c7b\u5305\u542b\u4e00\u4e2a\u6df1\u62f7\u8d1d\u7684\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u64cd\u4f5c\u7b26\u3002 # include <iostream> template < class T > class DynamicArray { private : T * m_array ; int m_length ; public : DynamicArray ( int length ) : m_array ( new T [ length ]), m_length ( length ) { } ~ DynamicArray () { delete [] m_array ; } // Copy constructor DynamicArray ( const DynamicArray & arr ) : m_length ( arr . m_length ) { m_array = new T [ m_length ]; for ( int i = 0 ; i < m_length ; ++ i ) m_array [ i ] = arr . m_array [ i ]; } // Copy assignment DynamicArray & operator = ( const DynamicArray & arr ) { if ( & arr == this ) return * this ; delete [] m_array ; m_length = arr . m_length ; m_array = new T [ m_length ]; for ( int i = 0 ; i < m_length ; ++ i ) m_array [ i ] = arr . m_array [ i ]; return * this ; } int getLength () const { return m_length ; } T & operator []( int index ) { return m_array [ index ]; } const T & operator []( int index ) const { return m_array [ index ]; } }; \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u5728\u7a0b\u5e8f\u4e2d\u4f7f\u7528\u8fd9\u4e2a\u7c7b\u3002\u4e3a\u4e86\u5411\u4f60\u5c55\u793a\u8fd9\u4e2a\u7c7b\u7684\u6027\u80fd\uff0c\u6211\u4eec\u5728\u5806\u4e0a\u5206\u914d\u4e86\u4e00\u767e\u4e07\u4e2a\u6574\u578b\uff0c\u6211\u4eec\u5c06\u4f7f\u7528\u6211\u4eec\u5728 lesson 8.16 -- Timing your code \u4e2d\u5f00\u53d1\u7684\u8ba1\u65f6\u5668\u7c7b\u3002\u6211\u4eec\u5c06\u4f7f\u7528\u8fd9\u4e2a\u8ba1\u65f6\u5668\u7c7b\u6765\u5c55\u793a\u6211\u4eec\u7684\u4ee3\u7801\u8fd0\u884c\u6709\u591a\u5feb\uff0c\u5411\u4f60\u5c55\u793a\u62f7\u8d1d\u548c\u79fb\u52a8\u4e4b\u95f4\u7684\u6027\u80fd\u5dee\u8ddd\u3002 # include <iostream> # include <chrono> // for std::chrono functions // Uses the above DynamicArray class class Timer { private : // Type aliases to make accessing nested type easier using clock_t = std :: chrono :: high_resolution_clock ; using second_t = std :: chrono :: duration < double , std :: ratio < 1 > > ; std :: chrono :: time_point < clock_t > m_beg ; public : Timer () : m_beg ( clock_t :: now ()) { } void reset () { m_beg = clock_t :: now (); } double elapsed () const { return std :: chrono :: duration_cast < second_t > ( clock_t :: now () - m_beg ). count (); } }; // Return a copy of arr with all of the values doubled DynamicArray < int > cloneArrayAndDouble ( const DynamicArray < int > & arr ) { DynamicArray < int > dbl ( arr . getLength ()); for ( int i = 0 ; i < arr . getLength (); ++ i ) dbl [ i ] = arr [ i ] * 2 ; return dbl ; } int main () { Timer t ; DynamicArray < int > arr ( 1000000 ); for ( int i = 0 ; i < arr . getLength (); i ++ ) arr [ i ] = i ; arr = cloneArrayAndDouble ( arr ); std :: cout << t . elapsed (); } \u5728\u4f5c\u8005\u4e4b\u4e00\u7684\u673a\u5668\u4e0a\uff0c\u5728\u53d1\u5e03\u6a21\u5f0f\u4e0b\uff0c\u8fd9\u6bb5\u7a0b\u5e8f\u5728 0.00825559 \u79d2\u5185\u6267\u884c\u5b8c\u3002 \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u518d\u6b21\u8fd0\u884c\u540c\u6837\u7684\u7a0b\u5e8f\uff0c\u4f7f\u7528\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c\u51fd\u6570\u6765\u66ff\u6362\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u3002 template < class T > class DynamicArray { private : T * m_array ; int m_length ; public : DynamicArray ( int length ) : m_array ( new T [ length ]), m_length ( length ) { } ~ DynamicArray () { delete [] m_array ; } // Copy constructor DynamicArray ( const DynamicArray & arr ) = delete ; // Copy assignment DynamicArray & operator = ( const DynamicArray & arr ) = delete ; // Move constructor DynamicArray ( DynamicArray && arr ) : m_length ( arr . m_length ), m_array ( arr . m_array ) { arr . m_length = 0 ; arr . m_array = nullptr ; } // Move assignment DynamicArray & operator = ( DynamicArray && arr ) { if ( & arr == this ) return * this ; delete [] m_array ; m_length = arr . m_length ; m_array = arr . m_array ; arr . m_length = 0 ; arr . m_array = nullptr ; return * this ; } int getLength () const { return m_length ; } T & operator []( int index ) { return m_array [ index ]; } const T & operator []( int index ) const { return m_array [ index ]; } }; # include <iostream> # include <chrono> // for std::chrono functions class Timer { private : // Type aliases to make accessing nested type easier using clock_t = std :: chrono :: high_resolution_clock ; using second_t = std :: chrono :: duration < double , std :: ratio < 1 > > ; std :: chrono :: time_point < clock_t > m_beg ; public : Timer () : m_beg ( clock_t :: now ()) { } void reset () { m_beg = clock_t :: now (); } double elapsed () const { return std :: chrono :: duration_cast < second_t > ( clock_t :: now () - m_beg ). count (); } }; // Return a copy of arr with all of the values doubled DynamicArray < int > cloneArrayAndDouble ( const DynamicArray < int > & arr ) { DynamicArray < int > dbl ( arr . getLength ()); for ( int i = 0 ; i < arr . getLength (); ++ i ) dbl [ i ] = arr [ i ] * 2 ; return dbl ; } int main () { Timer t ; DynamicArray < int > arr ( 1000000 ); for ( int i = 0 ; i < arr . getLength (); i ++ ) arr [ i ] = i ; arr = cloneArrayAndDouble ( arr ); std :: cout << t . elapsed (); } \u5728\u540c\u6837\u7684\u673a\u5668\u4e0a\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u5728 0.0056 \u79d2\u5185\u6267\u884c\u5b8c\u6bd5\u3002 \u6bd4\u8f83\u4e24\u4e2a\u7a0b\u5e8f\u7684\u8fd0\u884c\u65f6\u95f4\uff0c 0.0056 / 0.00825559 = 67.8% \u3002\u201c\u79fb\u52a8\u8bed\u4e49\u201d\u7684\u7248\u672c\u51e0\u4e4e\u5feb\u4e8633%","title":"15.3 \u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/#153","text":"By Alex on February 26 th , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.17 \u5728\u8bfe\u7a0b 15.1 \u667a\u80fd\u6307\u9488\u548c\u79fb\u52a8\u8bed\u4e49\u7684\u4ecb\u7ecd \u4e2d, \u6211\u4eec\u4e86\u89e3\u5230\u4e86 std::auto ptr \uff0c\u8ba8\u8bba\u4e86\u5bf9\u79fb\u52a8\u8bed\u4e49\u7684\u9700\u6c42\uff0c\u5e76\u7814\u7a76\u4e86\u4e3a\u590d\u5236\u8bed\u4e49\u8bbe\u8ba1\u7684\u51fd\u6570\uff08\u590d\u5236\u6784\u9020\u51fd\u6570\u548c\u590d\u5236\u8d4b\u503c\u8fd0\u7b97\u7b26\uff09\uff0c\u4ee5\u53ca\u88ab\u91cd\u65b0\u5b9a\u4e49\u4e3a\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\u65f6\u51fa\u73b0\u7684\u4e00\u4e9b\u7f3a\u70b9\u3002 \u5728\u8fd9\u5802\u8bfe\u4e2d\uff0c\u6211\u4eec\u5c06\u6df1\u5165\u4e86\u89e3 C++11 \u662f\u5982\u4f55\u901a\u8fc7 \u79fb\u52a8\u6784\u9020\u51fd\u6570 \u548c \u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97 \u6765\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\u3002","title":"15.3 \u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/#_1","text":"\u9996\u5148\uff0c\u8ba9\u6211\u4eec\u590d\u4e60\u4e00\u4e0b\u62f7\u8d1d\u8bed\u4e49( copy semantics )\u3002 \u62f7\u8d1d\u6784\u9020\u51fd\u6570 \u901a\u8fc7\u521b\u5efa\u4e00\u4efd\u8be5\u7c7b\u7684\u62f7\u8d1d\u6765\u521d\u59cb\u5316\u4e00\u4e2a\u7c7b\u3002 \u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26 \u901a\u8fc7\u62f7\u8d1d\u4e00\u4e2a\u5df2\u5b58\u5728\u7c7b\u5bf9\u8c61\uff0c\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5bf9\u8c61\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u4e00\u4e2a\u7c7b\u6ca1\u6709\u663e\u5f0f\u7684\u63d0\u4f9b\uff0cC++ \u5c06\u4f1a\u9ed8\u8ba4\u63d0\u4f9b\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u3002\u8fd9\u4e9b\u7531\u7f16\u8bd1\u5668\u63d0\u4f9b\u7684\u51fd\u6570\u4ec5\u5b9e\u73b0\u4e86\u6d45\u62f7\u8d1d\uff0c\u5728\u8fdb\u884c\u52a8\u6001\u5206\u914d\u5185\u5b58\u7684\u7c7b\u5bf9\u8c61\u4e0a\u4f7f\u7528\u53ef\u80fd\u9020\u6210\u95ee\u9898\u3002\u56e0\u6b64\u5728\u6d89\u53ca\u52a8\u6001\u5185\u5b58\u5206\u914d\u7684\u7c7b\u5fc5\u987b\u901a\u8fc7\u91cd\u5199\u8fd9\u4e9b\u51fd\u6570\u6765\u8fdb\u884c\u6df1\u62f7\u8d1d\u3002 \u56de\u5230\u6211\u4eec\u672c\u7ae0\u7684\u524d\u4e9b\u8bfe\u4e2d\u63d0\u5230\u7684 Auto_ptr \u667a\u80fd\u6307\u9488\u7c7b\u7684\u4f8b\u5b50\uff0c\u8ba9\u6211\u4eec\u770b\u4e00\u773c\u5b9e\u73b0\u6df1\u62f7\u8d1d\u7684\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\uff0c\u8fd8\u6709\u4e00\u4e2a\u7b80\u5355\u7684\u7a0b\u5e8f\u6765\u6d4b\u8bd5\u4ed6\u4eec\uff1a template < class T > class Auto_ptr3 { T * m_ptr ; public : Auto_ptr3 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr3 () { delete m_ptr ; } // Copy constructor \u62f7\u8d1d\u6784\u9020\u51fd\u6570 // Do deep copy of a.m_ptr to m_ptr // \u4ece a.m_ptr \u5230 m_ptr \u8fdb\u884c\u6df1\u62f7\u8d1d Auto_ptr3 ( const Auto_ptr3 & a ) { m_ptr = new T ; * m_ptr = * a . m_ptr ; } // Copy assignment // \u62f7\u8d1d\u8d4b\u503c\u51fd\u6570 // Do deep copy of a.m_ptr to m_ptr // \u4ece a.m_ptr \u5230 m_ptr \u8fdb\u884c\u6df1\u62f7\u8d1d Auto_ptr3 & operator = ( const Auto_ptr3 & a ) { // Self-assignment detection // \u81ea\u8d4b\u503c\u68c0\u6d4b if ( & a == this ) return * this ; // \u91ca\u653e\u6240\u6709\u6301\u6709\u7684\u8d44\u6e90 // Release any resource we're holding delete m_ptr ; // \u62f7\u8d1d\u8d44\u6e90 // Copy the resource m_ptr = new T ; * m_ptr = * a . m_ptr ; return * this ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } bool isNull () const { return m_ptr == nullptr ; } }; class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; Auto_ptr3 < Resource > generateResource () { Auto_ptr3 < Resource > res ( new Resource ); return res ; // this return value will invoke the copy constructor // \u8fd9\u4e2a\u8fd4\u56de\u503c\u5c06\u4f1a\u89e6\u53d1\u62f7\u8d1d\u6784\u9020\u51fd\u6570 } int main () { Auto_ptr3 < Resource > mainres ; mainres = generateResource (); // this assignment will invoke the copy assignment // \u8fd9\u4e2a\u8d4b\u503c\u5c06\u4f1a\u89e6\u53d1\u8d4b\u503c\u8d4b\u503c\u51fd\u6570 return 0 ; } \u5728\u8fd9\u4e2a\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u4e00\u4e2a\u53eb\u505a generateResource() \u7684\u51fd\u6570\u6765\u521b\u5efa\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u5c01\u88c5\u7684 Resource \uff0c\u5e76\u4e14\u5c06\u5b83\u4f20\u56de\u5230 main \u51fd\u6570\u4e2d\u3002 main \u51fd\u6570\u7d27\u63a5\u7740\u5c06\u5176\u8d4b\u503c\u7ed9\u5df2\u7ecf\u5b58\u5728\u7684 Auto_ptr3 \u5bf9\u8c61 mainres \u3002 \u5f53\u8fd9\u4e2a\u7a0b\u5e8f\u8fd0\u884c\u7684\u65f6\u5019\uff0c\u6253\u5370\uff1a Resource acquired Resource acquired Resource destroyed Resource acquired Resource destroyed Resource destroyed \uff08\u6ce8\u610f\uff1a\u4f60\u53ef\u80fd\u53ea\u5f97\u52304\u4e2a\u8f93\u51fa\uff0c\u5982\u679c\u4f60\u7684\u7f16\u8bd1\u5668 \u7701\u7565\\\u4f18\u5316 \u4e86 generateResource() \u7684\u8fd4\u56de\u503c\uff09 \u90a3\u4f1a\u6709\u5f88\u591a\u6b21\u521b\u5efa\u548c\u9500\u6bc1\uff0c\u4ec5\u4ec5\u4e3a\u4e86\u8fd9\u6837\u4e00\u4e2a\u7b80\u5355\u7684\u7a0b\u5e8f\uff01\u53d1\u751f\u4e86\u4ec0\u4e48\uff1f \u8ba9\u6211\u4eec\u4ed4\u7ec6\u770b\u770b\uff0c\u7a0b\u5e8f\u91cc\u6709 6 \u4e2a\u5173\u952e\u6b65\u9aa4\uff08\u6bcf\u6b21\u6253\u5370\u90fd\u53d1\u751f\u4e00\u4ef6\uff09\uff1a 1; \u5728 generateResource() \u4e2d\uff0c\u5c40\u90e8\u53d8\u91cf res \u88ab\u521b\u5efa\u5e76\u7528\u521d\u59cb\u5316\u4e3a\u4e00\u4e2a\u52a8\u6001\u5206\u914d\u7684 Resource \u3002 2; Res \u503c\u8fd4\u56de\u5230 main() \u3002\u901a\u8fc7\u503c\u8fd4\u56de\u7684\u539f\u56e0\u662f\uff0c res \u662f\u4e00\u4e2a\u5c40\u90e8\u53d8\u91cf \u2014\u2014 \u5b83\u4e0d\u80fd\u88ab\u901a\u8fc7\u5730\u5740\u6216\u5f15\u7528\u8fd4\u56de\uff0c\u56e0\u4e3a res \u5c06\u4f1a\u5728 generateResource() \u51fd\u6570\u7ed3\u675f\u524d\u88ab\u9500\u6bc1 \u7ed3\u675f\u3002\u56e0\u4e3a res \u662f\u62f7\u8d1d\u6784\u9020\uff0c\u505a\u4e86\u4e00\u6b21\u6df1\u62f7\u8d1d\uff0c\u4e00\u4e2a\u65b0\u7684 Resource \u5728\u8fd9\u88ab\u5206\u914d\uff0c\u89e6\u53d1\u4e86\u7b2c\u4e8c\u6b21 \"Resource acquired\"\u3002 3; Res \u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u9500\u6bc1\u4e4b\u524d\u521b\u5efa\u7684 Resource \uff0c\u8fd9\u89e6\u53d1\u4e86\u7b2c\u4e00\u4e2a \"Resource destroyed\"\u3002 4; \u4e34\u65f6\u5bf9\u8c61\u88ab\u8d4b\u503c\u8fdb mainres \u901a\u8fc7\u62f7\u8d1d\u8d4b\u503c\u3002\u56e0\u4e3a\u6211\u4eec\u7684\u62f7\u8d1d\u8d4b\u503c\u4e5f\u505a\u4e86\u4e00\u6b21\u6df1\u62f7\u8d1d\uff0c\u4e00\u4e2a\u65b0\u7684 Reource \u88ab\u5206\u914d\uff0c\u89e6\u53d1\u4e86\u53e6\u4e00\u4e2a \"Resource acquired\"\u3002 5; \u8d4b\u503c\u8868\u8fbe\u5f0f\u7ed3\u5c3e\uff0c\u4e34\u65f6\u5bf9\u8c61\u79bb\u5f00\u4e86\u8868\u8fbe\u5f0f\u4f5c\u7528\u57df\u5e76\u4e14\u88ab\u9500\u6bc1\uff0c\u89e6\u53d1\u4e86\u4e00\u4e2a \"Resource acquired\"\u3002 6; \u5728 main() \u7684\u672b\u5c3e\uff0c mainres \u79bb\u5f00\u4e86\u4f5c\u7528\u57df\uff0c\u5e76\u4e14\u89e6\u53d1\u4e86\u6700\u540e\u4e00\u4e2a \"Resource destroyed\"\u3002 \u56e0\u6b64\uff0c\u7b80\u800c\u8a00\u4e4b\uff0c\u56e0\u4e3a\u6211\u4eec\u8c03\u7528\u4e86\u4e00\u6b21\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u6765\u62f7\u8d1d\u6784\u9020 res \u6210\u4e00\u4e2a\u4e34\u65f6\u53d8\u91cf\uff0c\u5e76\u8c03\u7528\u4e86\u4e00\u6b21\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u6765\u62f7\u8d1d\u4e34\u65f6\u53d8\u91cf\u8fdb\u5165 mainres \uff0c\u6211\u4eec\u6700\u7ec8\u5206\u914d\u548c\u9500\u6bc1\u4e863\u4e2a\u72ec\u7acb\u7684 objects \u603b\u8ba1\u3002 \u8fd9\u662f\u4f4e\u6548\u7684\uff0c\u4f46\u662f\u5b83\u81f3\u5c11\u4e0d\u4f1a\u5d29\u6e83\u3002 \u7136\u800c\u5982\u679c\u7528\u79fb\u52a8\u8bed\u4e49\uff0c\u6211\u4eec\u53ef\u4ee5\u505a\u7684\u66f4\u597d\u3002","title":"\u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/#_2","text":"C++ \u5b9a\u4e49\u4e86\u4e24\u4e2a\u65b0\u7684\u51fd\u6570\u6765\u5b9e\u73b0 \u201c\u79fb\u52a8\u8bed\u4e49\u201d \uff1a\u4e00\u4e2a\u662f \u79fb\u52a8\u6784\u9020\u51fd\u6570 \uff0c\u4e00\u4e2a\u662f \u79fb\u52a8\u8d4b\u503c\u64cd\u4f5c\u7b26 \u3002\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u7684\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u7684\u76ee\u6807\u662f\u521b\u5efa\u4e00\u4efd\u5bf9\u8c61\u7684\u62f7\u8d1d\u5230\u53e6\u4e00\u4e2a\u5bf9\u8c61\uff0c\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u8d4b\u503c\u8d4b\u503c\u8fd0\u7b97\u7b26\u662f\u6765\u79fb\u52a8\u8d44\u6e90\u7684 \u6240\u6709\u6743(ownership) \uff0c\u4ece\u4e00\u4e2a\u5bf9\u8c61\u5230\u53e6\u4e00\u4e2a\u5bf9\u8c61\uff08\u8fd9\u6837\u505a\u6d88\u8017\u7684\u8d44\u6e90\u5c11\u5f88\u591a\uff09\u3002 \u5b9a\u4e49\u4e00\u4e2a\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u4e00\u4e2a\u79fb\u52a8\u8d4b\u503c\u51fd\u6570\u548c\u62f7\u8d1d\u7684\u540c\u7c7b\u51fd\u6570\u6240\u5b9e\u73b0\u7684\u76ee\u7684\u76f8\u4f3c\u3002\u7136\u800c\uff0c\u8fd9\u4e9b\u590d\u5236\u51fd\u6570\u7684\u98ce\u683c\u91c7\u7528 \u5e38\u91cf\u5de6\u503c\u5f15\u7528 \u53c2\u6570\uff0c\u79fb\u52a8\u51fd\u6570\u7684\u98ce\u683c\u4f7f\u7528\u4e86 \u975e\u5e38\u91cf\u53f3\u503c\u5f15\u7528 \u53c2\u6570\u3002 \u6709\u4e00\u4e2a\u548c\u4e4b\u524d\u7684 Auto_ptr3 \u76f8\u540c\u7684\u7c7b\uff0c\u6dfb\u52a0\u4e86\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u4e1c\u8d4b\u503c\u64cd\u4f5c\u7b26\u3002\u6211\u4eec\u7559\u4e0b\u4e86\u8fdb\u884c \u6df1\u62f7\u8d1d \u7684\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u64cd\u4f5c\u7b26\u4ec5\u4ec5\u4e3a\u4e86\u4f5c\u6bd4\u8f83\u3002 # include <iostream> template < class T > class Auto_ptr4 { T * m_ptr ; public : Auto_ptr4 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr4 () { delete m_ptr ; } // Copy constructor // Do deep copy of a.m_ptr to m_ptr Auto_ptr4 ( const Auto_ptr4 & a ) { m_ptr = new T ; * m_ptr = * a . m_ptr ; } // Move constructor // Transfer ownership of a.m_ptr to m_ptr Auto_ptr4 ( Auto_ptr4 && a ) : m_ptr ( a . m_ptr ) { a . m_ptr = nullptr ; // we'll talk more about this line below } // Copy assignment // Do deep copy of a.m_ptr to m_ptr Auto_ptr4 & operator = ( const Auto_ptr4 & a ) { // Self-assignment detection if ( & a == this ) return * this ; // Release any resource we're holding delete m_ptr ; // Copy the resource m_ptr = new T ; * m_ptr = * a . m_ptr ; return * this ; } // Move assignment // Transfer ownership of a.m_ptr to m_ptr Auto_ptr4 & operator = ( Auto_ptr4 && a ) { // Self-assignment detection if ( & a == this ) return * this ; // Release any resource we're holding delete m_ptr ; // Transfer ownership of a.m_ptr to m_ptr m_ptr = a . m_ptr ; a . m_ptr = nullptr ; // we'll talk more about this line below return * this ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } bool isNull () const { return m_ptr == nullptr ; } }; class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; Auto_ptr4 < Resource > generateResource () { Auto_ptr4 < Resource > res ( new Resource ); return res ; // this return value will invoke the move constructor } int main () { Auto_ptr4 < Resource > mainres ; mainres = generateResource (); // this assignment will invoke the move assignment return 0 ; } \u79fb\u52a8\u6784\u9020\u51fd\u6570 \u548c \u79fb\u52a8\u8d4b\u503c\u64cd\u4f5c\u7b26 \u975e\u5e38\u7b80\u5355\u3002\u4e0d\u518d\u5bf9\u539f\u5bf9\u8c61\u8fdb\u884c\u6df1\u62f7\u8d1d\u5230\u4e00\u4e2a\u4e0d\u540c\u7684\u5bf9\u8c61\uff0c\u4ec5\u4ec5\u7b80\u5355\u5730\u4ece\u6e90\u5bf9\u8c61 \u79fb\u52a8\uff08\u5077\uff09 \u5230\u76ee\u6807\u5bf9\u8c61\u3002\u5176\u5b9e\u5c31\u662f\u6d89\u53ca\u4e86\u4ece\u539f\u6307\u9488\u5230\u76ee\u5bf9\u8c61\u7684\u6d45\u62f7\u8d1d\uff0c\u7136\u540e\u539f\u6307\u9488\u8bbe\u5b9a\u4e3a null \u3002 \u6211\u4eec\u8fd0\u884c\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u5c06\u6253\u5370\uff1a Resource acquired Resource destroyed \u90a3\u597d\u5f97\u591a\uff1a \u7a0b\u5e8f\u7684\u6d41\u7a0b\u548c\u4ee5\u524d\u76f8\u4f3c\uff0c\u7136\u800c\uff0c\u4e0d\u518d\u8c03\u7528\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\uff0c\u800c\u8fd9\u4e2a\u7a0b\u5e8f\u8c03\u7528\u4e86\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26\u3002\u8ba9\u6211\u4eec\u6df1\u5165\u6765\u770b\uff1a 1; \u5728 generateResource() \u4e2d\uff0c\u5c40\u90e8\u53d8\u91cf res \u88ab\u7528\u52a8\u6001\u5206\u914d\u521b\u5efa\u548c\u521d\u59cb\u5316\u3002 2; Res \u901a\u8fc7\u503c\u8fd4\u56de\u5230 main() \u3002 Res \u88ab\u79fb\u52a8\u6784\u9020\u8fdb\u4e00\u4e2a\u4e34\u65f6\u5bf9\u8c61\uff0c\u8f6c\u4e49\u8fd9\u4e2a\u5728 res \u4e2d\u52a8\u6001\u521b\u5efa\u7684\u5bf9\u8c61\uff0c\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u65b9\u8ba8\u8bba\u4e3a\u4f55\u8fd9\u6837\u505a\u3002 3; Res \u79bb\u5f00\u4f5c\u7528\u4e8e\u3002\u56e0\u4e3a res \u4e0d\u518d\u7ba1\u7406\u6307\u9488\uff08\u5df2\u7ecf\u88ab\u79fb\u52a8\u5230\u4e34\u65f6\u533a\uff09\uff0c\u6ca1\u4ec0\u4e48\u5176\u4ed6\u7684\u53d1\u751f\uff08delete nullptr \u4e0d\u4f1a\u53d1\u751f\u4ec0\u4e48\uff09\u3002 4; \u4e34\u65f6\u5bf9\u8c61\u88ab\u79fb\u52a8\u8d4b\u503c\u7ed9 mainres \u3002\u8fd9\u6b21\u8f6c\u79fb\u4e86\u52a8\u6001\u521b\u5efa\u5e76\u50a8\u5b58\u5728\u4e34\u65f6\u533a\u7684\u5bf9\u8c61\u7ed9 mainres \u3002 5; \u5728\u590d\u5236\u8868\u8fbe\u5f0f\u7ed3\u5c3e\uff0c\u4e34\u65f6\u7684\u5bf9\u8c61\u79bb\u5f00\u4e86\u8868\u8fbe\u5f0f\u4f5c\u7528\u4e8e\uff0c\u5e76\u4e14\u88ab\u9500\u6bc1\u3002\u7136\u800c\u56e0\u4e3a\u4e34\u65f6\u533a\u4e0d\u518d\u7ba1\u7406\u6307\u9488\uff08\u88ab\u79fb\u52a8\u5230\u4e86 mainres \u4e0a\uff09\uff0c\u56e0\u6b64\u8fd9\u4e00\u6b65\u4e5f\u4ec0\u4e48\u90fd\u4e0d\u4f1a\u53d1\u751f\u3002 6; \u5728 main() \u51fd\u6570\u7684\u672b\u5c3e\uff0c mainres \u79bb\u5f00\u4e86\u4f5c\u7528\u4e8e\uff0c\u89e6\u53d1\u4e86\u6700\u540e\u4e00\u4e2a \u201cResource destroyed\u201d \u6253\u5370\u5728\u5c4f\u5e55\u4e0a\u3002 \u56e0\u6b64\uff0c\u4e0d\u518d\u62f7\u8d1d Resource \u4e24\u6b21\uff08\u4e00\u6b21\u4e3a\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u4e00\u6b21\u4e3a\u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26\uff09\uff0c\u6211\u4eec\u79fb\u52a8\u4e86\u5b83\u4e24\u6b21\u3002\u8fd9\u66f4\u9ad8\u6548\uff0c\u56e0\u4e3a Resource \u4ec5\u4ec5\u88ab\u6784\u9020\u548c\u9500\u6bc1\u4e00\u6b21\uff0c\u800c\u4e0d\u662f\u4e09\u6b21\u3002","title":"\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/#_3","text":"\u5f53\u90a3\u4e9b\u51fd\u6570\u88ab\u8c03\u7528\uff0c\u5e76\u4e14\u6784\u9020\u51fd\u6570\u6216\u8005\u8d4b\u503c\u8fd0\u7b97\u7b26\u7684\u53c2\u6570\u662f\u4e00\u4e2a\u53f3\u503c\u65f6\uff0c\u4f1a\u8c03\u7528\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26\u3002\u6700\u5178\u578b\u7684\u662f\uff0c\u53f3\u503c\u4f1a\u662f\u4e00\u4e2a\u5b57\u9762\u91cf(literal)\u6216\u4e00\u4e2a\u4e34\u65f6\u503c\u3002 \u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c \u79fb\u52a8\u6784\u9020\u51fd\u6570 \u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26\u4e0d\u4f1a\u88ab\u9ed8\u8ba4\u63d0\u4f9b\uff0c\u9664\u975e\u8be5\u7c7b\u6ca1\u6709\u5b9a\u4e49\u4efb\u4f55 \u62f7\u8d1d\u6784\u9020\u51fd\u6570 \uff0c\u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26\uff0c \u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26 \uff0c\u6216\u8005**\u6790\u6784\u51fd\u6570** \u3002\u7136\u800c\uff0c\u9ed8\u8ba4\u7684 \u79fb\u52a8\u6784\u9020\u51fd\u6570 \u548c \u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26 \u53ea\u4f1a\u505a\u548c\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26\u76f8\u4f3c\u7684\u4e8b\u60c5\uff08\u5236\u4f5c\u62f7\u8d1d\uff0c\u4e0d\u79fb\u52a8\uff09\u3002 \u89c4\u5b9a\uff1a\u5982\u679c\u4f60\u60f3\u8981\u4e00\u4e2a\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26\u6765\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\uff0c\u4f60\u9700\u8981\u81ea\u5df1\u5b9e\u73b0\u4e00\u4e2a\u3002","title":"\u4f55\u65f6\u8c03\u7528\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/#_4","text":"\u4f60\u73b0\u5728\u4e86\u89e3\u4e86\u8db3\u591f\u591a\u7684\u4e0a\u4e0b\u6587\uff0c\u7406\u89e3\u79fb\u52a8\u8bed\u4e49\u80cc\u540e\u7684\u5173\u952e\u56e0\u7d20\u3002 \u5982\u679c\u6211\u4eec\u6784\u9020\u4e00\u4e2a\u5bf9\u8c61\u6216\u8005\u8fdb\u884c\u4e00\u6b21\u8d4b\u503c\u65f6\uff0c\u5f53\u53c2\u6570\u662f\u4e00\u4e2a\u5de6\u503c\uff0c\u6211\u4eec\u552f\u4e00\u80fd\u505a\u7684\u5c31\u662f\u62f7\u8d1d\u8fd9\u4e2a\u5de6\u503c\u3002\u6211\u4eec\u4e0d\u80fd\u5047\u8bbe\u4fee\u6539\u5b83\u662f\u5b89\u5168\u7684\uff0c\u56e0\u4e3a\u5b83\u53ef\u80fd\u5728\u4e4b\u540e\u7684\u7a0b\u5e8f\u4e2d\u88ab\u4f7f\u7528\u3002\u5c31\u597d\u50cf\u5982\u679c\u6709\u4e00\u4e2a\u8868\u8fbe\u5f0f a = b \uff0c \u6211\u4eec\u65e0\u8bba\u5982\u4f55\u4e0d\u4f1a\u671f\u5f85b\u88ab\u6539\u53d8 \u3002 \u7136\u800c\uff0c\u5982\u679c\u6211\u4eec\u6784\u9020\u4e00\u4e2a\u5bf9\u8c61\u6216\u8005\u505a\u4e00\u6b21\u8d4b\u503c\u65f6\uff0c\u53c2\u6570\u662f\u4e00\u4e2a\u53f3\u503c\uff0c\u6211\u4eec\u77e5\u9053\u53f3\u503c\u4ec5\u4ec5\u662f\u4e00\u4e2a\u67d0\u4e2a\u7c7b\u578b\u7684\u4e34\u65f6\u503c\u3002\u76f8\u6bd4\u62f7\u8d1d\u4ed6\uff08\u82b1\u8d39\u66f4\u591a\u8d44\u6e90\uff09\uff0c\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u7684\u79fb\u52a8\u5b83\u7684\u8d44\u6e90\uff08\u82b1\u8d39\u975e\u5e38\u5c11\uff09\u7ed9\u6211\u4eec\u6b63\u5728\u521b\u5efa\u6216\u8005\u8d4b\u503c\u7684\u8d44\u6e90\u3002\u8fd9\u662f\u5b9e\u73b0\u8d77\u6765\u662f\u5b89\u5168\u7684\uff0c\u56e0\u4e3a\u4e34\u65f6\u503c\u5c06\u4f1a\u88ab\u9500\u6bc1\u5728\u8868\u8fbe\u5f0f\u7684\u7ed3\u5c3e\uff0c\u56e0\u6b64\u6211\u4eec\u77e5\u9053\u5b83\u5c06\u6c38\u8fdc\u4e0d\u4f1a\u518d\u88ab\u518d\u6b21\u4f7f\u7528\uff01 C++11\uff0c\u901a\u8fc7\u53f3\u503c\u5f15\u7528\uff0c\u7ed9\u6211\u4eec\u80fd\u529b\u6765\u63d0\u4f9b\u4e00\u4e2a\u4e0d\u540c\u7684\u5b9e\u73b0\uff0c\u5f53\u53c2\u6570\u662f\u4e00\u4e2a\u53f3\u503c\u6216\u4e00\u4e2a\u5de6\u503c\uff0c\u6709\u4e86\u8fd9\u4e2a\u80fd\u529b\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u66f4\u7b80\u5355\uff0c\u66f4\u9ad8\u6548\u7684\u51b3\u5b9a\u6211\u4eec\u7f16\u5199\u7684\u5bf9\u8c61\u7684\u884c\u4e3a\u3002","title":"\u79fb\u52a8\u8bed\u4e49\u80cc\u540e\u7684\u5173\u8fdb\u56e0\u7d20"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/#_5","text":"\u5728\u4ee5\u4e0a\u7684\u4f8b\u5b50\u4e2d\uff0c\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c\u51fd\u6570\u8bbe\u7f6e a.m_ptr \u4e3a nullptr \u3002\u8fd9\u662f\u770b\u8d77\u6765\u4f3c\u4e4e\u662f\u6ca1\u4ec0\u4e48\u7528\u2014\u2014\u2014\u2014\u6bd5\u7adf\uff0c\u5982\u679c \u201ca\u201d \u662f\u4e00\u4e2a\u4e34\u65f6\u53f3\u503c\uff0c\u4e3a\u4ec0\u4e48\u963b\u6b62\u201c\u6e05\u7406\u201d\uff0c\u5982\u679c \u201ca\u201d \u65e0\u8bba\u5982\u4f55\u90fd\u4f1a\u88ab\u9500\u6bc1\u3002 \u8fd9\u4e2a\u95ee\u9898\u7684\u7b54\u6848\u5f88\u7b80\u5355\uff1a\u5f53 \u201ca\u201d \u79bb\u5f00\u4f5c\u7528\u57df\uff0c \"a\" \u7684\u6790\u6784\u51fd\u6570\u5c06\u4f1a\u88ab\u8c03\u7528\uff0c\u5e76\u4e14 a.m_ptr \u5c06\u4f1a\u88ab\u5220\u9664\u3002\u5982\u679c\u5728\u90a3\u65f6 a.m_ptr \u4ecd\u7136\u6307\u7740\u548c m_ptr \u76f8\u540c\u7684\u7684\u8d44\u6e90\uff0c m_ptr \u5c31\u4f1a\u6210\u4e3a\u4e00\u4e2a\u60ac\u7a7a\u6307\u9488\u3002\u5f53\u5bf9\u8c61\u5bf9\u8c61\u5305\u542b\u7684 m_ptr \u6700\u7ec8\u88ab\u4f7f\u7528\uff08\u6216\u8005\u9500\u6bc1\uff09\uff0c\u5c06\u4f1a\u53d1\u751f\u672a\u5b9a\u4e49\u64cd\u4f5c(undefiend behavior)\u3002 \u53e6\u5916\uff0c\u5728\u4e0b\u8282\u8bfe\u4e2d\u6211\u4eec\u5c06\u4f1a\u770b\u5230\u4e00\u4e9b\u4f8b\u5b50\u5f53 a \u53ef\u4ee5\u662f\u4e00\u4e2a\u5de6\u503c\u65f6\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c a \u5c06\u4e0d\u4f1a\u88ab\u7acb\u5373\u9500\u6bc1\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u5176\u58f0\u660e\u5468\u671f\u7ed3\u675f\u524d\u67e5\u8be2\u3002","title":"\u79fb\u52a8\u51fd\u6570\u5e94\u59cb\u7ec8\u4f7f\u4e24\u4e2a\u5bf9\u8c61\u5904\u4e8e\u5b9a\u4e49\u826f\u597d\u7684\u72b6\u6001"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/#_6","text":"\u5728 \u4e4b\u524d\u7684\u4f8b\u5b50\u91cc\uff0c Auto_ptr4 \u4e2d\u7684 generateResource() \uff0c\u5f53\u53d8\u91cf res \u88ab\u901a\u8fc7\u503c\u8fd4\u56de\uff0c\u5b83\u88ab\u79fb\u52a8\u800c\u4e0d\u662f\u62f7\u8d1d\uff0c\u5373\u4fbf res \u59cb\u7ec8\u662f\u4e00\u4e2a\u5de6\u503c\u3002C++ \u89c4\u8303\u4e2d\u6709\u4e00\u4e2a\u7279\u4f8b\u8fd9\u6837\u63cf\u8ff0\uff1a\u901a\u8fc7\u503c\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5bf9\u8c61\u5c06\u81ea\u52a8\u4f7f\u7528\u79fb\u52a8\u8bed\u4e49\uff0c\u5373\u4fbf\u4ed6\u4eec\u662f\u4e00\u4e2a\u5de6\u503c\u3002\u8fd9\u5f88\u6709\u610f\u4e49\uff0c\u56e0\u4e3a res \u65e0\u8bba\u5982\u4f55\u5373\u5c06\u88ab\u9500\u6bc1\u5728\u51fd\u6570\u7684\u672b\u5c3e\uff01\u6211\u4eec\u53ef\u4ee5\u4e5f\u5077\u8d70\u5b83\u7684\u8d44\u6e90\u800c\u4e0d\u662f\u505a\u6ca1\u5fc5\u8981\u7684\u62f7\u8d1d\u3002 \u5c3d\u7ba1\u7f16\u8bd1\u5668\u53ef\u4ee5\u79fb\u52a8\u5de6\u503c\u4f5c\u4e3a\u51fd\u6570\u7684\u8fd4\u56de\u503c\uff08Although the compiler can move l-value return values\uff09\uff0c\u5728\u4e00\u4e9b\u4f8b\u5b50\u4e2d\uff0c\u53ef\u4ee5\u505a\u7684\u66f4\u597d\uff0c\u901a\u8fc7\u7b80\u5355\u7684\u6dd8\u6c70\u5b8c\u5168\u62f7\u8d1d\uff08\u907f\u514d\u62f7\u8d1d\u800c\u6216\u5168\u90e8\u4f7f\u7528\u79fb\u52a8\uff09\u3002\u5728\u8fd9\u6837\u7684\u4f8b\u5b50\u4e2d\uff0c\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u6784\u9020\u51fd\u6570\u90fd\u4e0d\u4f1a\u88ab\u8c03\u7528\u3002","title":"\u5de6\u503c\u901a\u8fc7\u79fb\u52a8\u503c\u8fd4\u56de\uff0c\u66ff\u4ee3\u590d\u5236\u8fd4\u56de"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/#_7","text":"\u5728 \u4e0a\u65b9\u7684 Auto_ptr4 \u7c7b\u4e2d\uff0c\u6211\u4eec\u7559\u4e0b\u4e86 copy \u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u64cd\u4f5c\u7b26\u4e3a\u4e86\u6bd4\u8f83\u7684\u76ee\u7684\u3002\u4f46\u5728\u5f00\u542f\u79fb\u52a8(mode-enabled)\u66f4\u613f\u610f\u5220\u9664\u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u6765\u786e\u4fdd\u62f7\u8d1d\u4e0d\u4f1a\u53d1\u751f\u3002\u5728\u63a5\u4e0b\u6765\u7684\u4f8b\u5b50\u4e2d Auto_ptr \u7c7b\uff0c\u6211\u4eec\u60f3\u8981\u62f7\u8d1d\u6211\u4eec\u7684 templated \u5bf9\u8c61 T \u2014\u2014\u2014\u2014 \u4e0d\u4ec5\u56e0\u4e3a\u5b83\u7684\u5f00\u9500\u5f88\u5927\uff0c\u800c\u4e14 T \u7c7b\u53ef\u80fd\u751a\u81f3\u4e0d\u652f\u6301\u62f7\u8d1d\uff01 \u8fd9\u662f Auto_ptr \u652f\u6301\u79fb\u52a8\u8bed\u4e49\uff0c\u4f46\u662f\u4e0d\u652f\u6301\u62f7\u8d1d\u8bed\u4e49\u7684\u7248\u672c\u3002 # include <iostream> template < class T > class Auto_ptr5 { T * m_ptr ; public : Auto_ptr5 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr5 () { delete m_ptr ; } // Copy constructor -- no copying allowed! Auto_ptr5 ( const Auto_ptr5 & a ) = delete ; // Move constructor // Transfer ownership of a.m_ptr to m_ptr Auto_ptr5 ( Auto_ptr5 && a ) : m_ptr ( a . m_ptr ) { a . m_ptr = nullptr ; } // Copy assignment -- no copying allowed! Auto_ptr5 & operator = ( const Auto_ptr5 & a ) = delete ; // Move assignment // Transfer ownership of a.m_ptr to m_ptr Auto_ptr5 & operator = ( Auto_ptr5 && a ) { // Self-assignment detection if ( & a == this ) return * this ; // Release any resource we're holding delete m_ptr ; // Transfer ownership of a.m_ptr to m_ptr m_ptr = a . m_ptr ; a . m_ptr = nullptr ; return * this ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } bool isNull () const { return m_ptr == nullptr ; } }; \u5982\u679c\u4f60\u5c1d\u8bd5\u901a\u8fc7\u5de6\u503c\u4f20\u4e00\u4e2a Auto_ptr5 \u5230\u4e00\u4e2a\u51fd\u6570\uff0c\u7f16\u8bd1\u5668\u5c06\u4f1a\u62a5\u9519\u544a\u8bc9\u4f60\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u662f\u5fc5\u987b\u7684\uff0c\u7528\u6765\u521d\u59cb\u5316\u62f7\u8d1d\u6784\u9020\u53c2\u6570\u5df2\u7ecf\u88ab\u5220\u9664\u3002\u8fd9\u5c31\u5bf9\u4e86\uff0c\u56e0\u4e3a\u6211\u4eec\u5e94\u8be5\u901a\u8fc7\u5e38\u5de6\u503c\u5f15\u7528\u4f20\u9012 Auto_ptr5 \uff01 Auto_ptr5 \u662f\uff08\u7ec8\u6781\uff09\u4e00\u4e2a\u5f88\u597d\u7684\u53ea\u80fd\u6307\u6b63\u7c7b\u3002\u5e76\u4e14\u4e8b\u5b9e\u4e0a\uff0c\u6807\u51c6\u5e93\u5305\u542b\u7684\u7c7b\u5df2\u7ecf\u975e\u5e38\u50cf\u8fd9\u4e2a\uff08\u4f60\u5e94\u8be5\u7528\u6807\u51c6\uff09\uff0c\u88ab\u53eb\u505a std::unique_ptr \u3002\u6211\u4eec\u5c06\u8ba8\u8bba\u66f4\u591a\u6709\u5173 std::unique_ptr \u5728\u7a0d\u540e\u7684\u7ae0\u8282\u4e2d\u3002","title":"\u7981\u7528\u62f7\u8d1d"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/#_8","text":"\u8ba9\u6211\u4eec\u770b\u4e00\u773c\u53e6\u4e00\u4e2a\u7c7b\u4f7f\u7528\u4e86\u52a8\u6001\u5185\u5b58\u5206\u914d\uff1a\u4e00\u4e2a\u7b80\u5355\u7684\u52a8\u6001\u6a21\u677f\u6570\u7ec4\u3002\u8fd9\u4e2a\u7c7b\u5305\u542b\u4e00\u4e2a\u6df1\u62f7\u8d1d\u7684\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u64cd\u4f5c\u7b26\u3002 # include <iostream> template < class T > class DynamicArray { private : T * m_array ; int m_length ; public : DynamicArray ( int length ) : m_array ( new T [ length ]), m_length ( length ) { } ~ DynamicArray () { delete [] m_array ; } // Copy constructor DynamicArray ( const DynamicArray & arr ) : m_length ( arr . m_length ) { m_array = new T [ m_length ]; for ( int i = 0 ; i < m_length ; ++ i ) m_array [ i ] = arr . m_array [ i ]; } // Copy assignment DynamicArray & operator = ( const DynamicArray & arr ) { if ( & arr == this ) return * this ; delete [] m_array ; m_length = arr . m_length ; m_array = new T [ m_length ]; for ( int i = 0 ; i < m_length ; ++ i ) m_array [ i ] = arr . m_array [ i ]; return * this ; } int getLength () const { return m_length ; } T & operator []( int index ) { return m_array [ index ]; } const T & operator []( int index ) const { return m_array [ index ]; } }; \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u5728\u7a0b\u5e8f\u4e2d\u4f7f\u7528\u8fd9\u4e2a\u7c7b\u3002\u4e3a\u4e86\u5411\u4f60\u5c55\u793a\u8fd9\u4e2a\u7c7b\u7684\u6027\u80fd\uff0c\u6211\u4eec\u5728\u5806\u4e0a\u5206\u914d\u4e86\u4e00\u767e\u4e07\u4e2a\u6574\u578b\uff0c\u6211\u4eec\u5c06\u4f7f\u7528\u6211\u4eec\u5728 lesson 8.16 -- Timing your code \u4e2d\u5f00\u53d1\u7684\u8ba1\u65f6\u5668\u7c7b\u3002\u6211\u4eec\u5c06\u4f7f\u7528\u8fd9\u4e2a\u8ba1\u65f6\u5668\u7c7b\u6765\u5c55\u793a\u6211\u4eec\u7684\u4ee3\u7801\u8fd0\u884c\u6709\u591a\u5feb\uff0c\u5411\u4f60\u5c55\u793a\u62f7\u8d1d\u548c\u79fb\u52a8\u4e4b\u95f4\u7684\u6027\u80fd\u5dee\u8ddd\u3002 # include <iostream> # include <chrono> // for std::chrono functions // Uses the above DynamicArray class class Timer { private : // Type aliases to make accessing nested type easier using clock_t = std :: chrono :: high_resolution_clock ; using second_t = std :: chrono :: duration < double , std :: ratio < 1 > > ; std :: chrono :: time_point < clock_t > m_beg ; public : Timer () : m_beg ( clock_t :: now ()) { } void reset () { m_beg = clock_t :: now (); } double elapsed () const { return std :: chrono :: duration_cast < second_t > ( clock_t :: now () - m_beg ). count (); } }; // Return a copy of arr with all of the values doubled DynamicArray < int > cloneArrayAndDouble ( const DynamicArray < int > & arr ) { DynamicArray < int > dbl ( arr . getLength ()); for ( int i = 0 ; i < arr . getLength (); ++ i ) dbl [ i ] = arr [ i ] * 2 ; return dbl ; } int main () { Timer t ; DynamicArray < int > arr ( 1000000 ); for ( int i = 0 ; i < arr . getLength (); i ++ ) arr [ i ] = i ; arr = cloneArrayAndDouble ( arr ); std :: cout << t . elapsed (); } \u5728\u4f5c\u8005\u4e4b\u4e00\u7684\u673a\u5668\u4e0a\uff0c\u5728\u53d1\u5e03\u6a21\u5f0f\u4e0b\uff0c\u8fd9\u6bb5\u7a0b\u5e8f\u5728 0.00825559 \u79d2\u5185\u6267\u884c\u5b8c\u3002 \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u518d\u6b21\u8fd0\u884c\u540c\u6837\u7684\u7a0b\u5e8f\uff0c\u4f7f\u7528\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c\u51fd\u6570\u6765\u66ff\u6362\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u3002 template < class T > class DynamicArray { private : T * m_array ; int m_length ; public : DynamicArray ( int length ) : m_array ( new T [ length ]), m_length ( length ) { } ~ DynamicArray () { delete [] m_array ; } // Copy constructor DynamicArray ( const DynamicArray & arr ) = delete ; // Copy assignment DynamicArray & operator = ( const DynamicArray & arr ) = delete ; // Move constructor DynamicArray ( DynamicArray && arr ) : m_length ( arr . m_length ), m_array ( arr . m_array ) { arr . m_length = 0 ; arr . m_array = nullptr ; } // Move assignment DynamicArray & operator = ( DynamicArray && arr ) { if ( & arr == this ) return * this ; delete [] m_array ; m_length = arr . m_length ; m_array = arr . m_array ; arr . m_length = 0 ; arr . m_array = nullptr ; return * this ; } int getLength () const { return m_length ; } T & operator []( int index ) { return m_array [ index ]; } const T & operator []( int index ) const { return m_array [ index ]; } }; # include <iostream> # include <chrono> // for std::chrono functions class Timer { private : // Type aliases to make accessing nested type easier using clock_t = std :: chrono :: high_resolution_clock ; using second_t = std :: chrono :: duration < double , std :: ratio < 1 > > ; std :: chrono :: time_point < clock_t > m_beg ; public : Timer () : m_beg ( clock_t :: now ()) { } void reset () { m_beg = clock_t :: now (); } double elapsed () const { return std :: chrono :: duration_cast < second_t > ( clock_t :: now () - m_beg ). count (); } }; // Return a copy of arr with all of the values doubled DynamicArray < int > cloneArrayAndDouble ( const DynamicArray < int > & arr ) { DynamicArray < int > dbl ( arr . getLength ()); for ( int i = 0 ; i < arr . getLength (); ++ i ) dbl [ i ] = arr [ i ] * 2 ; return dbl ; } int main () { Timer t ; DynamicArray < int > arr ( 1000000 ); for ( int i = 0 ; i < arr . getLength (); i ++ ) arr [ i ] = i ; arr = cloneArrayAndDouble ( arr ); std :: cout << t . elapsed (); } \u5728\u540c\u6837\u7684\u673a\u5668\u4e0a\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u5728 0.0056 \u79d2\u5185\u6267\u884c\u5b8c\u6bd5\u3002 \u6bd4\u8f83\u4e24\u4e2a\u7a0b\u5e8f\u7684\u8fd0\u884c\u65f6\u95f4\uff0c 0.0056 / 0.00825559 = 67.8% \u3002\u201c\u79fb\u52a8\u8bed\u4e49\u201d\u7684\u7248\u672c\u51e0\u4e4e\u5feb\u4e8633%","title":"\u53e6\u4e00\u4e2a\u4f8b\u5b50"},{"location":"15-move-semantics-and-smart-pointers/15.4-std%3A%3Amove/","text":"15.4 std::move \u00b6 By Alex on March 4 th , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.18 \u4e00\u65e6\u4f60\u5f00\u59cb\u4f7f\u7528\u66f4\u52a0\u9891\u7e41\u7684\u4f7f\u7528\u79fb\u52a8\u8bed\u4e49\uff0c\u4f60\u5c31\u4f1a\u53d1\u73b0\u5f88\u591a\u60c5\u51b5\u4e0b\uff0c\u4f60\u60f3\u8981\u8c03\u7528\u79fb\u52a8\u8bed\u4e49\uff0c\u4f46\u662f\u4f60\u521b\u5efa\u7684\u5bf9\u8c61\u4e0d\u5f97\u4e0d\u4f5c\u4e3a\u5de6\u503c\uff0c\u800c\u4e0d\u662f\u53f3\u503c\u3002\u601d\u8003\u4e0b\u5217\u4ea4\u6362\u51fd\u6570\u7684\u4ee3\u7801\uff1a #include <iostream> #include <string> template < class T > void myswap ( T & a , T & b ) { T tmp { a }; // invokes copy constructor a = b ; // invokes copy assignment b = tmp ; // invokes copy assignment } int main () { std :: string x { \"abc\" }; std :: string y { \"de\" }; std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"y: \" << y << '\\n' ; myswap ( x , y ); std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"y: \" << y << '\\n' ; return 0 ; } \u4f20\u5165\u4e24\u4e2a T\uff08\u4f8b\u5b50\u4e2d\u4f7f\u7528\u4e86 std::string \uff09 \u7c7b\u578b\u7684\u5bf9\u8c61\uff0c\u8fd9\u4e2a\u51fd\u6570\u4ea4\u6362\u4ed6\u4eec\u7684\u503c\u901a\u8fc7\u4e09\u6b21\u62f7\u8d1d\u3002 x: abc y: de x: de y: abc \u5728\u6211\u4eec\u5b66\u4e60\u4e86\u4e0a\u8282\u8bfe\u540e\uff0c\u8fdb\u884c\u62f7\u8d1d\u53ef\u80fd\u662f\u4f4e\u6548\u7684\u3002\u5e76\u4e14\u8fd9\u4e2a\u7248\u672c\u7684\u4ea4\u6362\u51fd\u6570\u8fdb\u884c\u4e86\u4e09\u6b21\u62f7\u8d1d\u3002\u90a3\u4f1a\u5f15\u8d77\u8fc7\u91cf\u7684\u5b57\u7b26\u4e32\u521b\u5efa\u548c\u9500\u6bc1\uff0c\u662f\u975e\u5e38\u7f13\u6162\u7684\u3002 \u7136\u800c\uff0c\u5728\u8fd9\u91cc\u8fdb\u884c\u62f7\u8d1d\u662f\u4e0d\u5fc5\u8981\u7684\u3002\u6211\u4eec\u771f\u6b63\u8981\u505a\u7684\u662f\u4ea4\u6362 a \u548c b \u7684\u503c\uff0c\u53ef\u4ee5\u88ab\u4f7f\u7528\u4e09\u6b21\u79fb\u52a8\u6765\u66ff\u4ee3\uff01\u56e0\u6b64\u5982\u679c\u6211\u4eec\u4ece\u62f7\u8d1d\u8bed\u4e49\u5207\u6362\u5230\u79fb\u52a8\u8bed\u4e49\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u6211\u4eec\u7684\u4ee3\u7801\u62e5\u6709\u66f4\u9ad8\u6027\u80fd\u3002 \u600e\u4e48\u505a\u5462\uff1f\u8fd9\u91cc\u7684\u95ee\u9898\u662f a \u548c b \u90fd\u662f\u5de6\u503c\u5f15\u7528\uff0c\u4e0d\u662f\u53f3\u503c\u5f15\u7528\uff0c\u56e0\u6b64\u6211\u4eec\u65e0\u6cd5\u8c03\u7528\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c\u64cd\u4f5c\u7b26\u6765\u66ff\u4ee3\u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5c06\u4f1a\u5f97\u5230\u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c\u7684\u884c\u4e3a\u3002\u6211\u4eec\u80fd\u600e\u4e48\u529e\u5462\uff1f std::move \u00b6 \u5728 C++11 \u4e2d std::move \u662f\u4e00\u4e2a\u6807\u51c6\u5e93\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u53ea\u6709\u4e00\u4e2a\u76ee\u7684\uff0c\u628a\u53c2\u6570\u8f6c\u5316\u4e3a\u53f3\u503c\u3002\u6211\u4eec\u53ef\u4ee5\u4f20\u4e00\u4e2a\u5de6\u503c\u7ed9 std::move \uff0c\u7136\u540e\u5b83\u5c31\u4f1a\u8fd4\u56de\u4e00\u4e2a\u53f3\u503c\u5f15\u7528\u3002 std::move \u88ab\u5b9a\u4e49\u5728 utility \u5934\u4e2d\u3002 \u8fd9\u6709\u4e00\u4e2a\u548c\u4e0a\u9762\u76f8\u540c\uff0c\u4f46\u662f\u4f7f\u7528 std::move \u5c06\u5de6\u503c\u8f6c\u5316\u4e3a\u53f3\u503c\uff0c\u6765\u5b9e\u73b0 myswap() \uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u8c03\u7528\u79fb\u52a8\u8bed\u4e49\uff1a #include <iostream> #include <string> #include <utility> // for std::move template < class T > void myswap ( T & a , T & b ) { T tmp { std :: move ( a ) }; // invokes move constructor a = std :: move ( b ); // invokes move assignment b = std :: move ( tmp ); // invokes move assignment } int main () { std :: string x { \"abc\" }; std :: string y { \"de\" }; std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"y: \" << y << '\\n' ; myswap ( x , y ); std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"y: \" << y << '\\n' ; return 0 ; } This prints the same result as above: x: abc y: de x: de y: abc \u4f46\u662f\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u6027\u80fd\u9ad8\u4e86\u8bb8\u591a\u3002\u5f53 tmp \u88ab\u521d\u59cb\u5316\u65f6\uff0c\u4e0d\u518d\u5bf9 x \u8fdb\u884c\u62f7\u8d1d\uff0c\u6211\u4eec\u7528 std::move \u6765\u8f6c\u5316\u5de6\u503c\u53d8\u91cf x \u6210\u4e00\u4e2a r-value \u3002\u56e0\u4e3a\u53c2\u6570\u662f\u4e00\u4e2a \u53f3\u503c\uff0c\u56e0\u6b64\u79fb\u52a8\u8bed\u4e49\u88ab\u89e6\u53d1\uff0c\u56e0\u6b64 x \u88ab\u79fb\u52a8\u8fdb tmp \u3002 \u4f7f\u7528\u4e00\u5bf9\u4ea4\u6362\uff0cx \u7684\u503c\u88ab\u79fb\u52a8\u5230\u4e86 y \u4e0a\uff0c\u5e76\u4e14 y \u7684\u503c \u5df2\u7ecf\u88ab\u79fb\u52a8\u5230\u4e86 x\u3002 Another example \u00b6 \u5f53\u7528\u5de6\u503c\u586b\u5145\u4e00\u4e2a\u5bb9\u5668\u7684\u5143\u7d20\u65f6\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u7528 std::move \uff0c\u4f8b\u5982 std::vector \u3002 \u5728\u4e0b\u9762\u7684\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u5148\u901a\u8fc7\u62f7\u8d1d\u8bed\u4e49\u6dfb\u52a0\u4e86\u4e00\u4e2a\u5143\u7d20\u5230 vector\uff0c\u7136\u540e\u6211\u4eec\u901a\u8fc7\u79fb\u52a8\u8bed\u4e49\u6dfb\u52a0\u4e00\u4e2a\u5143\u7d20\u5230 vector\u3002 #include <iostream> #include <string> #include <utility> // for std::move #include <vector> int main () { std :: vector < std :: string > v ; std :: string str = \"Knock\" ; std :: cout << \"Copying str \\n \" ; v . push_back ( str ); // calls l-value version of push_back, which copies str into the array element std :: cout << \"str: \" << str << '\\n' ; std :: cout << \"vector: \" << v [ 0 ] << '\\n' ; std :: cout << \" \\n Moving str \\n \" ; v . push_back ( std :: move ( str )); // calls r-value version of push_back, which moves str into the array element std :: cout << \"str: \" << str << '\\n' ; std :: cout << \"vector:\" << v [ 0 ] << ' ' << v [ 1 ] << '\\n' ; return 0 ; } \u7a0b\u5e8f\u6253\u5370\uff1a Copying str str: Knock vector: Knock Moving str str: vector: Knock Knock \u5728\u7b2c\u4e00\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u4f20\u9012\u4e86\u4e00\u4e2a\u5de6\u503c\u5230 push_back() \u4e2d\uff0c\u56e0\u6b64\u5b83\u4f7f\u7528\u4e86\u62f7\u8d1d\u8bed\u4e49\u6765\u6dfb\u52a0\u4e00\u4e2a\u5143\u7d20\u5230 vecotr\u3002\u56e0\u4e3a\u8fd9\u6837\uff0cstr \u4e2d\u7684\u503c\u88ab\u7559\u4e0b\u4e86\u3002 \u5728\u7b2c\u4e8c\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u4f20\u4e86\u4e00\u4e2a\u53f3\u503c\u5230 push_back() \uff08\u5b9e\u9645\u4e0a\u662f\u901a\u8fc7 std::move \u5c06\u5de6\u503c\u8f6c\u5316\u4e3a\u53f3\u503c\uff09\uff0c\u8fd9\u6837\u4e00\u6765\u5b83\u4f7f\u7528\u79fb\u52a8\u8bed\u4e49\u6765\u6dfb\u52a0\u4e00\u4e2a\u5143\u7d20\u5230 vector \u8fd9\u66f4\u52a0\u7684\u9ad8\u6548\uff0c\u56e0\u4e3a vector \u5143\u7d20\u53ef\u4ee5\u5077\u8d70 string \u7684\u503c\uff0c\u800c\u4e0d\u662f\u62f7\u8d1d\u5b83\u3002\u5728\u8fd9\u4e2a\u60c5\u51b5\u4e0b\uff0cstr \u4f1a\u88ab\u7559\u7a7a\u3002 \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u503c\u5f97\u91cd\u7533\u4e00\u904d\u7684\u662f std::move() \u63d0\u4f9b\u4e86\u4e00\u4e2a\u63d0\u793a\u7ed9\u7f16\u8bd1\u5668\uff0c\u7a0b\u5e8f\u5458\u4e0d\u518d\u9700\u8981\u8fd9\u4e2a\u5bf9\u8c61\u4e86\uff08\u81f3\u5c11\uff0c\u4e0d\u9700\u8981\u5b83\u5f53\u524d\u7684\u72b6\u6001\uff09\u3002\u56e0\u6b64\uff0c\u4f60\u5e94\u8be5\u4e0d\u8981\u4f7f\u7528 std::move() \u5728\u4efb\u4f55\u6301\u7eed\u4f7f\u7528\uff0c\u4e0d\u60f3\u88ab\u4fee\u6539\u7684\u5bf9\u8c61\uff0c\u5e76\u4e14\u4f60\u5e94\u8be5\u4e0d\u8981\u671f\u671b\u4efb\u4f55\u7ecf\u8fc7 std::move() \u7684\u5bf9\u8c61\u5728\u7ecf\u8fc7\u79fb\u52a8\u540e\u76f8\u540c\uff01\uff08you should not expect the state of any objects that have had std::move() applied to be the same after they are moved!\uff09 \u79fb\u52a8\u51fd\u6570\u5e94\u8be5\u603b\u662f\u4fdd\u6301\u5bf9\u8c61 well-defined \u7684\u72b6\u6001 \u00b6 \u5982\u6211\u4eec\u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\u4e86\u89e3\u7684\u90a3\u6837\uff0c\u6700\u597d\u603b\u662f\u8ba9\u88ab\u7a83\u53d6\u7684\u5bf9\u8c61\u4fdd\u6301\u67d0\u79cd\u826f\u597d\u7684\uff08\u786e\u5b9a\u6027\uff09\u7684\u72b6\u6001\u3002\u5728\u7406\u60f3\u60c5\u51b5\u4e0b\uff0c\u5e94\u8be5\u662f\u4e00\u4e2a null state \uff0c\u5c06\u5bf9\u8c61\u8bbe\u7f6e\u56de\u5b83\u6700\u521d\u59cb\u6216\u80050\u72b6\u6001\u3002\u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u8c08\u8c08\u4e3a\u4ec0\u4e48\u8fd9\u6837\u505a\uff1a\u4f7f\u7528 std::move \uff0c\u6bd5\u7adf\u88ab\u7a83\u53d6\u7684\u5bf9\u8c61\u4e5f\u53ef\u80fd\u4e0d\u662f\u4e00\u4e2a\u4e34\u65f6\u72b6\u6001\u6bd5\u7adf\u3002\u7528\u6237\u53ef\u80fd\u60f3\u8981\u518d\u6b21\u91cd\u7528\u8fd9\u4e2a\uff08\u73b0\u5728\u4e3a\u7a7a\uff09\u7684\u5bf9\u8c61\uff0c\u6216\u8005\u6d4b\u8bd5\u5b83\u4ee5\u67d0\u79cd\u65b9\u5f0f\uff0c\u5e76\u4e14\u53ef\u80fd\u8fdb\u884c\u76f8\u5e94\u7684\u8ba1\u5212\uff08or test it in some way, and can plan accordingly\uff09\u3002 \u5728\u4ee5\u4e0a\u7684\u4f8b\u5b50\u4e2d\uff0c string \u7c7b\u578b\u7684 str \u88ab\u8bbe\u7f6e\u6210\u7a7a\u5b57\u7b26\u4e32\uff0c\u5728\u88ab\u79fb\u52a8\u4e4b\u540e\uff08std::sttring \u5728\u4e00\u6b21\u6210\u529f\u7684move\u540e\u603b\u662f\u8fd9\u4e48\u505a\uff09\u3002\u8fd9\u5141\u8bb8\u6211\u4eec\u91cd\u7528\u53d8\u91cf str \u5982\u679c\u6211\u4eec\u5e0c\u671b\uff08\u6216\u8005\u6211\u4eec\u53ef\u4ee5\u5ffd\u7565\u5b83\uff0c\u5982\u679c\u6211\u4eec\u4e0d\u518d\u9700\u8981\u4f7f\u7528\u5b83\uff09\u3002 std::move \u5728\u5176\u4ed6\u5730\u65b9\u7684\u5e94\u7528 \u00b6 \u5f53\u6392\u5e8f\u4e00\u4e2a\u6570\u7ec4\u65f6\uff0c std::move \u4e5f\u53ef\u4ee5\u5f88\u6709\u7528\u3002\u8bb8\u591a\u6392\u5e8f\u7b97\u6cd5\uff08\u4f8b\u5982\u9009\u62e9\u6392\u5e8f\u548c\u5192\u6ce1\u6392\u5e8f\uff09\u90fd\u4f1a\u6d89\u53ca\u4e00\u5bf9\u5143\u7d20\u7684\u4ea4\u6362\u3002\u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u501f\u52a9\u62f7\u8d1d\u8bed\u4e49\u6765\u505a\u4ea4\u6362\uff0c\u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u66f4\u9ad8\u6548\u7684\u79fb\u52a8\u8bed\u4e49\u3002 \u5982\u679c\u6211\u4eec\u60f3\u8981\u79fb\u52a8\u6307\u9488\u6240\u7ba1\u7406\u7684 contents \u7ed9\u53e6\u4e00\u4e2a\uff0c\u4e5f\u662f\u5f88\u6709\u7528\u7684\u3002 \u7ed3\u8bba \u00b6 std::move \u53ef\u80fd\u88ab\u7528\u5728\u6bcf\u5f53\u6211\u4eec\u9700\u8981\u5bf9\u5f85\u4e00\u4e2a\u5de6\u503c\u50cf\u5bf9\u5f85\u53f3\u503c\u90a3\u6837\uff0c\u4e3a\u4e86\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\u800c\u4e0d\u662f\u62f7\u8d1d\u8bed\u4e49\u3002","title":"15.4 std::move"},{"location":"15-move-semantics-and-smart-pointers/15.4-std%3A%3Amove/#154-stdmove","text":"By Alex on March 4 th , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.18 \u4e00\u65e6\u4f60\u5f00\u59cb\u4f7f\u7528\u66f4\u52a0\u9891\u7e41\u7684\u4f7f\u7528\u79fb\u52a8\u8bed\u4e49\uff0c\u4f60\u5c31\u4f1a\u53d1\u73b0\u5f88\u591a\u60c5\u51b5\u4e0b\uff0c\u4f60\u60f3\u8981\u8c03\u7528\u79fb\u52a8\u8bed\u4e49\uff0c\u4f46\u662f\u4f60\u521b\u5efa\u7684\u5bf9\u8c61\u4e0d\u5f97\u4e0d\u4f5c\u4e3a\u5de6\u503c\uff0c\u800c\u4e0d\u662f\u53f3\u503c\u3002\u601d\u8003\u4e0b\u5217\u4ea4\u6362\u51fd\u6570\u7684\u4ee3\u7801\uff1a #include <iostream> #include <string> template < class T > void myswap ( T & a , T & b ) { T tmp { a }; // invokes copy constructor a = b ; // invokes copy assignment b = tmp ; // invokes copy assignment } int main () { std :: string x { \"abc\" }; std :: string y { \"de\" }; std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"y: \" << y << '\\n' ; myswap ( x , y ); std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"y: \" << y << '\\n' ; return 0 ; } \u4f20\u5165\u4e24\u4e2a T\uff08\u4f8b\u5b50\u4e2d\u4f7f\u7528\u4e86 std::string \uff09 \u7c7b\u578b\u7684\u5bf9\u8c61\uff0c\u8fd9\u4e2a\u51fd\u6570\u4ea4\u6362\u4ed6\u4eec\u7684\u503c\u901a\u8fc7\u4e09\u6b21\u62f7\u8d1d\u3002 x: abc y: de x: de y: abc \u5728\u6211\u4eec\u5b66\u4e60\u4e86\u4e0a\u8282\u8bfe\u540e\uff0c\u8fdb\u884c\u62f7\u8d1d\u53ef\u80fd\u662f\u4f4e\u6548\u7684\u3002\u5e76\u4e14\u8fd9\u4e2a\u7248\u672c\u7684\u4ea4\u6362\u51fd\u6570\u8fdb\u884c\u4e86\u4e09\u6b21\u62f7\u8d1d\u3002\u90a3\u4f1a\u5f15\u8d77\u8fc7\u91cf\u7684\u5b57\u7b26\u4e32\u521b\u5efa\u548c\u9500\u6bc1\uff0c\u662f\u975e\u5e38\u7f13\u6162\u7684\u3002 \u7136\u800c\uff0c\u5728\u8fd9\u91cc\u8fdb\u884c\u62f7\u8d1d\u662f\u4e0d\u5fc5\u8981\u7684\u3002\u6211\u4eec\u771f\u6b63\u8981\u505a\u7684\u662f\u4ea4\u6362 a \u548c b \u7684\u503c\uff0c\u53ef\u4ee5\u88ab\u4f7f\u7528\u4e09\u6b21\u79fb\u52a8\u6765\u66ff\u4ee3\uff01\u56e0\u6b64\u5982\u679c\u6211\u4eec\u4ece\u62f7\u8d1d\u8bed\u4e49\u5207\u6362\u5230\u79fb\u52a8\u8bed\u4e49\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u6211\u4eec\u7684\u4ee3\u7801\u62e5\u6709\u66f4\u9ad8\u6027\u80fd\u3002 \u600e\u4e48\u505a\u5462\uff1f\u8fd9\u91cc\u7684\u95ee\u9898\u662f a \u548c b \u90fd\u662f\u5de6\u503c\u5f15\u7528\uff0c\u4e0d\u662f\u53f3\u503c\u5f15\u7528\uff0c\u56e0\u6b64\u6211\u4eec\u65e0\u6cd5\u8c03\u7528\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c\u64cd\u4f5c\u7b26\u6765\u66ff\u4ee3\u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5c06\u4f1a\u5f97\u5230\u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c\u7684\u884c\u4e3a\u3002\u6211\u4eec\u80fd\u600e\u4e48\u529e\u5462\uff1f","title":"15.4 std::move"},{"location":"15-move-semantics-and-smart-pointers/15.4-std%3A%3Amove/#stdmove","text":"\u5728 C++11 \u4e2d std::move \u662f\u4e00\u4e2a\u6807\u51c6\u5e93\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u53ea\u6709\u4e00\u4e2a\u76ee\u7684\uff0c\u628a\u53c2\u6570\u8f6c\u5316\u4e3a\u53f3\u503c\u3002\u6211\u4eec\u53ef\u4ee5\u4f20\u4e00\u4e2a\u5de6\u503c\u7ed9 std::move \uff0c\u7136\u540e\u5b83\u5c31\u4f1a\u8fd4\u56de\u4e00\u4e2a\u53f3\u503c\u5f15\u7528\u3002 std::move \u88ab\u5b9a\u4e49\u5728 utility \u5934\u4e2d\u3002 \u8fd9\u6709\u4e00\u4e2a\u548c\u4e0a\u9762\u76f8\u540c\uff0c\u4f46\u662f\u4f7f\u7528 std::move \u5c06\u5de6\u503c\u8f6c\u5316\u4e3a\u53f3\u503c\uff0c\u6765\u5b9e\u73b0 myswap() \uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u8c03\u7528\u79fb\u52a8\u8bed\u4e49\uff1a #include <iostream> #include <string> #include <utility> // for std::move template < class T > void myswap ( T & a , T & b ) { T tmp { std :: move ( a ) }; // invokes move constructor a = std :: move ( b ); // invokes move assignment b = std :: move ( tmp ); // invokes move assignment } int main () { std :: string x { \"abc\" }; std :: string y { \"de\" }; std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"y: \" << y << '\\n' ; myswap ( x , y ); std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"y: \" << y << '\\n' ; return 0 ; } This prints the same result as above: x: abc y: de x: de y: abc \u4f46\u662f\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u6027\u80fd\u9ad8\u4e86\u8bb8\u591a\u3002\u5f53 tmp \u88ab\u521d\u59cb\u5316\u65f6\uff0c\u4e0d\u518d\u5bf9 x \u8fdb\u884c\u62f7\u8d1d\uff0c\u6211\u4eec\u7528 std::move \u6765\u8f6c\u5316\u5de6\u503c\u53d8\u91cf x \u6210\u4e00\u4e2a r-value \u3002\u56e0\u4e3a\u53c2\u6570\u662f\u4e00\u4e2a \u53f3\u503c\uff0c\u56e0\u6b64\u79fb\u52a8\u8bed\u4e49\u88ab\u89e6\u53d1\uff0c\u56e0\u6b64 x \u88ab\u79fb\u52a8\u8fdb tmp \u3002 \u4f7f\u7528\u4e00\u5bf9\u4ea4\u6362\uff0cx \u7684\u503c\u88ab\u79fb\u52a8\u5230\u4e86 y \u4e0a\uff0c\u5e76\u4e14 y \u7684\u503c \u5df2\u7ecf\u88ab\u79fb\u52a8\u5230\u4e86 x\u3002","title":"std::move"},{"location":"15-move-semantics-and-smart-pointers/15.4-std%3A%3Amove/#another-example","text":"\u5f53\u7528\u5de6\u503c\u586b\u5145\u4e00\u4e2a\u5bb9\u5668\u7684\u5143\u7d20\u65f6\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u7528 std::move \uff0c\u4f8b\u5982 std::vector \u3002 \u5728\u4e0b\u9762\u7684\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u5148\u901a\u8fc7\u62f7\u8d1d\u8bed\u4e49\u6dfb\u52a0\u4e86\u4e00\u4e2a\u5143\u7d20\u5230 vector\uff0c\u7136\u540e\u6211\u4eec\u901a\u8fc7\u79fb\u52a8\u8bed\u4e49\u6dfb\u52a0\u4e00\u4e2a\u5143\u7d20\u5230 vector\u3002 #include <iostream> #include <string> #include <utility> // for std::move #include <vector> int main () { std :: vector < std :: string > v ; std :: string str = \"Knock\" ; std :: cout << \"Copying str \\n \" ; v . push_back ( str ); // calls l-value version of push_back, which copies str into the array element std :: cout << \"str: \" << str << '\\n' ; std :: cout << \"vector: \" << v [ 0 ] << '\\n' ; std :: cout << \" \\n Moving str \\n \" ; v . push_back ( std :: move ( str )); // calls r-value version of push_back, which moves str into the array element std :: cout << \"str: \" << str << '\\n' ; std :: cout << \"vector:\" << v [ 0 ] << ' ' << v [ 1 ] << '\\n' ; return 0 ; } \u7a0b\u5e8f\u6253\u5370\uff1a Copying str str: Knock vector: Knock Moving str str: vector: Knock Knock \u5728\u7b2c\u4e00\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u4f20\u9012\u4e86\u4e00\u4e2a\u5de6\u503c\u5230 push_back() \u4e2d\uff0c\u56e0\u6b64\u5b83\u4f7f\u7528\u4e86\u62f7\u8d1d\u8bed\u4e49\u6765\u6dfb\u52a0\u4e00\u4e2a\u5143\u7d20\u5230 vecotr\u3002\u56e0\u4e3a\u8fd9\u6837\uff0cstr \u4e2d\u7684\u503c\u88ab\u7559\u4e0b\u4e86\u3002 \u5728\u7b2c\u4e8c\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u4f20\u4e86\u4e00\u4e2a\u53f3\u503c\u5230 push_back() \uff08\u5b9e\u9645\u4e0a\u662f\u901a\u8fc7 std::move \u5c06\u5de6\u503c\u8f6c\u5316\u4e3a\u53f3\u503c\uff09\uff0c\u8fd9\u6837\u4e00\u6765\u5b83\u4f7f\u7528\u79fb\u52a8\u8bed\u4e49\u6765\u6dfb\u52a0\u4e00\u4e2a\u5143\u7d20\u5230 vector \u8fd9\u66f4\u52a0\u7684\u9ad8\u6548\uff0c\u56e0\u4e3a vector \u5143\u7d20\u53ef\u4ee5\u5077\u8d70 string \u7684\u503c\uff0c\u800c\u4e0d\u662f\u62f7\u8d1d\u5b83\u3002\u5728\u8fd9\u4e2a\u60c5\u51b5\u4e0b\uff0cstr \u4f1a\u88ab\u7559\u7a7a\u3002 \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u503c\u5f97\u91cd\u7533\u4e00\u904d\u7684\u662f std::move() \u63d0\u4f9b\u4e86\u4e00\u4e2a\u63d0\u793a\u7ed9\u7f16\u8bd1\u5668\uff0c\u7a0b\u5e8f\u5458\u4e0d\u518d\u9700\u8981\u8fd9\u4e2a\u5bf9\u8c61\u4e86\uff08\u81f3\u5c11\uff0c\u4e0d\u9700\u8981\u5b83\u5f53\u524d\u7684\u72b6\u6001\uff09\u3002\u56e0\u6b64\uff0c\u4f60\u5e94\u8be5\u4e0d\u8981\u4f7f\u7528 std::move() \u5728\u4efb\u4f55\u6301\u7eed\u4f7f\u7528\uff0c\u4e0d\u60f3\u88ab\u4fee\u6539\u7684\u5bf9\u8c61\uff0c\u5e76\u4e14\u4f60\u5e94\u8be5\u4e0d\u8981\u671f\u671b\u4efb\u4f55\u7ecf\u8fc7 std::move() \u7684\u5bf9\u8c61\u5728\u7ecf\u8fc7\u79fb\u52a8\u540e\u76f8\u540c\uff01\uff08you should not expect the state of any objects that have had std::move() applied to be the same after they are moved!\uff09","title":"Another example"},{"location":"15-move-semantics-and-smart-pointers/15.4-std%3A%3Amove/#well-defined","text":"\u5982\u6211\u4eec\u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\u4e86\u89e3\u7684\u90a3\u6837\uff0c\u6700\u597d\u603b\u662f\u8ba9\u88ab\u7a83\u53d6\u7684\u5bf9\u8c61\u4fdd\u6301\u67d0\u79cd\u826f\u597d\u7684\uff08\u786e\u5b9a\u6027\uff09\u7684\u72b6\u6001\u3002\u5728\u7406\u60f3\u60c5\u51b5\u4e0b\uff0c\u5e94\u8be5\u662f\u4e00\u4e2a null state \uff0c\u5c06\u5bf9\u8c61\u8bbe\u7f6e\u56de\u5b83\u6700\u521d\u59cb\u6216\u80050\u72b6\u6001\u3002\u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u8c08\u8c08\u4e3a\u4ec0\u4e48\u8fd9\u6837\u505a\uff1a\u4f7f\u7528 std::move \uff0c\u6bd5\u7adf\u88ab\u7a83\u53d6\u7684\u5bf9\u8c61\u4e5f\u53ef\u80fd\u4e0d\u662f\u4e00\u4e2a\u4e34\u65f6\u72b6\u6001\u6bd5\u7adf\u3002\u7528\u6237\u53ef\u80fd\u60f3\u8981\u518d\u6b21\u91cd\u7528\u8fd9\u4e2a\uff08\u73b0\u5728\u4e3a\u7a7a\uff09\u7684\u5bf9\u8c61\uff0c\u6216\u8005\u6d4b\u8bd5\u5b83\u4ee5\u67d0\u79cd\u65b9\u5f0f\uff0c\u5e76\u4e14\u53ef\u80fd\u8fdb\u884c\u76f8\u5e94\u7684\u8ba1\u5212\uff08or test it in some way, and can plan accordingly\uff09\u3002 \u5728\u4ee5\u4e0a\u7684\u4f8b\u5b50\u4e2d\uff0c string \u7c7b\u578b\u7684 str \u88ab\u8bbe\u7f6e\u6210\u7a7a\u5b57\u7b26\u4e32\uff0c\u5728\u88ab\u79fb\u52a8\u4e4b\u540e\uff08std::sttring \u5728\u4e00\u6b21\u6210\u529f\u7684move\u540e\u603b\u662f\u8fd9\u4e48\u505a\uff09\u3002\u8fd9\u5141\u8bb8\u6211\u4eec\u91cd\u7528\u53d8\u91cf str \u5982\u679c\u6211\u4eec\u5e0c\u671b\uff08\u6216\u8005\u6211\u4eec\u53ef\u4ee5\u5ffd\u7565\u5b83\uff0c\u5982\u679c\u6211\u4eec\u4e0d\u518d\u9700\u8981\u4f7f\u7528\u5b83\uff09\u3002","title":"\u79fb\u52a8\u51fd\u6570\u5e94\u8be5\u603b\u662f\u4fdd\u6301\u5bf9\u8c61 well-defined \u7684\u72b6\u6001"},{"location":"15-move-semantics-and-smart-pointers/15.4-std%3A%3Amove/#stdmove_1","text":"\u5f53\u6392\u5e8f\u4e00\u4e2a\u6570\u7ec4\u65f6\uff0c std::move \u4e5f\u53ef\u4ee5\u5f88\u6709\u7528\u3002\u8bb8\u591a\u6392\u5e8f\u7b97\u6cd5\uff08\u4f8b\u5982\u9009\u62e9\u6392\u5e8f\u548c\u5192\u6ce1\u6392\u5e8f\uff09\u90fd\u4f1a\u6d89\u53ca\u4e00\u5bf9\u5143\u7d20\u7684\u4ea4\u6362\u3002\u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u501f\u52a9\u62f7\u8d1d\u8bed\u4e49\u6765\u505a\u4ea4\u6362\uff0c\u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u66f4\u9ad8\u6548\u7684\u79fb\u52a8\u8bed\u4e49\u3002 \u5982\u679c\u6211\u4eec\u60f3\u8981\u79fb\u52a8\u6307\u9488\u6240\u7ba1\u7406\u7684 contents \u7ed9\u53e6\u4e00\u4e2a\uff0c\u4e5f\u662f\u5f88\u6709\u7528\u7684\u3002","title":"std::move \u5728\u5176\u4ed6\u5730\u65b9\u7684\u5e94\u7528"},{"location":"15-move-semantics-and-smart-pointers/15.4-std%3A%3Amove/#_1","text":"std::move \u53ef\u80fd\u88ab\u7528\u5728\u6bcf\u5f53\u6211\u4eec\u9700\u8981\u5bf9\u5f85\u4e00\u4e2a\u5de6\u503c\u50cf\u5bf9\u5f85\u53f3\u503c\u90a3\u6837\uff0c\u4e3a\u4e86\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\u800c\u4e0d\u662f\u62f7\u8d1d\u8bed\u4e49\u3002","title":"\u7ed3\u8bba"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/","text":"15.5 std::unique_ptr \u00b6 By Alex on March 15 th , 2017 | last modified by nascardriver on July 12 th , 2020 \u7ffb\u8bd1by dashjay 2020.07.18 \u5728\u672c\u7ae0\u7684\u5f00\u59cb\uff0c\u6211\u4eec\u8ba8\u8bba\u4e86\u5728\u4e00\u4e9b\u6761\u4ef6\u4e0b\uff0c\u5982\u4f55\u4f7f\u7528\u6307\u9488\u4f1a\u5f15\u8d77bug\u548c\u5185\u5b58\u6cc4\u9732\u3002\u4f8b\u5982\uff0c\u8fd9\u5c31\u53ef\u80fd\u4f1a\u53d1\u751f\u5728\uff0c\u5f53\u4e00\u4e2a\u51fd\u6570\u63d0\u524d\u9000\u51fa\uff0c\u6216\u629b\u51fa\u5f02\u5e38\uff0c\u6216\u8005\u6307\u9488\u6ca1\u6709\u88ab\u5408\u7406\u7684\u5220\u9664\u65f6\u3002 #include <iostream> void someFunction () { auto * ptr { new Resource () }; int x {}; std :: cout << \"Enter an integer: \" ; std :: cin >> x ; if ( x == 0 ) throw 0 ; // the function returns early, and ptr won\u2019t be deleted! // do stuff with ptr here delete ptr ; } \u65e2\u7136\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86 \u79fb\u52a8\u8bed\u4e49 \u7684\u64cd\u4f5c\uff0c\u6211\u4eec\u53ef\u4ee5\u56de\u5230 \u667a\u80fd\u6307\u9488 \u7684\u8bdd\u9898\u4e86\u3002\u63d0\u9192\u4e00\u4e0b\uff0c \u667a\u80fd\u6307\u9488 \u662f\u4e00\u4e2a\u7ba1\u7406\u7740 \u52a8\u6001\u5206\u914d\u8d44\u6e90 \u7684\u7c7b\uff0c\u5e76\u4e14\u4fdd\u8bc1\u52a8\u6001\u5206\u914d\u7684\u5bf9\u8c61\u5728\u5408\u9002\u7684\u65f6\u95f4\u88ab\u5408\u9002\u7684 \u91ca\u653e \uff0c\uff08\u901a\u5e38\u662f\u667a\u80fd\u6307\u9488\u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff09\u3002 \u56e0\u4e3a\u8fd9\u6837\uff0c\u667a\u80fd\u6307\u9488\u672c\u8eab\u5e94\u8be5\u4ece\u4e0d\u88ab\u52a8\u6001\u5206\u914d\uff08\u5426\u5219\uff0c\u5982\u679c\u4ed6\u4eec\u81ea\u5df1\u672c\u8eab\u5c31\u53ef\u80fd\u6709\u6ca1\u88ab\u5408\u9002\u5730\u91ca\u653e\u7684\u98ce\u9669\uff0c\u8fd9\u610f\u5473\u7740\u5b83\u6301\u6709\u7684\u5bf9\u8c61\u5c06\u4e0d\u4f1a\u88ab\u91ca\u653e\uff0c\u9020\u6210\u5185\u5b58\u6cc4\u9732\uff09\u3002\u901a\u8fc7\u59cb\u7ec8\u53ea\u5728\u6808\u533a\u521b\u5efa\u667a\u80fd\u6307\u9488\u7684\u65b9\u5f0f\uff08\u4f5c\u4e3a\u5c40\u90e8\u53d8\u91cf\u6216\u8005\u662f\u5176\u4ed6\u7c7b\u7684\u7ec4\u6210\uff09\uff0c\u6211\u4eec\u4fdd\u8bc1\u90a3\u6837\u7684\u667a\u80fd\u6307\u9488\u5c06\u4f1a\u5408\u7406\u5730\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5f53\u51fd\u6570\u7ed3\u675f\u6216\u8005\u5bf9\u8c61\u79bb\u5f00\u4f5c\u7528\u57df\u65f6\u65f6\uff0c\u80fd\u786e\u4fdd\u667a\u80fd\u6307\u9488 \u6301\u6709\u7684\u5bf9\u8c61 \u88ab\u5408\u9002\u7684\u91ca\u653e\u3002 C++11 \u6807\u51c6\u5e93\u9644\u5e26\u56db\u79cd\u6307\u9488\u7c7b\u578b\uff1a std::auto_ptr \uff08\u4e0d\u5e94\u8be5\u4f7f\u7528\u2014\u2014\u2014\u2014\u5728C++17\u4e2d\u5df2\u7ecf\u88ab\u79fb\u9664\uff09\uff0c std::unique_ptr \uff0c std::share_ptr \u548c std::weak_ptr \u3002 std::unique_ptr \u662f\u76ee\u524d\u6700\u591a\u4f7f\u7528\u7684\u667a\u80fd\u6307\u9488\u7c7b\uff0c\u56e0\u6b64\u6211\u4eec\u4e5f\u7b2c\u4e00\u4e2a\u6765\u8bb2\u5b83\u3002\u5728\u4e4b\u540e\u7684\u8bfe\u7a0b\u91cc\uff0c\u6211\u4eec\u4f1a\u8bb2 std::shared_ptr \u548c std::weak_ptr \u3002 std::unique_ptr \u00b6 std::unique_ptr \u662f C++11 \u4e2d std::auto_ptr \u7684\u66ff\u4ee3\u54c1\u3002\u5b83\u5e94\u8be5\u88ab\u7528\u4e8e\u7ba1\u7406\u4efb\u4f55\u52a8\u6001\u5206\u914d\uff0c\u5e76\u4e0d\u4f1a\u5728\u591a\u4e2a\u5bf9\u8c61\u4e2d\u5206\u4eab\u7684\u5bf9\u8c61\u3002 std::unique_ptr \uff0c\u5e94\u8be5\u5b8c\u5168\u7684\u6301\u6709\u5b83\u7ba1\u7406\u7684\u5bf9\u8c61\uff0c\u4e0d\u5e94\u8be5\u548c\u5176\u4ed6\u7c7b\u578b\u5206\u4eab\u5bf9\u8c61\u7684\u6240\u6709\u6743\u3002 std::unique_ptr \u5b9a\u4e49\u5728 <memory> \u5934\u4e2d\u3002 \u8ba9\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u8fd9\u4e2a\u7b80\u5355\u7684\u667a\u80fd\u6307\u9488\u7684\u4f8b\u5b50\uff1a # include <iostream> # include <memory> // for std::unique_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { // allocate a Resource object and have it owned by std::unique_ptr std :: unique_ptr < Resource > res { new Resource () }; return 0 ; } // res goes out of scope here, and the allocated Resource is destroyed \u56e0\u4e3a std::unique_ptr \u5728\u6808\u533a\u4e0a\u88ab\u5206\u914d\uff0c\u5b83\u6700\u7ec8\u4f1a\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5e76\u4e14\u4f1a\u81ea\u52a8\u5220\u9664\u5b83\u7ba1\u7406\u7684\u8d44\u6e90\u3002 \u4e0d\u50cf std::auto_ptr \uff0c std::unique_ptr \u66f4\u9002\u5408\u7528\u6765\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\u3002 # include <iostream> # include <memory> // for std::unique_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { std :: unique_ptr < Resource > res1 { new Resource {} }; // Resource created here std :: unique_ptr < Resource > res2 {}; // Start as nullptr std :: cout << \"res1 is \" << ( static_cast < bool > ( res1 ) ? \"not null \\n \" : \"null \\n \" ); std :: cout << \"res2 is \" << ( static_cast < bool > ( res2 ) ? \"not null \\n \" : \"null \\n \" ); // res2 = res1; // Won't compile: copy assignment is disabled res2 = std :: move ( res1 ); // res2 assumes ownership, res1 is set to null std :: cout << \"Ownership transferred \\n \" ; std :: cout << \"res1 is \" << ( static_cast < bool > ( res1 ) ? \"not null \\n \" : \"null \\n \" ); std :: cout << \"res2 is \" << ( static_cast < bool > ( res2 ) ? \"not null \\n \" : \"null \\n \" ); return 0 ; } // Resource destroyed here when res2 goes out of scope \u8fd9\u4e2a\u4f8b\u5b50\u4f1a\u6253\u5370\uff1a Resource acquired res1 is not null res2 is null Ownership transferred res1 is null res2 is not null Resource destroyed \u56e0\u4e3a std__unique_ptr \u5728\u8bbe\u8ba1\u65f6\u8003\u8651\u4e86\u79fb\u52a8\u8bed\u4e49\uff0c \u62f7\u8d1d\u521d\u59cb\u5316 \u548c \u62f7\u8d1d\u8d4b\u503c \u90fd\u88ab\u7981\u7528\u4e86\u3002\u5982\u679c\u4f60\u6211\u76f8\u8981\u8f6c\u79fb\u4e00\u4e2a\u88ab std::unique_ptr \u7ba1\u7406\u7684\u5185\u5bb9\uff0c\u4f60\u5fc5\u987b\u4f7f\u7528 \u79fb\u52a8\u8bed\u4e49 \u3002\u5728\u4ee5\u4e0a\u7684\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528 std::move \uff08\u5c06 res1 \u8f6c\u5316\u6210\u4e00\u4e2a\u53f3\u503c\uff0c\u53ef\u4ee5\u89e6\u53d1\u4e00\u4e2a\u79fb\u52a8\u8d4b\u503c\uff0c\u800c\u4e0d\u662f\u62f7\u8d1d\u8d4b\u503c\uff09 \u6765\u5b8c\u6210\u3002 \u8bbf\u95ee\u88ab\u7ba1\u7406\u7684\u5bf9\u8c61 \u00b6 std::unique_ptr \u91cd\u8f7d\u4e86 *\u64cd\u4f5c\u7b26 \u548c ->\u64cd\u4f5c\u7b26 \u53ef\u4ee5\u7528\u6765\u8fd4\u56de\u6240\u7ba1\u7406\u7684\u8d44\u6e90\uff0c operator* \u8fd4\u56de\u4e00\u4e2a\u8d44\u6e90\u7684\u5f15\u7528\uff0c operator-> \u8fd4\u56de\u4e00\u4e2a\u6307\u9488\u3002 \u8bb0\u4f4f std::unique_ptr \u53ef\u80fd\u4e0d\u603b\u662f\u7ba1\u7406\u4e00\u4e2a\u8d44\u6e90\uff0c\u5b83\u4e5f\u53ef\u80fd\u88ab\u521b\u9020\u4e3a\u7a7a(\u4f7f\u7528\u9ed8\u8ba4\u7684\u6784\u9020\u51fd\u6570\u5e76\u4e14\u4f20\u5165\u4e00\u4e2a\u7a7a\u6307\u9488\u4f5c\u4e3a\u53c2\u6570)\uff0c\u6216\u8005\u56e0\u4e3a\u5b83\u7ba1\u7406\u7684\u8d44\u6e90\u88ab\u79fb\u52a8\u5230\u53e6\u4e00\u4e2a std::unique_ptr . \u56e0\u6b64\u5728\u6211\u4eec\u4f7f\u7528\u8fd9\u4e9b\u6307\u9488\u4e4b\u524d\uff0c\u6211\u4eec\u5e94\u8be5\u68c0\u67e5 std::unique_ptr \u662f\u5426\u7ba1\u7406\u4e00\u4e2a\u8d44\u6e90\u3002\u5e78\u8fd0\u7684\u662f\uff0c\u8fd9\u5f88\u7b80\u5355\uff1a std::unique_ptr \u6709\u4e00\u4e2a\u53ef\u4ee5\u8f6c\u5316\u6210\u4e00\u4e2abool\u503c\u7684\u51fd\u6570\uff0c\u5982\u679c\u8be5 unique_ptr \u7ba1\u7406\u4e00\u4efd\u8d44\u6e90\u5219\u8fd4\u56de true\u3002 \u8fd9\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff1a # include <iostream> # include <memory> // for std::unique_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } friend std :: ostream & operator << ( std :: ostream & out , const Resource & res ) { out << \"I am a resource \\n \" ; return out ; } }; int main () { std :: unique_ptr < Resource > res { new Resource {} }; if ( res ) // use implicit cast to bool to ensure res contains a Resource std :: cout << * res << '\\n' ; // print the Resource that res is owning return 0 ; } \u8f93\u51fa\uff1a Resource acquired I am a resource Resource destroyed \u5728\u4e0a\u65b9\u7684\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u91cd\u8f7d\u7684 operator* \u6765\u83b7\u5f97 unique_ptr \u6301\u6709\u7684\u8d44\u6e90\uff0c\u7136\u540e\u9001\u5230 std::cout \u6253\u5370\u3002 std::unique_ptr \u548c\u6570\u7ec4 \u00b6 \u4e0d\u50cf std::auto_ptr \u90a3\u6837\uff0c std::unique_ptr \u662f\u8db3\u591f\u667a\u80fd\u7684\u77e5\u9053\u662f\u5426\u4f7f\u7528\u6807\u91cf\u5220\u9664(scalar delete)\u6216\u6570\u7ec4\u5220\u9664(array delete[])\uff0c\u56e0\u6b64 std::unique_ptr \u53ef\u4ee5\u540c\u65f6\u642d\u914d scalar objects \u548c arrays \u3002 \u7136\u800c\uff0c std::array \u6216\u8005 std::vector (\u6216 std::string ) \u603b\u4f1a\u662f\u4e00\u4e2a\u66f4\u597d\u7684\u9009\u62e9\uff0c\u76f8\u6bd4\u8d77\u7528\u56fa\u5b9a\u6570\u7ec4( fixed array )\uff0cC\u7c7b\u578b\u5b57\u7b26\u4e32( C-style string ) \u6216 \u52a8\u6001\u6570\u7ec4\uff08 dynamic array \uff09\u642d\u914d std::unique_ptr \u3002 \u89c4\u5219\uff1a\u66f4\u52a0\u504f\u597d\u4f7f\u7528 std::array , std::vector \u6216\u8005 std::string \u800c\u4e0d\u662f\u667a\u80fd\u6307\u9488\u7ba1\u7406\u7684\u5b9a\u957f\u6570\u7ec4\uff0c\u52a8\u6001\u6570\u7ec4\uff0c\u6216\u8005C\u98ce\u683c\u5b57\u7b26\u4e32\u3002 std::make_unique \u00b6 C++14 \u5e26\u6709\u4e00\u4e2a\u9644\u52a0\u7684\u51fd\u6570\u53eb\u505a std::make_unique() \u3002\u6b64\u6a21\u677f\u5316\u51fd\u6570\u6784\u9020\u6a21\u677f\u7c7b\u578b\u7684\u5bf9\u8c61\uff0c\u5e76\u4f7f\u7528\u4f20\u9012\u7ed9\u51fd\u6570\u7684\u53c2\u6570\u5bf9\u5176\u8fdb\u884c\u521d\u59cb\u5316\u3002 # include <memory> // for std::unique_ptr and std::make_unique # include <iostream> class Fraction { private : int m_numerator { 0 }; int m_denominator { 1 }; public : Fraction ( int numerator = 0 , int denominator = 1 ) : m_numerator { numerator }, m_denominator { denominator } { } friend std :: ostream & operator << ( std :: ostream & out , const Fraction & f1 ) { out << f1 . m_numerator << '/' << f1 . m_denominator ; return out ; } }; int main () { // Create a single dynamically allocated Fraction with numerator 3 and denominator 5 // We can also use automatic type deduction to good effect here auto f1 { std :: make_unique < Fraction > ( 3 , 5 ) }; std :: cout << * f1 << '\\n' ; // Create a dynamically allocated array of Fractions of length 4 auto f2 { std :: make_unique < Fraction [] > ( 4 ) }; std :: cout << f2 [ 0 ] << '\\n' ; return 0 ; } \u8f93\u51fa 3 /5 0 /1 std::make_unique \u7684\u4f7f\u7528\u662f\u4e00\u4e2a\u53ef\u9009\u9879\uff0c\u4f46\u662f\u662f\u975e\u5e38\u63a8\u8350\u7684\u3002\u8fd9\u662f\u56e0\u4e3a\u4f7f\u7528 std::make_unique \u5f88\u7b80\u5355\uff0c\u5e76\u4e14\u5b83\u4e5f\u9700\u8981\u5199\u66f4\u5c11\u7684\u4ee3\u7801\u3002\uff08\u5f53\u4f7f\u7528\u81ea\u52a8\u7c7b\u578b\u5224\u65ad\u65f6\uff09\uff0c\u66f4\u8fdb\u4e00\u6b65\u6765\u8bf4\uff0c\u5b83\u4e5f\u89e3\u51b3\u4e86\u4e00\u4e2a\u5f02\u5e38\u5b89\u5168\u95ee\u9898\uff0c\u8fd9\u4f1a\u5f15\u8d77C++... (Furthermore it resolves an exception safety issue that can result from C++ leaving the order of evaluation for function arguments unspecified.) \u89c4\u5b9a: \u4f7f\u7528 std::make_unique() \u800c\u4e0d\u662f\u81ea\u5df1\u624b\u52a8\u521b\u5efa\u3002 \u5f02\u5e38\u5b89\u5168\u95ee\u9898\u7ec6\u8282 \u00b6 \u7ed9\u90a3\u4e9b\u60f3\u77e5\u9053\u4e0a\u65b9\u63d0\u5230\u7684\u662f\u4ec0\u4e48 \u201c\u5f02\u5e38\u5b89\u5168\u95ee\u9898\u201d\u7684\u4eba\u4e00\u4e9b\u89e3\u91ca\uff0c\u8fd9\u91cc\u6709\u4e00\u4e2a\u5173\u4e8e\u6b64\u95ee\u9898\u7684\u63cf\u8ff0 \u601d\u8003\u4e00\u4e2a\u50cf\u8fd9\u6837\u7684\u8868\u8fbe\u5f0f\uff1a some_function ( std :: unique_ptr < T > ( new T ), function_that_can_throw_exception ()); \u7f16\u8bd1\u5668\u5728\u5982\u4f55\u5904\u7406\u8fd9\u4e2a\u8c03\u7528\u65b9\u9762\u6709\u5f88\u5927\u7684\u6d3b\u52a8\u7a7a\u95f4\u3002\u5b83\u53ef\u80fd\u521b\u5efa\u4e00\u4e2a\u65b0\u7684 T\uff0c\u7136\u540e\u518d\u8c03\u7528 function_that_can_throw_exception() \uff0c\u7136\u540e\u521b\u5efa std::unique_ptr \u7ba1\u7406\u8fd9\u52a8\u6001\u5206\u914d\u7684T\u3002\u5982\u679c function_that_can_throw_exception() \u629b\u51fa\u4e00\u4e2a\u5f02\u5e38\uff0c\u7136\u540e T \u88ab\u5206\u914d\u4f46\u662f\u6ca1\u6709\u88ab\u91ca\u653e\uff0c\u56e0\u4e3a\u7528\u6765\u91ca\u653e\u8be5\u8d44\u6e90\u7684\u667a\u80fd\u6307\u9488\u8fd8\u6ca1\u6709\u88ab\u521b\u5efa\uff0c\u8fd9\u5f15\u8d77\u4e86 T \u7684\u6cc4\u9732\u3002 std::make_unique() \u4e0d\u4f1a\u9047\u5230\u8fd9\u4e2a\u95ee\u9898\uff0c\u56e0\u4e3a\u5bf9\u8c61 T \u7684\u521b\u5efa\u548c\u521b\u5efa std::unique_ptr \u90fd\u53d1\u751f\u5728 std::make_unique() \u51fd\u6570\uff0c\u4e0d\u5b58\u5728\u6267\u884c\u987a\u5e8f\u6a21\u7cca\u7684\u95ee\u9898\u3002 \u4ece\u51fd\u6570\u8fd4\u56de std::unique_ptr \u00b6 std::unique_ptr \u53ef\u4ee5\u88ab\u4ece\u4e00\u4e2a\u51fd\u6570\u5b89\u5168\u7684\u8fd4\u56de\uff1a std :: unique_ptr < Resource > createResource () { return std :: make_unique < Resource > (); } int main () { auto ptr { createResource () }; // do whatever return 0 ; } \u5728\u4e0a\u65b9\u7684\u4ee3\u7801\u4e2d\uff0c createResource() \u901a\u8fc7\u503c\u8fd4\u56de\u4e00\u4e2a std::unique_ptr \u3002\u5982\u679c\u8fd9\u503c\u4e0d\u4f1a\u88ab\u8d4b\u503c\u7ed9\u4efb\u4f55\u5bf9\u8c61\uff0c\u8fd4\u56de\u7684\u4e34\u65f6\u503c\u5c06\u4f1a\u79bb\u5f00\u4f5c\u7528\u57df\u5e76\u4e14\u88ab\u6e05\u7406\u3002\u5982\u679c\u5b83\u88ab\u8d4b\u503c\uff08\u50cfmain\u4e2d\u5c55\u793a\u7684\u90a3\u6837\uff09\uff0c\u5728C++14\u6216\u8005\u66f4\u65e9\uff0c\u79fb\u52a8\u8bed\u4e49\u5c06\u4f1a\u88ab\u4f7f\u7528\u6765\u4ece\u8fd4\u56de\u503c\u8f6c\u79fb\u8d44\u6e90\u5230\u5373\u5c06\u8d4b\u503c\u7684\u5bf9\u8c61\uff08\u4e0a\u65b9\u4f8b\u5b50\u4e2d\u7684ptr\uff09\uff0c\u5728C++17\u6216\u8005\u66f4\u65b0\uff0c\u8fd4\u56de\u5c06\u4f1a\u88ab\u7701\u7565\uff0c\u8fd9\u4f7f\u5f97\u76f8\u6bd4\u8fd4\u56de\u539f\u6307\u9488\uff0c\u8fd4\u56de\u4e00\u4e2a unique_ptr \u7684\u8d44\u6e90\u66f4\u52a0\u5b89\u5168\u3002 \u603b\u4f53\u6765\u8bb2\uff0c\u4f60\u5e94\u8be5\u4ece\u4e0d\u901a\u8fc7\u6307\u9488\u6216\u5f15\u7528\u8fd4\u56de std::unique_ptr \uff08\u9664\u975e\u4f60\u6709\u7279\u6b8a\u7684\u539f\u56e0\u6765\u8fd9\u6837\u505a\uff09\u3002 \u5411\u51fd\u6570\u4f20\u5165 std::unique_ptr \u00b6 \u5982\u679c\u4f60\u60f3\u8981\u51fd\u6570\u6765\u83b7\u5f97\u6307\u9488\u5185\u5bb9\u7684\u6240\u6709\u6743\uff0c\u901a\u8fc7\u503c\u4f20\u4e00\u4e2a std::unique_ptr \u3002\u6ce8\u610f\uff0c\u56e0\u4e3a\u62f7\u8d1d\u8bed\u4e49\u5df2\u7ecf\u88ab\u7981\u7528\uff0c\u4f60\u5c06\u4f1a\u4f7f\u7528 std::move \u6765\u4f20\u503c\u8fdb\u5165\u51fd\u6570\u3002 # include <memory> // for std::unique_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } friend std :: ostream & operator << ( std :: ostream & out , const Resource & res ) { out << \"I am a resource \\n \" ; return out ; } }; void takeOwnership ( std :: unique_ptr < Resource > res ) { if ( res ) std :: cout << * res << '\\n' ; } // the Resource is destroyed here int main () { auto ptr { std :: make_unique < Resource > () }; // takeOwnership(ptr); // This doesn't work, need to use move semantics takeOwnership ( std :: move ( ptr )); // ok: use move semantics std :: cout << \"Ending program \\n \" ; return 0 ; } \u8f93\u51fa\uff1a Resource acquired I am a resource Resource destroyed Ending program \u6ce8\u610f\u5728\u8fd9\u4e2a\u4f8b\u5b50\u91cc\uff0c\u8d44\u6e90\u7684\u6240\u6709\u6743\u88ab\u4f20\u7ed9\u4e86 takeOwnership() \uff0c\u56e0\u6b64\u8d44\u6e90\u5c06\u4f1a\u88ab\u9500\u6bc1\u5728 takeOwnership() \u51fd\u6570\u7ed3\u675f\u65f6\uff0c\u800c\u4e0d\u662f main() \u7136\u800c\uff0c\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u4f60\u4e0d\u60f3\u8ba9\u51fd\u6570\u5f97\u5230\u8d44\u6e90\u7684\u6240\u6709\u6743\u3002\u867d\u7136\u4f60\u53ef\u4ee5\u4f20\u5165\u4e00\u4e2a std::unique_ptr \u7684\u5f15\u7528\uff08\u8fd9\u5141\u8bb8\u51fd\u6570\u4f7f\u7528\u5bf9\u8c61\uff0c\u800c\u4e0d\u5f97\u5230\u6240\u6709\u6743\uff09\uff0c\u4f60\u5e94\u8be5\u4ec5\u4ec5\u5728 \u8c03\u7528\u51fd\u6570\u4f1a\u4fee\u6539\u6216\u8005\u6539\u53d8\u6301\u5176\u7ba1\u7406\u7684\u5bf9\u8c61\u7684\u60c5\u51b5\u4e0b\u4f7f\u7528\u3002 \u76f8\u53cd\uff0c\u66f4\u597d\u7684\u65b9\u5f0f\u662f\u4f20\u5165\u4e00\u4e2a\u8d44\u6e90\u672c\u8eab\uff08\u901a\u8fc7\u6307\u9488\u6216\u8005\u5f15\u7528\uff0c\u6839\u636enull\u662f\u5426\u662f\u4e00\u4e2a\u5408\u6cd5\u7684\u53c2\u6570\uff09\uff0c\u8fd9\u5141\u8bb8\u51fd\u6570\u4fdd\u6301\u8c03\u7528\u8005\u7ba1\u7406\u8d44\u6e90\u3002\u4e3a\u4e86\u4ece\u4e00\u4e2a std::unique_ptr \u5f97\u5230\u539f\u6765\u7684\u8d44\u6e90\u6307\u9488\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528 get() \u6210\u5458\u51fd\u6570\uff1a # include <memory> // for std::unique_ptr # include <iostream> class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } friend std :: ostream & operator << ( std :: ostream & out , const Resource & res ) { out << \"I am a resource \\n \" ; return out ; } }; // The function only uses the resource, so we'll accept a pointer to the resource, not a reference to the whole std::unique_ptr<Resource> void useResource ( Resource * res ) { if ( res ) std :: cout << * res << '\\n' ; } int main () { auto ptr { std :: make_unique < Resource > () }; useResource ( ptr . get ()); // note: get() used here to get a pointer to the Resource std :: cout << \"Ending program \\n \" ; return 0 ; } // The Resource is destroyed here \u8f93\u51fa Resource acquired I am a resource Ending program Resource destroyed std::unique_ptr \u548c\u7c7b\u578b \u00b6 \u5f53\u7136\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528 std::unique_ptr \u4f5c\u4e3a\u4f60\u7684\u7c7b\u578b\u4e2d\u7684\u7ec4\u6210\u90e8\u5206\uff0c\u4ee5\u8fd9\u4e2a\u65b9\u5f0f\uff0c\u4f60\u5c06\u4e0d\u7528\u62c5\u5fc3\u786e\u4fdd\u4f60\u7684\u7c7b\u578b\u7684\u6790\u6784\u51fd\u6570\u91ca\u653e\u52a8\u6001\u5185\u5b58\u4e86\uff0c\u56e0\u4e3a std::uniqut_ptr \u5c06\u4f1a\u81ea\u52a8\u7684\u9500\u6bc1\uff0c\u5f53\u7c7b\u578b\u5bf9\u8c61\u88ab\u9500\u6bc1\u65f6\u3002\u7136\u800c\uff0c\u8bb0\u4f4f\u5982\u679c\u4f60\u7684\u7c7b\u578b\u662f\u52a8\u6001\u5206\u914d\u7684\uff0c\u90a3\u4e48\u5bf9\u8c61\u672c\u8eab\u5c31\u6709\u98ce\u9669\u4e0d\u80fd\u88ab\u6b63\u786e\u7684\u91ca\u653e\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u667a\u80fd\u6307\u9488\u4e5f\u4e0d\u80fd\u5e2e\u4f60\u3002 std::unique_ptr \u7684\u8bef\u7528 \u00b6 \u8fd9\u6709\u4e24\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff0c\u8bef\u7528 std::unique_ptr \uff0c\u4ed6\u4eec\u90fd\u662f\u975e\u5e38\u5bb9\u6613\u907f\u514d\u7684\u3002 \u9996\u5148\uff0c\u4e0d\u8981\u8ba9\u591a\u4e2a\u6307\u9488\u7ba1\u7406\u540c\u6837\u7684\u8d44\u6e90\uff0c\u4f8b\u5982\uff1a Resource * res { new Resource () }; std :: unique_ptr < Resource > res1 { res }; std :: unique_ptr < Resource > res2 { res }; \u8fd9\u5728\u8bed\u4e49\u4e0a\u662f\u5408\u6cd5\u7684\uff0c\u6700\u540e\u7684\u7ed3\u679c\u5c31\u662f res1 \u548c res2 \u5c1d\u8bd5\u5220\u9664\u8d44\u6e90\uff0c\u4f1a\u5f15\u53d1\u672a\u5b9a\u4e49\u884c\u4e3a\u3002 \u7b2c\u4e8c\uff0c\u4e0d\u8981\u624b\u52a8\u5220\u9664 std::unique_ptr \u7ba1\u7406\u7684\u8d44\u6e90 Resource * res { new Resource () }; std :: unique_ptr < Resource > res1 { res }; delete res ; \u5982\u679c\u4f60\u90a3\u6837\u505a\uff0c std::unique_ptr \u5c06\u4f1a\u5c1d\u8bd5\u5220\u9664\u4e00\u4e2a\u65e9\u5c31\u5220\u9664\u7684\u8d44\u6e90\uff0c\u4e5f\u4f1a\u5f15\u8d77\u672a\u5b9a\u4e49\u884c\u4e3a\u3002 \u6211\u4eec\u6ce8\u610f\u5230\uff0c std::make_unique() \u521a\u597d\u65e0\u610f\u4e2d\u5c31\u907f\u514d\u4e86\u8fd9\u4e24\u79cd\u60c5\u51b5\u7684\u53d1\u751f\u3002","title":"15.5 std::unique_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#155-stdunique_ptr","text":"By Alex on March 15 th , 2017 | last modified by nascardriver on July 12 th , 2020 \u7ffb\u8bd1by dashjay 2020.07.18 \u5728\u672c\u7ae0\u7684\u5f00\u59cb\uff0c\u6211\u4eec\u8ba8\u8bba\u4e86\u5728\u4e00\u4e9b\u6761\u4ef6\u4e0b\uff0c\u5982\u4f55\u4f7f\u7528\u6307\u9488\u4f1a\u5f15\u8d77bug\u548c\u5185\u5b58\u6cc4\u9732\u3002\u4f8b\u5982\uff0c\u8fd9\u5c31\u53ef\u80fd\u4f1a\u53d1\u751f\u5728\uff0c\u5f53\u4e00\u4e2a\u51fd\u6570\u63d0\u524d\u9000\u51fa\uff0c\u6216\u629b\u51fa\u5f02\u5e38\uff0c\u6216\u8005\u6307\u9488\u6ca1\u6709\u88ab\u5408\u7406\u7684\u5220\u9664\u65f6\u3002 #include <iostream> void someFunction () { auto * ptr { new Resource () }; int x {}; std :: cout << \"Enter an integer: \" ; std :: cin >> x ; if ( x == 0 ) throw 0 ; // the function returns early, and ptr won\u2019t be deleted! // do stuff with ptr here delete ptr ; } \u65e2\u7136\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86 \u79fb\u52a8\u8bed\u4e49 \u7684\u64cd\u4f5c\uff0c\u6211\u4eec\u53ef\u4ee5\u56de\u5230 \u667a\u80fd\u6307\u9488 \u7684\u8bdd\u9898\u4e86\u3002\u63d0\u9192\u4e00\u4e0b\uff0c \u667a\u80fd\u6307\u9488 \u662f\u4e00\u4e2a\u7ba1\u7406\u7740 \u52a8\u6001\u5206\u914d\u8d44\u6e90 \u7684\u7c7b\uff0c\u5e76\u4e14\u4fdd\u8bc1\u52a8\u6001\u5206\u914d\u7684\u5bf9\u8c61\u5728\u5408\u9002\u7684\u65f6\u95f4\u88ab\u5408\u9002\u7684 \u91ca\u653e \uff0c\uff08\u901a\u5e38\u662f\u667a\u80fd\u6307\u9488\u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff09\u3002 \u56e0\u4e3a\u8fd9\u6837\uff0c\u667a\u80fd\u6307\u9488\u672c\u8eab\u5e94\u8be5\u4ece\u4e0d\u88ab\u52a8\u6001\u5206\u914d\uff08\u5426\u5219\uff0c\u5982\u679c\u4ed6\u4eec\u81ea\u5df1\u672c\u8eab\u5c31\u53ef\u80fd\u6709\u6ca1\u88ab\u5408\u9002\u5730\u91ca\u653e\u7684\u98ce\u9669\uff0c\u8fd9\u610f\u5473\u7740\u5b83\u6301\u6709\u7684\u5bf9\u8c61\u5c06\u4e0d\u4f1a\u88ab\u91ca\u653e\uff0c\u9020\u6210\u5185\u5b58\u6cc4\u9732\uff09\u3002\u901a\u8fc7\u59cb\u7ec8\u53ea\u5728\u6808\u533a\u521b\u5efa\u667a\u80fd\u6307\u9488\u7684\u65b9\u5f0f\uff08\u4f5c\u4e3a\u5c40\u90e8\u53d8\u91cf\u6216\u8005\u662f\u5176\u4ed6\u7c7b\u7684\u7ec4\u6210\uff09\uff0c\u6211\u4eec\u4fdd\u8bc1\u90a3\u6837\u7684\u667a\u80fd\u6307\u9488\u5c06\u4f1a\u5408\u7406\u5730\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5f53\u51fd\u6570\u7ed3\u675f\u6216\u8005\u5bf9\u8c61\u79bb\u5f00\u4f5c\u7528\u57df\u65f6\u65f6\uff0c\u80fd\u786e\u4fdd\u667a\u80fd\u6307\u9488 \u6301\u6709\u7684\u5bf9\u8c61 \u88ab\u5408\u9002\u7684\u91ca\u653e\u3002 C++11 \u6807\u51c6\u5e93\u9644\u5e26\u56db\u79cd\u6307\u9488\u7c7b\u578b\uff1a std::auto_ptr \uff08\u4e0d\u5e94\u8be5\u4f7f\u7528\u2014\u2014\u2014\u2014\u5728C++17\u4e2d\u5df2\u7ecf\u88ab\u79fb\u9664\uff09\uff0c std::unique_ptr \uff0c std::share_ptr \u548c std::weak_ptr \u3002 std::unique_ptr \u662f\u76ee\u524d\u6700\u591a\u4f7f\u7528\u7684\u667a\u80fd\u6307\u9488\u7c7b\uff0c\u56e0\u6b64\u6211\u4eec\u4e5f\u7b2c\u4e00\u4e2a\u6765\u8bb2\u5b83\u3002\u5728\u4e4b\u540e\u7684\u8bfe\u7a0b\u91cc\uff0c\u6211\u4eec\u4f1a\u8bb2 std::shared_ptr \u548c std::weak_ptr \u3002","title":"15.5 std::unique_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#stdunique_ptr","text":"std::unique_ptr \u662f C++11 \u4e2d std::auto_ptr \u7684\u66ff\u4ee3\u54c1\u3002\u5b83\u5e94\u8be5\u88ab\u7528\u4e8e\u7ba1\u7406\u4efb\u4f55\u52a8\u6001\u5206\u914d\uff0c\u5e76\u4e0d\u4f1a\u5728\u591a\u4e2a\u5bf9\u8c61\u4e2d\u5206\u4eab\u7684\u5bf9\u8c61\u3002 std::unique_ptr \uff0c\u5e94\u8be5\u5b8c\u5168\u7684\u6301\u6709\u5b83\u7ba1\u7406\u7684\u5bf9\u8c61\uff0c\u4e0d\u5e94\u8be5\u548c\u5176\u4ed6\u7c7b\u578b\u5206\u4eab\u5bf9\u8c61\u7684\u6240\u6709\u6743\u3002 std::unique_ptr \u5b9a\u4e49\u5728 <memory> \u5934\u4e2d\u3002 \u8ba9\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u8fd9\u4e2a\u7b80\u5355\u7684\u667a\u80fd\u6307\u9488\u7684\u4f8b\u5b50\uff1a # include <iostream> # include <memory> // for std::unique_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { // allocate a Resource object and have it owned by std::unique_ptr std :: unique_ptr < Resource > res { new Resource () }; return 0 ; } // res goes out of scope here, and the allocated Resource is destroyed \u56e0\u4e3a std::unique_ptr \u5728\u6808\u533a\u4e0a\u88ab\u5206\u914d\uff0c\u5b83\u6700\u7ec8\u4f1a\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5e76\u4e14\u4f1a\u81ea\u52a8\u5220\u9664\u5b83\u7ba1\u7406\u7684\u8d44\u6e90\u3002 \u4e0d\u50cf std::auto_ptr \uff0c std::unique_ptr \u66f4\u9002\u5408\u7528\u6765\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\u3002 # include <iostream> # include <memory> // for std::unique_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { std :: unique_ptr < Resource > res1 { new Resource {} }; // Resource created here std :: unique_ptr < Resource > res2 {}; // Start as nullptr std :: cout << \"res1 is \" << ( static_cast < bool > ( res1 ) ? \"not null \\n \" : \"null \\n \" ); std :: cout << \"res2 is \" << ( static_cast < bool > ( res2 ) ? \"not null \\n \" : \"null \\n \" ); // res2 = res1; // Won't compile: copy assignment is disabled res2 = std :: move ( res1 ); // res2 assumes ownership, res1 is set to null std :: cout << \"Ownership transferred \\n \" ; std :: cout << \"res1 is \" << ( static_cast < bool > ( res1 ) ? \"not null \\n \" : \"null \\n \" ); std :: cout << \"res2 is \" << ( static_cast < bool > ( res2 ) ? \"not null \\n \" : \"null \\n \" ); return 0 ; } // Resource destroyed here when res2 goes out of scope \u8fd9\u4e2a\u4f8b\u5b50\u4f1a\u6253\u5370\uff1a Resource acquired res1 is not null res2 is null Ownership transferred res1 is null res2 is not null Resource destroyed \u56e0\u4e3a std__unique_ptr \u5728\u8bbe\u8ba1\u65f6\u8003\u8651\u4e86\u79fb\u52a8\u8bed\u4e49\uff0c \u62f7\u8d1d\u521d\u59cb\u5316 \u548c \u62f7\u8d1d\u8d4b\u503c \u90fd\u88ab\u7981\u7528\u4e86\u3002\u5982\u679c\u4f60\u6211\u76f8\u8981\u8f6c\u79fb\u4e00\u4e2a\u88ab std::unique_ptr \u7ba1\u7406\u7684\u5185\u5bb9\uff0c\u4f60\u5fc5\u987b\u4f7f\u7528 \u79fb\u52a8\u8bed\u4e49 \u3002\u5728\u4ee5\u4e0a\u7684\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528 std::move \uff08\u5c06 res1 \u8f6c\u5316\u6210\u4e00\u4e2a\u53f3\u503c\uff0c\u53ef\u4ee5\u89e6\u53d1\u4e00\u4e2a\u79fb\u52a8\u8d4b\u503c\uff0c\u800c\u4e0d\u662f\u62f7\u8d1d\u8d4b\u503c\uff09 \u6765\u5b8c\u6210\u3002","title":"std::unique_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#_1","text":"std::unique_ptr \u91cd\u8f7d\u4e86 *\u64cd\u4f5c\u7b26 \u548c ->\u64cd\u4f5c\u7b26 \u53ef\u4ee5\u7528\u6765\u8fd4\u56de\u6240\u7ba1\u7406\u7684\u8d44\u6e90\uff0c operator* \u8fd4\u56de\u4e00\u4e2a\u8d44\u6e90\u7684\u5f15\u7528\uff0c operator-> \u8fd4\u56de\u4e00\u4e2a\u6307\u9488\u3002 \u8bb0\u4f4f std::unique_ptr \u53ef\u80fd\u4e0d\u603b\u662f\u7ba1\u7406\u4e00\u4e2a\u8d44\u6e90\uff0c\u5b83\u4e5f\u53ef\u80fd\u88ab\u521b\u9020\u4e3a\u7a7a(\u4f7f\u7528\u9ed8\u8ba4\u7684\u6784\u9020\u51fd\u6570\u5e76\u4e14\u4f20\u5165\u4e00\u4e2a\u7a7a\u6307\u9488\u4f5c\u4e3a\u53c2\u6570)\uff0c\u6216\u8005\u56e0\u4e3a\u5b83\u7ba1\u7406\u7684\u8d44\u6e90\u88ab\u79fb\u52a8\u5230\u53e6\u4e00\u4e2a std::unique_ptr . \u56e0\u6b64\u5728\u6211\u4eec\u4f7f\u7528\u8fd9\u4e9b\u6307\u9488\u4e4b\u524d\uff0c\u6211\u4eec\u5e94\u8be5\u68c0\u67e5 std::unique_ptr \u662f\u5426\u7ba1\u7406\u4e00\u4e2a\u8d44\u6e90\u3002\u5e78\u8fd0\u7684\u662f\uff0c\u8fd9\u5f88\u7b80\u5355\uff1a std::unique_ptr \u6709\u4e00\u4e2a\u53ef\u4ee5\u8f6c\u5316\u6210\u4e00\u4e2abool\u503c\u7684\u51fd\u6570\uff0c\u5982\u679c\u8be5 unique_ptr \u7ba1\u7406\u4e00\u4efd\u8d44\u6e90\u5219\u8fd4\u56de true\u3002 \u8fd9\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff1a # include <iostream> # include <memory> // for std::unique_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } friend std :: ostream & operator << ( std :: ostream & out , const Resource & res ) { out << \"I am a resource \\n \" ; return out ; } }; int main () { std :: unique_ptr < Resource > res { new Resource {} }; if ( res ) // use implicit cast to bool to ensure res contains a Resource std :: cout << * res << '\\n' ; // print the Resource that res is owning return 0 ; } \u8f93\u51fa\uff1a Resource acquired I am a resource Resource destroyed \u5728\u4e0a\u65b9\u7684\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u91cd\u8f7d\u7684 operator* \u6765\u83b7\u5f97 unique_ptr \u6301\u6709\u7684\u8d44\u6e90\uff0c\u7136\u540e\u9001\u5230 std::cout \u6253\u5370\u3002","title":"\u8bbf\u95ee\u88ab\u7ba1\u7406\u7684\u5bf9\u8c61"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#stdunique_ptr_1","text":"\u4e0d\u50cf std::auto_ptr \u90a3\u6837\uff0c std::unique_ptr \u662f\u8db3\u591f\u667a\u80fd\u7684\u77e5\u9053\u662f\u5426\u4f7f\u7528\u6807\u91cf\u5220\u9664(scalar delete)\u6216\u6570\u7ec4\u5220\u9664(array delete[])\uff0c\u56e0\u6b64 std::unique_ptr \u53ef\u4ee5\u540c\u65f6\u642d\u914d scalar objects \u548c arrays \u3002 \u7136\u800c\uff0c std::array \u6216\u8005 std::vector (\u6216 std::string ) \u603b\u4f1a\u662f\u4e00\u4e2a\u66f4\u597d\u7684\u9009\u62e9\uff0c\u76f8\u6bd4\u8d77\u7528\u56fa\u5b9a\u6570\u7ec4( fixed array )\uff0cC\u7c7b\u578b\u5b57\u7b26\u4e32( C-style string ) \u6216 \u52a8\u6001\u6570\u7ec4\uff08 dynamic array \uff09\u642d\u914d std::unique_ptr \u3002 \u89c4\u5219\uff1a\u66f4\u52a0\u504f\u597d\u4f7f\u7528 std::array , std::vector \u6216\u8005 std::string \u800c\u4e0d\u662f\u667a\u80fd\u6307\u9488\u7ba1\u7406\u7684\u5b9a\u957f\u6570\u7ec4\uff0c\u52a8\u6001\u6570\u7ec4\uff0c\u6216\u8005C\u98ce\u683c\u5b57\u7b26\u4e32\u3002","title":"std::unique_ptr \u548c\u6570\u7ec4"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#stdmake_unique","text":"C++14 \u5e26\u6709\u4e00\u4e2a\u9644\u52a0\u7684\u51fd\u6570\u53eb\u505a std::make_unique() \u3002\u6b64\u6a21\u677f\u5316\u51fd\u6570\u6784\u9020\u6a21\u677f\u7c7b\u578b\u7684\u5bf9\u8c61\uff0c\u5e76\u4f7f\u7528\u4f20\u9012\u7ed9\u51fd\u6570\u7684\u53c2\u6570\u5bf9\u5176\u8fdb\u884c\u521d\u59cb\u5316\u3002 # include <memory> // for std::unique_ptr and std::make_unique # include <iostream> class Fraction { private : int m_numerator { 0 }; int m_denominator { 1 }; public : Fraction ( int numerator = 0 , int denominator = 1 ) : m_numerator { numerator }, m_denominator { denominator } { } friend std :: ostream & operator << ( std :: ostream & out , const Fraction & f1 ) { out << f1 . m_numerator << '/' << f1 . m_denominator ; return out ; } }; int main () { // Create a single dynamically allocated Fraction with numerator 3 and denominator 5 // We can also use automatic type deduction to good effect here auto f1 { std :: make_unique < Fraction > ( 3 , 5 ) }; std :: cout << * f1 << '\\n' ; // Create a dynamically allocated array of Fractions of length 4 auto f2 { std :: make_unique < Fraction [] > ( 4 ) }; std :: cout << f2 [ 0 ] << '\\n' ; return 0 ; } \u8f93\u51fa 3 /5 0 /1 std::make_unique \u7684\u4f7f\u7528\u662f\u4e00\u4e2a\u53ef\u9009\u9879\uff0c\u4f46\u662f\u662f\u975e\u5e38\u63a8\u8350\u7684\u3002\u8fd9\u662f\u56e0\u4e3a\u4f7f\u7528 std::make_unique \u5f88\u7b80\u5355\uff0c\u5e76\u4e14\u5b83\u4e5f\u9700\u8981\u5199\u66f4\u5c11\u7684\u4ee3\u7801\u3002\uff08\u5f53\u4f7f\u7528\u81ea\u52a8\u7c7b\u578b\u5224\u65ad\u65f6\uff09\uff0c\u66f4\u8fdb\u4e00\u6b65\u6765\u8bf4\uff0c\u5b83\u4e5f\u89e3\u51b3\u4e86\u4e00\u4e2a\u5f02\u5e38\u5b89\u5168\u95ee\u9898\uff0c\u8fd9\u4f1a\u5f15\u8d77C++... (Furthermore it resolves an exception safety issue that can result from C++ leaving the order of evaluation for function arguments unspecified.) \u89c4\u5b9a: \u4f7f\u7528 std::make_unique() \u800c\u4e0d\u662f\u81ea\u5df1\u624b\u52a8\u521b\u5efa\u3002","title":"std::make_unique"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#_2","text":"\u7ed9\u90a3\u4e9b\u60f3\u77e5\u9053\u4e0a\u65b9\u63d0\u5230\u7684\u662f\u4ec0\u4e48 \u201c\u5f02\u5e38\u5b89\u5168\u95ee\u9898\u201d\u7684\u4eba\u4e00\u4e9b\u89e3\u91ca\uff0c\u8fd9\u91cc\u6709\u4e00\u4e2a\u5173\u4e8e\u6b64\u95ee\u9898\u7684\u63cf\u8ff0 \u601d\u8003\u4e00\u4e2a\u50cf\u8fd9\u6837\u7684\u8868\u8fbe\u5f0f\uff1a some_function ( std :: unique_ptr < T > ( new T ), function_that_can_throw_exception ()); \u7f16\u8bd1\u5668\u5728\u5982\u4f55\u5904\u7406\u8fd9\u4e2a\u8c03\u7528\u65b9\u9762\u6709\u5f88\u5927\u7684\u6d3b\u52a8\u7a7a\u95f4\u3002\u5b83\u53ef\u80fd\u521b\u5efa\u4e00\u4e2a\u65b0\u7684 T\uff0c\u7136\u540e\u518d\u8c03\u7528 function_that_can_throw_exception() \uff0c\u7136\u540e\u521b\u5efa std::unique_ptr \u7ba1\u7406\u8fd9\u52a8\u6001\u5206\u914d\u7684T\u3002\u5982\u679c function_that_can_throw_exception() \u629b\u51fa\u4e00\u4e2a\u5f02\u5e38\uff0c\u7136\u540e T \u88ab\u5206\u914d\u4f46\u662f\u6ca1\u6709\u88ab\u91ca\u653e\uff0c\u56e0\u4e3a\u7528\u6765\u91ca\u653e\u8be5\u8d44\u6e90\u7684\u667a\u80fd\u6307\u9488\u8fd8\u6ca1\u6709\u88ab\u521b\u5efa\uff0c\u8fd9\u5f15\u8d77\u4e86 T \u7684\u6cc4\u9732\u3002 std::make_unique() \u4e0d\u4f1a\u9047\u5230\u8fd9\u4e2a\u95ee\u9898\uff0c\u56e0\u4e3a\u5bf9\u8c61 T \u7684\u521b\u5efa\u548c\u521b\u5efa std::unique_ptr \u90fd\u53d1\u751f\u5728 std::make_unique() \u51fd\u6570\uff0c\u4e0d\u5b58\u5728\u6267\u884c\u987a\u5e8f\u6a21\u7cca\u7684\u95ee\u9898\u3002","title":"\u5f02\u5e38\u5b89\u5168\u95ee\u9898\u7ec6\u8282"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#stdunique_ptr_2","text":"std::unique_ptr \u53ef\u4ee5\u88ab\u4ece\u4e00\u4e2a\u51fd\u6570\u5b89\u5168\u7684\u8fd4\u56de\uff1a std :: unique_ptr < Resource > createResource () { return std :: make_unique < Resource > (); } int main () { auto ptr { createResource () }; // do whatever return 0 ; } \u5728\u4e0a\u65b9\u7684\u4ee3\u7801\u4e2d\uff0c createResource() \u901a\u8fc7\u503c\u8fd4\u56de\u4e00\u4e2a std::unique_ptr \u3002\u5982\u679c\u8fd9\u503c\u4e0d\u4f1a\u88ab\u8d4b\u503c\u7ed9\u4efb\u4f55\u5bf9\u8c61\uff0c\u8fd4\u56de\u7684\u4e34\u65f6\u503c\u5c06\u4f1a\u79bb\u5f00\u4f5c\u7528\u57df\u5e76\u4e14\u88ab\u6e05\u7406\u3002\u5982\u679c\u5b83\u88ab\u8d4b\u503c\uff08\u50cfmain\u4e2d\u5c55\u793a\u7684\u90a3\u6837\uff09\uff0c\u5728C++14\u6216\u8005\u66f4\u65e9\uff0c\u79fb\u52a8\u8bed\u4e49\u5c06\u4f1a\u88ab\u4f7f\u7528\u6765\u4ece\u8fd4\u56de\u503c\u8f6c\u79fb\u8d44\u6e90\u5230\u5373\u5c06\u8d4b\u503c\u7684\u5bf9\u8c61\uff08\u4e0a\u65b9\u4f8b\u5b50\u4e2d\u7684ptr\uff09\uff0c\u5728C++17\u6216\u8005\u66f4\u65b0\uff0c\u8fd4\u56de\u5c06\u4f1a\u88ab\u7701\u7565\uff0c\u8fd9\u4f7f\u5f97\u76f8\u6bd4\u8fd4\u56de\u539f\u6307\u9488\uff0c\u8fd4\u56de\u4e00\u4e2a unique_ptr \u7684\u8d44\u6e90\u66f4\u52a0\u5b89\u5168\u3002 \u603b\u4f53\u6765\u8bb2\uff0c\u4f60\u5e94\u8be5\u4ece\u4e0d\u901a\u8fc7\u6307\u9488\u6216\u5f15\u7528\u8fd4\u56de std::unique_ptr \uff08\u9664\u975e\u4f60\u6709\u7279\u6b8a\u7684\u539f\u56e0\u6765\u8fd9\u6837\u505a\uff09\u3002","title":"\u4ece\u51fd\u6570\u8fd4\u56de std::unique_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#stdunique_ptr_3","text":"\u5982\u679c\u4f60\u60f3\u8981\u51fd\u6570\u6765\u83b7\u5f97\u6307\u9488\u5185\u5bb9\u7684\u6240\u6709\u6743\uff0c\u901a\u8fc7\u503c\u4f20\u4e00\u4e2a std::unique_ptr \u3002\u6ce8\u610f\uff0c\u56e0\u4e3a\u62f7\u8d1d\u8bed\u4e49\u5df2\u7ecf\u88ab\u7981\u7528\uff0c\u4f60\u5c06\u4f1a\u4f7f\u7528 std::move \u6765\u4f20\u503c\u8fdb\u5165\u51fd\u6570\u3002 # include <memory> // for std::unique_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } friend std :: ostream & operator << ( std :: ostream & out , const Resource & res ) { out << \"I am a resource \\n \" ; return out ; } }; void takeOwnership ( std :: unique_ptr < Resource > res ) { if ( res ) std :: cout << * res << '\\n' ; } // the Resource is destroyed here int main () { auto ptr { std :: make_unique < Resource > () }; // takeOwnership(ptr); // This doesn't work, need to use move semantics takeOwnership ( std :: move ( ptr )); // ok: use move semantics std :: cout << \"Ending program \\n \" ; return 0 ; } \u8f93\u51fa\uff1a Resource acquired I am a resource Resource destroyed Ending program \u6ce8\u610f\u5728\u8fd9\u4e2a\u4f8b\u5b50\u91cc\uff0c\u8d44\u6e90\u7684\u6240\u6709\u6743\u88ab\u4f20\u7ed9\u4e86 takeOwnership() \uff0c\u56e0\u6b64\u8d44\u6e90\u5c06\u4f1a\u88ab\u9500\u6bc1\u5728 takeOwnership() \u51fd\u6570\u7ed3\u675f\u65f6\uff0c\u800c\u4e0d\u662f main() \u7136\u800c\uff0c\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u4f60\u4e0d\u60f3\u8ba9\u51fd\u6570\u5f97\u5230\u8d44\u6e90\u7684\u6240\u6709\u6743\u3002\u867d\u7136\u4f60\u53ef\u4ee5\u4f20\u5165\u4e00\u4e2a std::unique_ptr \u7684\u5f15\u7528\uff08\u8fd9\u5141\u8bb8\u51fd\u6570\u4f7f\u7528\u5bf9\u8c61\uff0c\u800c\u4e0d\u5f97\u5230\u6240\u6709\u6743\uff09\uff0c\u4f60\u5e94\u8be5\u4ec5\u4ec5\u5728 \u8c03\u7528\u51fd\u6570\u4f1a\u4fee\u6539\u6216\u8005\u6539\u53d8\u6301\u5176\u7ba1\u7406\u7684\u5bf9\u8c61\u7684\u60c5\u51b5\u4e0b\u4f7f\u7528\u3002 \u76f8\u53cd\uff0c\u66f4\u597d\u7684\u65b9\u5f0f\u662f\u4f20\u5165\u4e00\u4e2a\u8d44\u6e90\u672c\u8eab\uff08\u901a\u8fc7\u6307\u9488\u6216\u8005\u5f15\u7528\uff0c\u6839\u636enull\u662f\u5426\u662f\u4e00\u4e2a\u5408\u6cd5\u7684\u53c2\u6570\uff09\uff0c\u8fd9\u5141\u8bb8\u51fd\u6570\u4fdd\u6301\u8c03\u7528\u8005\u7ba1\u7406\u8d44\u6e90\u3002\u4e3a\u4e86\u4ece\u4e00\u4e2a std::unique_ptr \u5f97\u5230\u539f\u6765\u7684\u8d44\u6e90\u6307\u9488\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528 get() \u6210\u5458\u51fd\u6570\uff1a # include <memory> // for std::unique_ptr # include <iostream> class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } friend std :: ostream & operator << ( std :: ostream & out , const Resource & res ) { out << \"I am a resource \\n \" ; return out ; } }; // The function only uses the resource, so we'll accept a pointer to the resource, not a reference to the whole std::unique_ptr<Resource> void useResource ( Resource * res ) { if ( res ) std :: cout << * res << '\\n' ; } int main () { auto ptr { std :: make_unique < Resource > () }; useResource ( ptr . get ()); // note: get() used here to get a pointer to the Resource std :: cout << \"Ending program \\n \" ; return 0 ; } // The Resource is destroyed here \u8f93\u51fa Resource acquired I am a resource Ending program Resource destroyed","title":"\u5411\u51fd\u6570\u4f20\u5165 std::unique_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#stdunique_ptr_4","text":"\u5f53\u7136\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528 std::unique_ptr \u4f5c\u4e3a\u4f60\u7684\u7c7b\u578b\u4e2d\u7684\u7ec4\u6210\u90e8\u5206\uff0c\u4ee5\u8fd9\u4e2a\u65b9\u5f0f\uff0c\u4f60\u5c06\u4e0d\u7528\u62c5\u5fc3\u786e\u4fdd\u4f60\u7684\u7c7b\u578b\u7684\u6790\u6784\u51fd\u6570\u91ca\u653e\u52a8\u6001\u5185\u5b58\u4e86\uff0c\u56e0\u4e3a std::uniqut_ptr \u5c06\u4f1a\u81ea\u52a8\u7684\u9500\u6bc1\uff0c\u5f53\u7c7b\u578b\u5bf9\u8c61\u88ab\u9500\u6bc1\u65f6\u3002\u7136\u800c\uff0c\u8bb0\u4f4f\u5982\u679c\u4f60\u7684\u7c7b\u578b\u662f\u52a8\u6001\u5206\u914d\u7684\uff0c\u90a3\u4e48\u5bf9\u8c61\u672c\u8eab\u5c31\u6709\u98ce\u9669\u4e0d\u80fd\u88ab\u6b63\u786e\u7684\u91ca\u653e\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u667a\u80fd\u6307\u9488\u4e5f\u4e0d\u80fd\u5e2e\u4f60\u3002","title":"std::unique_ptr \u548c\u7c7b\u578b"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#stdunique_ptr_5","text":"\u8fd9\u6709\u4e24\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff0c\u8bef\u7528 std::unique_ptr \uff0c\u4ed6\u4eec\u90fd\u662f\u975e\u5e38\u5bb9\u6613\u907f\u514d\u7684\u3002 \u9996\u5148\uff0c\u4e0d\u8981\u8ba9\u591a\u4e2a\u6307\u9488\u7ba1\u7406\u540c\u6837\u7684\u8d44\u6e90\uff0c\u4f8b\u5982\uff1a Resource * res { new Resource () }; std :: unique_ptr < Resource > res1 { res }; std :: unique_ptr < Resource > res2 { res }; \u8fd9\u5728\u8bed\u4e49\u4e0a\u662f\u5408\u6cd5\u7684\uff0c\u6700\u540e\u7684\u7ed3\u679c\u5c31\u662f res1 \u548c res2 \u5c1d\u8bd5\u5220\u9664\u8d44\u6e90\uff0c\u4f1a\u5f15\u53d1\u672a\u5b9a\u4e49\u884c\u4e3a\u3002 \u7b2c\u4e8c\uff0c\u4e0d\u8981\u624b\u52a8\u5220\u9664 std::unique_ptr \u7ba1\u7406\u7684\u8d44\u6e90 Resource * res { new Resource () }; std :: unique_ptr < Resource > res1 { res }; delete res ; \u5982\u679c\u4f60\u90a3\u6837\u505a\uff0c std::unique_ptr \u5c06\u4f1a\u5c1d\u8bd5\u5220\u9664\u4e00\u4e2a\u65e9\u5c31\u5220\u9664\u7684\u8d44\u6e90\uff0c\u4e5f\u4f1a\u5f15\u8d77\u672a\u5b9a\u4e49\u884c\u4e3a\u3002 \u6211\u4eec\u6ce8\u610f\u5230\uff0c std::make_unique() \u521a\u597d\u65e0\u610f\u4e2d\u5c31\u907f\u514d\u4e86\u8fd9\u4e24\u79cd\u60c5\u51b5\u7684\u53d1\u751f\u3002","title":"std::unique_ptr \u7684\u8bef\u7528"},{"location":"15-move-semantics-and-smart-pointers/15.6-std%3A%3Ashared_ptr/","text":"15.6 std::shared_ptr \u00b6 By Alex on March 16 th , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.18 \u4e0d\u50cf std::unique_ptr \u90a3\u6837\uff0c\u4ec5\u4ec5\u88ab\u8bbe\u8ba1\u5355\u72ec\u62e5\u6709\u548c\u7ba1\u7406\u4e00\u4efd\u8d44\u6e90\uff0c std::shared_ptr \u662f\u4e3a\u4e86\u89e3\u51b3\u4f60\u9700\u8981\u521b\u5efa\u5f88\u591a\u667a\u80fd\u6307\u9488\u5171\u7528\u4e00\u4e2a\u8d44\u6e90\u7684\u60c5\u51b5\u3002 \u8fd9\u610f\u5473\u7740\uff0c\u540c\u65f6\u8bb8\u591a std::shared_ptr \u6307\u5411\u540c\u4e00\u4efd\u8d44\u6e90\u662fOK\u7684\u3002\u5728\u5185\u90e8\uff0c std::shared_ptr \u4fdd\u6301\u8ddf\u8e2a\u6b63\u5728\u5206\u4eab\u540c\u4e00\u4efd\u8d44\u6e90\u7684 std::shared_ptr \u6570\u91cf\u3002\u5f53\u53ea\u8981\u6709\u4e00\u4e2a std::shared_ptr \u6307\u5411\u8d44\u6e90\uff0c\u8fd9\u4e2a\u8d44\u6e90\u5c31\u4e0d\u4f1a\u88ab\u91ca\u653e\uff0c\u5373\u4f7f\u4e00\u4e9b std::shared_ptr \u88ab\u9500\u6bc1\u3002\u5f53\u6700\u540e\u4e00\u4e2a\u7ba1\u7406\u7740\u8d44\u6e90\u7684 std::shared_ptr \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff08\u6216\u8005\u88ab\u91cd\u65b0\u8d4b\u503c\u6307\u5411\u5176\u4ed6\u8d44\u6e90\uff09\u539f\u6765\u7ba1\u7406\u7684\u8d44\u6e90\u5c31\u4f1a\u88ab\u9500\u6bc1\u3002 \u548c std::unique_ptr \u4e00\u6837\uff0c std_shared_ptr \u5728 \u5934\u90e8\u4e2d\u3002 #include <iostream> #include <memory> // for std::shared_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { // allocate a Resource object and have it owned by std::shared_ptr Resource * res = new Resource ; std :: shared_ptr < Resource > ptr1 ( res ); { std :: shared_ptr < Resource > ptr2 ( ptr1 ); // use copy initialization to make another std::shared_ptr pointing to the same thing std :: cout << \"Killing one shared pointer \\n \" ; } // ptr2 goes out of scope here, but nothing happens std :: cout << \"Killing another shared pointer \\n \" ; return 0 ; } // ptr1 goes out of scope here, and the allocated Resource is destroyed \u8f93\u51fa Resource acquired Killing one shared pointer Killing another shared pointer Resource destroyed \u5728\u4e0a\u65b9\u7684\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u52a8\u6001\u8d44\u6e90\u5bf9\u8c61\uff0c\u5e76\u4e14\u8bbe\u7f6e\u4e86\u4e00\u4e2a\u540d\u5b57\u4e3a ptr1 \u7684 std::shared_ptr \u6765\u7ba1\u7406\u5b83\u3002\u5728\u8fd9\u4e2a\u5d4c\u5957\u7684\u8bed\u53e5\u5757\u4e2d\uff0c\u6211\u4eec\u7528\u62f7\u8d1d\u521d\u59cb\u5316\uff08 \u5728 std::shared_ptr \u4e2d\u5141\u8bb8\u7684\u64cd\u4f5c\uff0c\u56e0\u4e3a\u8d44\u6e90\u53ef\u4ee5\u88ab\u5171\u4eab \uff09\u6765\u521b\u5efa\u7b2c\u4e8c\u4e2a std::shared_ptr (ptr2)\u6307\u5411\u540c\u4e00\u4efd\u8d44\u6e90\u3002\u5f53 ptr1 \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff0c ptr1 \u6ce8\u610f\u5230\u8fd9\u91cc\u5df2\u7ecf\u6ca1\u6709 std::shared_ptr \u7ba1\u7406\u8fd9\u4efd\u8d44\u6e90\u4e86\uff0c\u56e0\u6b64\u6211\u4eec\u91ca\u653e\u8be5\u8d44\u6e90\u3002 \u6ce8\u610f\u6211\u4eec\u521b\u5efa\u4e86\u7b2c\u4e8c\u4e2a\u667a\u80fd\u6307\u9488\u4ece\u7b2c\u4e00\u4e2a\u667a\u80fd\u6307\u9488 \uff08\u4f7f\u7528\u62f7\u8d1d\u521d\u59cb\u5316\uff09 \u3002\u8fd9\u5f88\u91cd\u8981\uff0c\u601d\u8003\u5982\u4e0b\u4ee3\u7801\u3002 #include <iostream> #include <memory> // for std::shared_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { Resource * res = new Resource ; std :: shared_ptr < Resource > ptr1 ( res ); { std :: shared_ptr < Resource > ptr2 ( res ); // create ptr2 directly from res (instead of ptr1) std :: cout << \"Killing one shared pointer \\n \" ; } // ptr2 goes out of scope here, and the allocated Resource is destroyed std :: cout << \"Killing another shared pointer \\n \" ; return 0 ; } // ptr1 goes out of scope here, and the allocated Resource is destroyed again \u8f93\u51fa Resource acquired Killing one shared pointer Resource destroyed Killing another shared pointer Resource destroyed \u7136\u540e\u7d27\u63a5\u7740\u5d29\u6e83\uff08\u81f3\u5c11\u5728\u4f5c\u8005\u7684\u673a\u5668\u4e0a\uff09\u3002 \u8fd9\u91cc\u4e0d\u540c\u7684\u662f\u6211\u4eec\u521b\u5efa\u4e86\u4e24\u4e2a\u76f8\u4e92\u72ec\u7acb\u7684 std::shared_Ptr \u3002\u7ed3\u679c\uff0c\u5373\u4f7f\u4ed6\u4eec\u90fd\u6307\u5411 \u540c\u4e00\u4efd\u8d44\u6e90 \uff0c\u4f46\u662f\u4ed6\u4eec\u90fd\u6ca1\u610f\u8bc6\u5230\u5bf9\u65b9\u7684\u5b58\u5728\u3002\u5f53 ptr2 \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff0c\u4ed6 \u8ba4\u4e3a \u4ed6\u662f\u8d44\u6e90\u552f\u4e00\u7684\u62e5\u6709\u8005\uff0c\u6240\u4ee5\u91ca\u653e\u4e86\u5b83\u3002\u5f53 ptr1 \u4e4b\u540e\u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff0c\u5b83\u601d\u8003\u7684\u7740\u540c\u6837\u7684\u95ee\u9898\uff0c\u5e76\u4e14\u5c1d\u8bd5\u518d\u6b21\u5220\u9664\u5b83\u3002\u7cdf\u7cd5\u7684\u4e8b\u60c5\u53d1\u751f\u4e86\u3002 \u5e78\u8fd0\u7684\u662f\uff0c\u5f53\u4f60\u9700\u8981\u591a\u4e2a\u5171\u4eab\u6307\u9488\u6307\u5411\u540c\u4e00\u4efd\u8d44\u6e90\u65f6\uff0c\u8fd9\u662f\u975e\u5e38\u5bb9\u6613\u4f7f\u7528 \u62f7\u8d1d\u8d4b\u503c \u6216\u8005 \u62f7\u8d1d\u521d\u59cb\u5316 \u6765\u907f\u514d\u7684\u3002 \u89c4\u5b9a\uff1a\u5f53\u4f60\u9700\u8981\u4e0d\u6b62\u4e00\u4e2a std::shared_ptr \u6307\u5411\u540c\u4e00\u4efd\u8d44\u6e90\uff0c\u8bf7\u603b\u662f\u4ece\u5df2\u5b58\u5728\u7684 std::shared_ptr \u521b\u5efa\u62f7\u8d1d\u3002 std::make_shared \u00b6 \u5c31\u50cf\u5728C++14\u4e2d std::make_unique() \u53ef\u4ee5\u88ab\u7528\u6765\u521b\u5efa std::unique_ptr \u4e00\u6837\uff0c std::make_shared() \u53ef\u4ee5\uff08\u5e76\u4e14\u5e94\u8be5\uff09\u88ab\u7528\u6765\u521b\u5efa\u4e00\u4e2a std::shared_ptr \u3002 std::make_shared() \u5728C++11\u4e2d\u5c31\u53ef\u7528\u3002 \u6709\u4e9b\u4f8b\u5b50\uff0c\u4f7f\u7528\u4e86 std::make_shared() : #include <iostream> #include <memory> // for std::shared_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { // allocate a Resource object and have it owned by std::shared_ptr auto ptr1 = std :: make_shared < Resource > (); { auto ptr2 = ptr1 ; // create ptr2 using copy initialization of ptr1 std :: cout << \"Killing one shared pointer \\n \" ; } // ptr2 goes out of scope here, but nothing happens std :: cout << \"Killing another shared pointer \\n \" ; return 0 ; } // ptr1 goes out of scope here, and the allocated Resource is destroyed \u4f7f\u7528 std::make_shared() \u7684\u539f\u56e0\u548c std::make_unique() \u4e00\u6837 \u2014\u2014\u2014\u2014 std::make_shared() \u66f4\u7b80\u5355\u66f4\u5b89\u5168\uff08\u4f7f\u7528\u8fd9\u4e2a\u65b9\u6cd5\u4e0d\u53ef\u80fd\u76f4\u63a5\u521b\u5efa\u4e24\u4e2a\u76f8\u4e92\u72ec\u7acb\u7684 std::shared_ptr \u6307\u5411\u540c\u4e00\u5757\u8d44\u6e90\uff09\uff0c\u800c\u4e14\uff0c\u6bd4\u8d77\u4e0d\u4f7f\u7528\u5b83\uff0c std::make_shared() \u6709\u66f4\u52a0\u9ad8\u6027\u80fd\u3002\u5176\u539f\u56e0\u5728\u4e8e std::shared ptr \u8ddf\u8e2a\u6307\u5411\u7ed9\u5b9a\u8d44\u6e90\u7684\u6307\u9488\u6570\u91cf\u3002 \u6df1\u6316 std::shared_ptr \u00b6 \u4e0d\u50cf\u5185\u90e8\u4ec5\u4ec5\u4f7f\u7528\u4e00\u4e2a\u6307\u9488\u7684 std::unique_ptr \u90a3\u6837\uff0c std::shared_ptr \u5185\u90e8\u6709\u4e24\u4e2a\u6307\u9488\uff1a\u4e00\u4e2a\u6307\u9488\u6307\u5411\u88ab\u7ba1\u7406\u7684\u8d44\u6e90\uff0c\u53e6\u4e00\u4e2a\u6307\u9488\u5728\u201c\u63a7\u5236\u5757\uff08control block\uff09\u201d\uff0c\u662f\u4e00\u4e2a\u52a8\u6001\u5206\u914d\u7684\u5bf9\u8c61\uff0c\u4f1a\u8ddf\u8e2a\u5f88\u591a\u4e1c\u897f\uff0c\u5305\u62ec\u6709\u591a\u5c11\u4e2a std::shared_ptr \u6307\u5411\u8d44\u6e90\u3002 \u5f53\u4e00\u4e2a std::shared_ptr \u88ab\u4f7f\u7528\u6784\u9020\u51fd\u6570\u5355\u72ec\u521b\u5efa\u7684\u65f6\u5019\uff0c\u7ba1\u7406\u5bf9\u8c61\uff08\u4f20\u5165\u7684\u8d44\u6e90\uff09\u548c\u63a7\u5236\u5757\uff08\u6784\u9020\u5668\u521b\u5efa\uff09\u7684\u5185\u5b58\u5c31\u88ab\u5355\u72ec\u5206\u914d\u4e86\u3002\u7136\u800c\uff0c\u5f53\u4f7f\u7528 std::make_shared() \u65f6\uff0c\u8fd9\u53ef\u4ee5\u88ab\u4f18\u5316\u6210\u4e00\u4e2a\u5355\u72ec\u5185\u5b58\u5206\u914d\uff0c\u6709\u66f4\u597d\u7684\u6027\u80fd\u3002 \u8fd9\u4e5f\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48\u5355\u72ec\u521b\u5efa\u4e24\u4e2a std::shared_ptr \u4f1a\u9047\u5230\u95ee\u9898\u3002\u6bcf\u4e2a std::shared_ptr \u5c06\u4f1a\u6709\u4e00\u4e2a\u6307\u9488\u6307\u5411\u8d44\u6e90\uff0c\u7136\u800c\u6bcf\u4e2a std::shared_ptr \u72ec\u7acb\u5206\u914d\u5b83\u81ea\u5df1\u7684\u63a7\u5236\u5757\uff0c\u8fd9\u610f\u5473\u7740\u8fd9\u662f\u6301\u6709\u8d44\u6e90\u7684\u552f\u4e00\u7684\u6307\u9488\u3002\u56e0\u6b64\uff0c\u5f53 std::shared_ptr \u79bb\u5f00\u4f5c\u7528\u57df\u540e\uff0c\u4f1a\u91ca\u653e\u8d44\u6e90\uff0c\u5e76\u6ca1\u6709\u610f\u8bc6\u5230\u8fd8\u6709\u53e6\u4e00\u4e2a std::shared_ptr \u4ecd\u7136\u5728\u7ba1\u7406\u8d44\u6e90\u3002 \u7136\u800c\uff0c\u5f53\u4e00\u4e2a std::shared_ptr \u88ab\u4f7f\u7528\u62f7\u8d1d\u6784\u9020\u590d\u5236\u7684\u65f6\u5019\uff0c\u63a7\u5236\u5757\u4e2d\u7684\u6570\u636e\u540c\u6837\u88ab\u66f4\u65b0\u6210\u5408\u9002\u7684\u503c\uff0c\u8868\u660e\u6709\u53e6\u4e00\u4e2a std::shared_ptr \u5171\u540c\u7ba1\u7406\u8fd9\u4e2a\u8d44\u6e90\u3002 Shared pointers \u53ef\u4ee5\u4ece Unique pointers \u521b\u5efa \u00b6 \u4e00\u4e2a std::unique_ptr \u53ef\u4ee5\u88ab\u8f6c\u5316\u6210\u4e00\u4e2a std::shared_ptr \u901a\u8fc7\u4e00\u4e2a\u7279\u6b8a\u7684\u6784\u9020\u51fd\u6570\u63a5\u6536\u53f3\u503c\u3002 std::unique_ptr \u6301\u6709\u7684\u5185\u5bb9\u5c06\u4f1a\u79fb\u52a8\u7ed9 std::shared_ptr \u3002 \u7136\u800c\uff0c std::shared_ptr \u5374\u4e0d\u80fd\u5b89\u5168\u7684\u8f6c\u5316\u6210 std::unique_ptr \u3002\u8fd9\u610f\u5473\u7740\u5982\u679c\u4f60\u6b63\u5728\u521b\u5efa\u4e00\u4e2a\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u667a\u80fd\u6307\u9488\uff0c\u4f60\u6700\u597d\u8fd4\u56de\u4e00\u4e2a std::unique_ptr \u5e76\u4e14\u8d4b\u503c\u5b83\u7ed9\u4e00\u4e2a std::shared_ptr \u5982\u679c\u5408\u9002\u7684\u8bdd\u3002 \u4f7f\u7528 std::shared_ptr \u7684\u5371\u9669\u4e4b\u5904 \u00b6 std::shared_ptr \u6709\u4e00\u4e9b\u548c std::unique_ptr \u540c\u6837\u7684\u6311\u6218\uff0c\u5982\u679c std::shared_ptr \u6ca1\u6709\u88ab\u5408\u9002\u7684\u5904\u7406\uff08\u53ef\u80fd\u662f\u56e0\u4e3a\u5b83\u88ab\u52a8\u6001\u5206\u914d\u5e76\u4e14\u4ece\u672a\u5220\u9664\uff0c\u6216\u8005\u5b83\u4f5c\u4e3a\u5bf9\u8c61\u7684\u4e00\u90e8\u5206\uff0c\u88ab\u52a8\u6001\u5206\u914d\u5e76\u4ece\u672a\u5220\u9664\uff09\uff0c\u7d27\u63a5\u7740\u5b83\u7ba1\u7406\u7684\u8d44\u6e90\u4e5f\u5c06\u4e0d\u4f1a\u88ab\u91ca\u653e\u3002\u4f7f\u7528 std::unique_ptr \uff0c\u4f60\u4ec5\u9700\u8981\u53bb\u5173\u6ce8\u667a\u80fd\u6307\u9488\u662f\u5426\u88ab\u5408\u9002\u7684\u5904\u7406\u3002\u5982\u679c\u4f7f\u7528 std::shared_ptr \uff0c\u4f60\u4e0d\u5f97\u4e0d\u62c5\u5fc3\u4ed6\u4eec\u5168\u90e8\u3002\u5982\u679c\u4efb\u4f55\u4e00\u4e2a std::shared_ptr \u7ba1\u7406\u8d44\u6e90\u6ca1\u6709\u88ab\u5408\u9002\u7684\u6e05\u7406\uff0c\u8d44\u6e90\u5c06\u4e0d\u4f1a\u88ab\u91ca\u653e\u3002 std::shared_ptr \u548c\u6570\u7ec4 \u00b6 \u5728 C++14 \u6216\u66f4\u65e9\uff0c std::shared_ptr \u6ca1\u529e\u6cd5\u652f\u6301\u7ba1\u7406\u6570\u7ec4\uff0c\u5e76\u4e14\u4e0d\u5e94\u8be5\u4f7f\u7528C\u7c7b\u578b\u6570\u7ec4\u3002\u5728C++17\u4e2d\uff0c std::shared_ptr \u5df2\u7ecf\u652f\u6301\u6570\u7ec4\u4e86\u3002\u7136\u800c\uff0c\u5728C++17\u4e2d\uff0c std::make_shared \u4ecd\u7136\u7f3a\u4e4f\u5408\u9002\u7684\u9488\u5bf9\u6570\u7ec4\u7684\u652f\u6301\uff0c\u5e76\u4e14\u4e0d\u5e94\u8be5\u88ab\u7528\u6765\u521b\u5efa\u6570\u7ec4\uff0c\u8fd9\u4f1a\u5728C++20\u4e2d\u88ab\u89e3\u51b3\u3002 \u7ed3\u8bba \u00b6 std::shared_ptr \u88ab\u8bbe\u8ba1\u7528\u4e8e\u4f60\u9700\u8981\u591a\u4e2a\u667a\u80fd\u6307\u9488\u5171\u540c\u7ba1\u7406\u540c\u6837\u7684\u8d44\u6e90\u3002\u8d44\u6e90\u8b66\u5fbd\u88ab\u91ca\u653e\uff0c\u5f53\u6700\u540e\u4e00\u4e2a std::shared_ptr \u7ba1\u7406\u7684\u8d44\u6e90\u88ab\u9500\u6bc1\u65f6\u3002","title":"15.6 std::shared_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.6-std%3A%3Ashared_ptr/#156-stdshared_ptr","text":"By Alex on March 16 th , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.18 \u4e0d\u50cf std::unique_ptr \u90a3\u6837\uff0c\u4ec5\u4ec5\u88ab\u8bbe\u8ba1\u5355\u72ec\u62e5\u6709\u548c\u7ba1\u7406\u4e00\u4efd\u8d44\u6e90\uff0c std::shared_ptr \u662f\u4e3a\u4e86\u89e3\u51b3\u4f60\u9700\u8981\u521b\u5efa\u5f88\u591a\u667a\u80fd\u6307\u9488\u5171\u7528\u4e00\u4e2a\u8d44\u6e90\u7684\u60c5\u51b5\u3002 \u8fd9\u610f\u5473\u7740\uff0c\u540c\u65f6\u8bb8\u591a std::shared_ptr \u6307\u5411\u540c\u4e00\u4efd\u8d44\u6e90\u662fOK\u7684\u3002\u5728\u5185\u90e8\uff0c std::shared_ptr \u4fdd\u6301\u8ddf\u8e2a\u6b63\u5728\u5206\u4eab\u540c\u4e00\u4efd\u8d44\u6e90\u7684 std::shared_ptr \u6570\u91cf\u3002\u5f53\u53ea\u8981\u6709\u4e00\u4e2a std::shared_ptr \u6307\u5411\u8d44\u6e90\uff0c\u8fd9\u4e2a\u8d44\u6e90\u5c31\u4e0d\u4f1a\u88ab\u91ca\u653e\uff0c\u5373\u4f7f\u4e00\u4e9b std::shared_ptr \u88ab\u9500\u6bc1\u3002\u5f53\u6700\u540e\u4e00\u4e2a\u7ba1\u7406\u7740\u8d44\u6e90\u7684 std::shared_ptr \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff08\u6216\u8005\u88ab\u91cd\u65b0\u8d4b\u503c\u6307\u5411\u5176\u4ed6\u8d44\u6e90\uff09\u539f\u6765\u7ba1\u7406\u7684\u8d44\u6e90\u5c31\u4f1a\u88ab\u9500\u6bc1\u3002 \u548c std::unique_ptr \u4e00\u6837\uff0c std_shared_ptr \u5728 \u5934\u90e8\u4e2d\u3002 #include <iostream> #include <memory> // for std::shared_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { // allocate a Resource object and have it owned by std::shared_ptr Resource * res = new Resource ; std :: shared_ptr < Resource > ptr1 ( res ); { std :: shared_ptr < Resource > ptr2 ( ptr1 ); // use copy initialization to make another std::shared_ptr pointing to the same thing std :: cout << \"Killing one shared pointer \\n \" ; } // ptr2 goes out of scope here, but nothing happens std :: cout << \"Killing another shared pointer \\n \" ; return 0 ; } // ptr1 goes out of scope here, and the allocated Resource is destroyed \u8f93\u51fa Resource acquired Killing one shared pointer Killing another shared pointer Resource destroyed \u5728\u4e0a\u65b9\u7684\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u52a8\u6001\u8d44\u6e90\u5bf9\u8c61\uff0c\u5e76\u4e14\u8bbe\u7f6e\u4e86\u4e00\u4e2a\u540d\u5b57\u4e3a ptr1 \u7684 std::shared_ptr \u6765\u7ba1\u7406\u5b83\u3002\u5728\u8fd9\u4e2a\u5d4c\u5957\u7684\u8bed\u53e5\u5757\u4e2d\uff0c\u6211\u4eec\u7528\u62f7\u8d1d\u521d\u59cb\u5316\uff08 \u5728 std::shared_ptr \u4e2d\u5141\u8bb8\u7684\u64cd\u4f5c\uff0c\u56e0\u4e3a\u8d44\u6e90\u53ef\u4ee5\u88ab\u5171\u4eab \uff09\u6765\u521b\u5efa\u7b2c\u4e8c\u4e2a std::shared_ptr (ptr2)\u6307\u5411\u540c\u4e00\u4efd\u8d44\u6e90\u3002\u5f53 ptr1 \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff0c ptr1 \u6ce8\u610f\u5230\u8fd9\u91cc\u5df2\u7ecf\u6ca1\u6709 std::shared_ptr \u7ba1\u7406\u8fd9\u4efd\u8d44\u6e90\u4e86\uff0c\u56e0\u6b64\u6211\u4eec\u91ca\u653e\u8be5\u8d44\u6e90\u3002 \u6ce8\u610f\u6211\u4eec\u521b\u5efa\u4e86\u7b2c\u4e8c\u4e2a\u667a\u80fd\u6307\u9488\u4ece\u7b2c\u4e00\u4e2a\u667a\u80fd\u6307\u9488 \uff08\u4f7f\u7528\u62f7\u8d1d\u521d\u59cb\u5316\uff09 \u3002\u8fd9\u5f88\u91cd\u8981\uff0c\u601d\u8003\u5982\u4e0b\u4ee3\u7801\u3002 #include <iostream> #include <memory> // for std::shared_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { Resource * res = new Resource ; std :: shared_ptr < Resource > ptr1 ( res ); { std :: shared_ptr < Resource > ptr2 ( res ); // create ptr2 directly from res (instead of ptr1) std :: cout << \"Killing one shared pointer \\n \" ; } // ptr2 goes out of scope here, and the allocated Resource is destroyed std :: cout << \"Killing another shared pointer \\n \" ; return 0 ; } // ptr1 goes out of scope here, and the allocated Resource is destroyed again \u8f93\u51fa Resource acquired Killing one shared pointer Resource destroyed Killing another shared pointer Resource destroyed \u7136\u540e\u7d27\u63a5\u7740\u5d29\u6e83\uff08\u81f3\u5c11\u5728\u4f5c\u8005\u7684\u673a\u5668\u4e0a\uff09\u3002 \u8fd9\u91cc\u4e0d\u540c\u7684\u662f\u6211\u4eec\u521b\u5efa\u4e86\u4e24\u4e2a\u76f8\u4e92\u72ec\u7acb\u7684 std::shared_Ptr \u3002\u7ed3\u679c\uff0c\u5373\u4f7f\u4ed6\u4eec\u90fd\u6307\u5411 \u540c\u4e00\u4efd\u8d44\u6e90 \uff0c\u4f46\u662f\u4ed6\u4eec\u90fd\u6ca1\u610f\u8bc6\u5230\u5bf9\u65b9\u7684\u5b58\u5728\u3002\u5f53 ptr2 \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff0c\u4ed6 \u8ba4\u4e3a \u4ed6\u662f\u8d44\u6e90\u552f\u4e00\u7684\u62e5\u6709\u8005\uff0c\u6240\u4ee5\u91ca\u653e\u4e86\u5b83\u3002\u5f53 ptr1 \u4e4b\u540e\u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff0c\u5b83\u601d\u8003\u7684\u7740\u540c\u6837\u7684\u95ee\u9898\uff0c\u5e76\u4e14\u5c1d\u8bd5\u518d\u6b21\u5220\u9664\u5b83\u3002\u7cdf\u7cd5\u7684\u4e8b\u60c5\u53d1\u751f\u4e86\u3002 \u5e78\u8fd0\u7684\u662f\uff0c\u5f53\u4f60\u9700\u8981\u591a\u4e2a\u5171\u4eab\u6307\u9488\u6307\u5411\u540c\u4e00\u4efd\u8d44\u6e90\u65f6\uff0c\u8fd9\u662f\u975e\u5e38\u5bb9\u6613\u4f7f\u7528 \u62f7\u8d1d\u8d4b\u503c \u6216\u8005 \u62f7\u8d1d\u521d\u59cb\u5316 \u6765\u907f\u514d\u7684\u3002 \u89c4\u5b9a\uff1a\u5f53\u4f60\u9700\u8981\u4e0d\u6b62\u4e00\u4e2a std::shared_ptr \u6307\u5411\u540c\u4e00\u4efd\u8d44\u6e90\uff0c\u8bf7\u603b\u662f\u4ece\u5df2\u5b58\u5728\u7684 std::shared_ptr \u521b\u5efa\u62f7\u8d1d\u3002","title":"15.6 std::shared_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.6-std%3A%3Ashared_ptr/#stdmake_shared","text":"\u5c31\u50cf\u5728C++14\u4e2d std::make_unique() \u53ef\u4ee5\u88ab\u7528\u6765\u521b\u5efa std::unique_ptr \u4e00\u6837\uff0c std::make_shared() \u53ef\u4ee5\uff08\u5e76\u4e14\u5e94\u8be5\uff09\u88ab\u7528\u6765\u521b\u5efa\u4e00\u4e2a std::shared_ptr \u3002 std::make_shared() \u5728C++11\u4e2d\u5c31\u53ef\u7528\u3002 \u6709\u4e9b\u4f8b\u5b50\uff0c\u4f7f\u7528\u4e86 std::make_shared() : #include <iostream> #include <memory> // for std::shared_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { // allocate a Resource object and have it owned by std::shared_ptr auto ptr1 = std :: make_shared < Resource > (); { auto ptr2 = ptr1 ; // create ptr2 using copy initialization of ptr1 std :: cout << \"Killing one shared pointer \\n \" ; } // ptr2 goes out of scope here, but nothing happens std :: cout << \"Killing another shared pointer \\n \" ; return 0 ; } // ptr1 goes out of scope here, and the allocated Resource is destroyed \u4f7f\u7528 std::make_shared() \u7684\u539f\u56e0\u548c std::make_unique() \u4e00\u6837 \u2014\u2014\u2014\u2014 std::make_shared() \u66f4\u7b80\u5355\u66f4\u5b89\u5168\uff08\u4f7f\u7528\u8fd9\u4e2a\u65b9\u6cd5\u4e0d\u53ef\u80fd\u76f4\u63a5\u521b\u5efa\u4e24\u4e2a\u76f8\u4e92\u72ec\u7acb\u7684 std::shared_ptr \u6307\u5411\u540c\u4e00\u5757\u8d44\u6e90\uff09\uff0c\u800c\u4e14\uff0c\u6bd4\u8d77\u4e0d\u4f7f\u7528\u5b83\uff0c std::make_shared() \u6709\u66f4\u52a0\u9ad8\u6027\u80fd\u3002\u5176\u539f\u56e0\u5728\u4e8e std::shared ptr \u8ddf\u8e2a\u6307\u5411\u7ed9\u5b9a\u8d44\u6e90\u7684\u6307\u9488\u6570\u91cf\u3002","title":"std::make_shared"},{"location":"15-move-semantics-and-smart-pointers/15.6-std%3A%3Ashared_ptr/#stdshared_ptr","text":"\u4e0d\u50cf\u5185\u90e8\u4ec5\u4ec5\u4f7f\u7528\u4e00\u4e2a\u6307\u9488\u7684 std::unique_ptr \u90a3\u6837\uff0c std::shared_ptr \u5185\u90e8\u6709\u4e24\u4e2a\u6307\u9488\uff1a\u4e00\u4e2a\u6307\u9488\u6307\u5411\u88ab\u7ba1\u7406\u7684\u8d44\u6e90\uff0c\u53e6\u4e00\u4e2a\u6307\u9488\u5728\u201c\u63a7\u5236\u5757\uff08control block\uff09\u201d\uff0c\u662f\u4e00\u4e2a\u52a8\u6001\u5206\u914d\u7684\u5bf9\u8c61\uff0c\u4f1a\u8ddf\u8e2a\u5f88\u591a\u4e1c\u897f\uff0c\u5305\u62ec\u6709\u591a\u5c11\u4e2a std::shared_ptr \u6307\u5411\u8d44\u6e90\u3002 \u5f53\u4e00\u4e2a std::shared_ptr \u88ab\u4f7f\u7528\u6784\u9020\u51fd\u6570\u5355\u72ec\u521b\u5efa\u7684\u65f6\u5019\uff0c\u7ba1\u7406\u5bf9\u8c61\uff08\u4f20\u5165\u7684\u8d44\u6e90\uff09\u548c\u63a7\u5236\u5757\uff08\u6784\u9020\u5668\u521b\u5efa\uff09\u7684\u5185\u5b58\u5c31\u88ab\u5355\u72ec\u5206\u914d\u4e86\u3002\u7136\u800c\uff0c\u5f53\u4f7f\u7528 std::make_shared() \u65f6\uff0c\u8fd9\u53ef\u4ee5\u88ab\u4f18\u5316\u6210\u4e00\u4e2a\u5355\u72ec\u5185\u5b58\u5206\u914d\uff0c\u6709\u66f4\u597d\u7684\u6027\u80fd\u3002 \u8fd9\u4e5f\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48\u5355\u72ec\u521b\u5efa\u4e24\u4e2a std::shared_ptr \u4f1a\u9047\u5230\u95ee\u9898\u3002\u6bcf\u4e2a std::shared_ptr \u5c06\u4f1a\u6709\u4e00\u4e2a\u6307\u9488\u6307\u5411\u8d44\u6e90\uff0c\u7136\u800c\u6bcf\u4e2a std::shared_ptr \u72ec\u7acb\u5206\u914d\u5b83\u81ea\u5df1\u7684\u63a7\u5236\u5757\uff0c\u8fd9\u610f\u5473\u7740\u8fd9\u662f\u6301\u6709\u8d44\u6e90\u7684\u552f\u4e00\u7684\u6307\u9488\u3002\u56e0\u6b64\uff0c\u5f53 std::shared_ptr \u79bb\u5f00\u4f5c\u7528\u57df\u540e\uff0c\u4f1a\u91ca\u653e\u8d44\u6e90\uff0c\u5e76\u6ca1\u6709\u610f\u8bc6\u5230\u8fd8\u6709\u53e6\u4e00\u4e2a std::shared_ptr \u4ecd\u7136\u5728\u7ba1\u7406\u8d44\u6e90\u3002 \u7136\u800c\uff0c\u5f53\u4e00\u4e2a std::shared_ptr \u88ab\u4f7f\u7528\u62f7\u8d1d\u6784\u9020\u590d\u5236\u7684\u65f6\u5019\uff0c\u63a7\u5236\u5757\u4e2d\u7684\u6570\u636e\u540c\u6837\u88ab\u66f4\u65b0\u6210\u5408\u9002\u7684\u503c\uff0c\u8868\u660e\u6709\u53e6\u4e00\u4e2a std::shared_ptr \u5171\u540c\u7ba1\u7406\u8fd9\u4e2a\u8d44\u6e90\u3002","title":"\u6df1\u6316 std::shared_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.6-std%3A%3Ashared_ptr/#shared-pointers-unique-pointers","text":"\u4e00\u4e2a std::unique_ptr \u53ef\u4ee5\u88ab\u8f6c\u5316\u6210\u4e00\u4e2a std::shared_ptr \u901a\u8fc7\u4e00\u4e2a\u7279\u6b8a\u7684\u6784\u9020\u51fd\u6570\u63a5\u6536\u53f3\u503c\u3002 std::unique_ptr \u6301\u6709\u7684\u5185\u5bb9\u5c06\u4f1a\u79fb\u52a8\u7ed9 std::shared_ptr \u3002 \u7136\u800c\uff0c std::shared_ptr \u5374\u4e0d\u80fd\u5b89\u5168\u7684\u8f6c\u5316\u6210 std::unique_ptr \u3002\u8fd9\u610f\u5473\u7740\u5982\u679c\u4f60\u6b63\u5728\u521b\u5efa\u4e00\u4e2a\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u667a\u80fd\u6307\u9488\uff0c\u4f60\u6700\u597d\u8fd4\u56de\u4e00\u4e2a std::unique_ptr \u5e76\u4e14\u8d4b\u503c\u5b83\u7ed9\u4e00\u4e2a std::shared_ptr \u5982\u679c\u5408\u9002\u7684\u8bdd\u3002","title":"Shared pointers \u53ef\u4ee5\u4ece Unique pointers \u521b\u5efa"},{"location":"15-move-semantics-and-smart-pointers/15.6-std%3A%3Ashared_ptr/#stdshared_ptr_1","text":"std::shared_ptr \u6709\u4e00\u4e9b\u548c std::unique_ptr \u540c\u6837\u7684\u6311\u6218\uff0c\u5982\u679c std::shared_ptr \u6ca1\u6709\u88ab\u5408\u9002\u7684\u5904\u7406\uff08\u53ef\u80fd\u662f\u56e0\u4e3a\u5b83\u88ab\u52a8\u6001\u5206\u914d\u5e76\u4e14\u4ece\u672a\u5220\u9664\uff0c\u6216\u8005\u5b83\u4f5c\u4e3a\u5bf9\u8c61\u7684\u4e00\u90e8\u5206\uff0c\u88ab\u52a8\u6001\u5206\u914d\u5e76\u4ece\u672a\u5220\u9664\uff09\uff0c\u7d27\u63a5\u7740\u5b83\u7ba1\u7406\u7684\u8d44\u6e90\u4e5f\u5c06\u4e0d\u4f1a\u88ab\u91ca\u653e\u3002\u4f7f\u7528 std::unique_ptr \uff0c\u4f60\u4ec5\u9700\u8981\u53bb\u5173\u6ce8\u667a\u80fd\u6307\u9488\u662f\u5426\u88ab\u5408\u9002\u7684\u5904\u7406\u3002\u5982\u679c\u4f7f\u7528 std::shared_ptr \uff0c\u4f60\u4e0d\u5f97\u4e0d\u62c5\u5fc3\u4ed6\u4eec\u5168\u90e8\u3002\u5982\u679c\u4efb\u4f55\u4e00\u4e2a std::shared_ptr \u7ba1\u7406\u8d44\u6e90\u6ca1\u6709\u88ab\u5408\u9002\u7684\u6e05\u7406\uff0c\u8d44\u6e90\u5c06\u4e0d\u4f1a\u88ab\u91ca\u653e\u3002","title":"\u4f7f\u7528 std::shared_ptr \u7684\u5371\u9669\u4e4b\u5904"},{"location":"15-move-semantics-and-smart-pointers/15.6-std%3A%3Ashared_ptr/#stdshared_ptr_2","text":"\u5728 C++14 \u6216\u66f4\u65e9\uff0c std::shared_ptr \u6ca1\u529e\u6cd5\u652f\u6301\u7ba1\u7406\u6570\u7ec4\uff0c\u5e76\u4e14\u4e0d\u5e94\u8be5\u4f7f\u7528C\u7c7b\u578b\u6570\u7ec4\u3002\u5728C++17\u4e2d\uff0c std::shared_ptr \u5df2\u7ecf\u652f\u6301\u6570\u7ec4\u4e86\u3002\u7136\u800c\uff0c\u5728C++17\u4e2d\uff0c std::make_shared \u4ecd\u7136\u7f3a\u4e4f\u5408\u9002\u7684\u9488\u5bf9\u6570\u7ec4\u7684\u652f\u6301\uff0c\u5e76\u4e14\u4e0d\u5e94\u8be5\u88ab\u7528\u6765\u521b\u5efa\u6570\u7ec4\uff0c\u8fd9\u4f1a\u5728C++20\u4e2d\u88ab\u89e3\u51b3\u3002","title":"std::shared_ptr \u548c\u6570\u7ec4"},{"location":"15-move-semantics-and-smart-pointers/15.6-std%3A%3Ashared_ptr/#_1","text":"std::shared_ptr \u88ab\u8bbe\u8ba1\u7528\u4e8e\u4f60\u9700\u8981\u591a\u4e2a\u667a\u80fd\u6307\u9488\u5171\u540c\u7ba1\u7406\u540c\u6837\u7684\u8d44\u6e90\u3002\u8d44\u6e90\u8b66\u5fbd\u88ab\u91ca\u653e\uff0c\u5f53\u6700\u540e\u4e00\u4e2a std::shared_ptr \u7ba1\u7406\u7684\u8d44\u6e90\u88ab\u9500\u6bc1\u65f6\u3002","title":"\u7ed3\u8bba"},{"location":"15-move-semantics-and-smart-pointers/15.7-std%3A%3Aweak_ptr/","text":"15.7 std::shared_ptr \u7684\u5faa\u73af\u4f9d\u8d56\u95ee\u9898\uff0c\u4ecb\u7ecd std::weak_ptr \u00b6 By Alex on March 21 st , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.18 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u770b\u5230\u4e86 std::shared_ptr \u5982\u4f55\u5141\u8bb8\u6211\u4eec\u6709\u591a\u4e2a\u804c\u80fd\u6307\u6b63\u5171\u540c\u62e5\u6709\u540c\u6837\u7684\u8d44\u6e90\uff0c\u7136\u800c\uff0c\u5728\u5177\u4f53\u7684\u60c5\u51b5\u4e0b\uff0c\u8fd9\u53ef\u80fd\u5e26\u6765\u5f88\u591a\u95ee\u9898\uff0c\u601d\u8003\u5982\u4e0b\u4f8b\u5b50\uff0c\u8fd9\u65f6\u5019\u4e24\u4e2a\u5bf9\u8c61\u4e2d\u7684\u667a\u80fd\u6307\u9488\u5206\u522b\u6307\u5411\u4e86\u5176\u4ed6\u5bf9\u8c61\u3002 #include <iostream> #include <memory> // for std::shared_ptr #include <string> class Person { std :: string m_name ; std :: shared_ptr < Person > m_partner ; // initially created empty public : Person ( const std :: string & name ) : m_name ( name ) { std :: cout << m_name << \" created \\n \" ; } ~ Person () { std :: cout << m_name << \" destroyed \\n \" ; } friend bool partnerUp ( std :: shared_ptr < Person > & p1 , std :: shared_ptr < Person > & p2 ) { if ( ! p1 || ! p2 ) return false ; p1 -> m_partner = p2 ; p2 -> m_partner = p1 ; std :: cout << p1 -> m_name << \" is now partnered with \" << p2 -> m_name << \" \\n \" ; return true ; } }; int main () { auto lucy = std :: make_shared < Person > ( \"Lucy\" ); // create a Person named \"Lucy\" auto ricky = std :: make_shared < Person > ( \"Ricky\" ); // create a Person named \"Ricky\" partnerUp ( lucy , ricky ); // Make \"Lucy\" point to \"Ricky\" and vice-versa return 0 ; } \u5728\u4e0a\u4e2a\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528 make_shared() \u52a8\u6001\u5206\u914d\u4e86\u4e24\u4e2a Persons ,\u201cLucy\u201d \u548c \u201cRicky\u201d\uff08\u6765\u4fdd\u8bc1\u4ed6\u4eec\u5728 main()\u7ed3\u675f\u524d\u88ab\u9500\u6bc1 \uff09\u3002\u7d27\u63a5\u7740\uff0c\u6211\u4eec\u8ba9\u4ed6\u4eec\u6210\u4e3a\u642d\u6863\u3002\u8fd9\u4e2a\u64cd\u4f5c\u8bbe\u7f6e \"Lucy\" \u7684 std::shared_ptr \u6307\u5411 \u201cRicky\u201d\uff0c\u5e76\u4e14\u4f7f\u5f97 \u201cRicky\u201d \u5185\u7684 std::shared_ptr \u6307\u5411 \u201cLucy\u201d\u3002\u5171\u4eab\u6307\u9488\u88ab\u8bbe\u8ba1\u7528\u6765\u5171\u4eab\u7684\uff0c\u56e0\u6b64\u8fd9\u6837\u5f88\u68d2\uff0c\u5206\u522b\u8bbe\u7f6e\u4e24\u4e2a Persion \u4e3a\u5bf9\u65b9\u7684\u642d\u6863\u3002 \u7136\u800c\u6267\u884c\u8d77\u6765\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u6ca1\u6709\u6309\u7167\u671f\u671b\u6267\u884c\uff1a Lucy created Ricky created Lucy is now partnered with Ricky \u55ef\uff0c\u4f7f\u5f97\u3002\u6ca1\u6709\u9500\u6bc1\u53d1\u751f\uff0c\u53d1\u751f\u4e86\u4ec0\u4e48\uff1f \u5728 partnerUp() \u88ab\u8c03\u7528\u540e\uff0c\u6709\u4e24\u4e2a\u53ea\u80fd\u6307\u9488\u6307\u5411\u4e86 \u201cRicky\u201d\uff0c\u4e24\u4e2a\u667a\u80fd\u6307\u9488\u6307\u5411\u4e86 \u201cLucy\u201d\u3002 \u5728\u51fd\u6570\u7684\u7ed3\u5c3e\uff0c\u201cricky\u201d \u7684\u5171\u4eab\u6307\u9488\u5148\u79bb\u5f00\u4f5c\u7528\u4e8e\u3002\u5f53\u90a3\u53d1\u751f\u65f6\uff0c\u201cricky\u201d \u68c0\u67e5\u662f\u5426\u6709\u4efb\u4f55\u5176\u4ed6\u7684\u5171\u4eab\u6307\u9488\u5171\u7528\u62e5\u6709 \u201cRicky\u201d\u3002\u786e\u5b9e\u6709\uff08\u201clucy\u2018s m_partner\u201d\uff09\u3002\u56e0\u4e3a\u8fd9\uff0c\u5b83\u6ca1\u6709\u91ca\u653e\u201cRicky\u201d\uff08\u5982\u679c\u5b83\u91ca\u653e\u4e86\uff0c\u90a3\u4e48 \u201cLucy\u201d \u7684 m_partner \u5c31\u4f1a\u53d8\u6210\u60ac\u7a7a\u6307\u9488\uff09\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u73b0\u5728\u6709\u4e00\u4e2a\u53ea\u80fd\u6307\u9488\u6307\u5411 \u201cRicky\u201d\uff08\u201cLucy\u201d \u7684 m_partner\uff09\u548c\u4e24\u4e2a\u53ea\u80fd\u6307\u9488\u6307\u5411 \u201cLucy\u201d\uff08\u53d8\u91cf lucy \u548c \u201cRicky\u201d \u7684 m_partner\uff09\u3002 \u7d27\u63a5\u7740 lucy \u7684\u5171\u4eab\u6307\u9488\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5e76\u4e14\u540c\u6837\u7684\u4e8b\u60c5\u53d1\u751f\u4e86\uff0c\u667a\u80fd\u6307\u9488 lucy \u68c0\u67e5\u662f\u5426\u6709\u5176\u4ed6\u667a\u80fd\u6307\u6b63\u5171\u540c\u62e5\u6709 \u201cLucy\u201d\uff0c\u786e\u5b9e\u5b58\u5728\uff08\u201cRicky\u201d \u7684 m_partner\uff09\uff0c\u56e0\u6b64 \u201cLucy\u201d \u4e0d\u4f1a\u88ab\u91ca\u653e\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6709\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u6307\u5411 \u201cLucy\u201d\uff08\u201cRicky\u201d \u7684 m_partner\uff09\uff0c\u548c\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u6307\u5411 \u201cRicky\u201d\uff08\u201cLucy\u201d \u7684 m_partner\uff09\u3002 \u7d27\u63a5\u7740\uff0c\u7a0b\u5e8f\u7ed3\u675f \u2014\u2014\u2014\u2014 \u201cLucy\u201d \u6216 \u201cRicky\u201d \u90fd\u6ca1\u6709\u88ab\u91ca\u653e\uff01\u672c\u8d28\u4e0a \u201cLucy\u201d \u6700\u540e\u4fdd\u8bc1\u4e86 \u201cRicky\u201d \u4e0d\u88ab\u9500\u6bc1\uff0c\u800c\u4e14 \u201cRicky\u201d \u6700\u540e\u4fdd\u8bc1\u4e86 \u201cLucy\u201d \u4e0d\u88ab\u9500\u6bc1\u3002 It turns out that this can happen any time shared pointers form a circular reference. \u8fd9\u4f1a\u53d1\u751f\u5728\u4efb\u4f55\u65f6\u5019\uff0c\u53ea\u8981\u667a\u80fd\u6307\u9488\u51fa\u73b0\u5faa\u73af\u5f15\u7528\u3002 \u5faa\u73af\u4f9d\u8d56 \u00b6 \u5faa\u73af\u4f9d\u8d56\uff08\u4e5f\u53eb cyclical reference)\u662f\u4e00\u7cfb\u5217\u5f15\u7528\u4e2d\uff0c\u6bcf\u4e00\u4e2a\u5bf9\u8c61\u5f15\u7528\u4e86\u4e0b\u4e00\u4e2a\uff0c\u800c\u6700\u540e\u4e00\u4e2a\u5bf9\u8c61\u5f15\u7528\u4e86\u7b2c\u4e00\u4e2a\uff0c\u9020\u6210\u5faa\u73af\u3002\u8fd9\u4e2a\u5f15\u7528\u4e0d\u9700\u8981\u662f\u786e\u5207\u7684 C++ \u5f15\u7528 \u2014\u2014\u2014\u2014 \u5b83\u53ef\u4ee5\u662f\u6307\u9488\uff0c\u552f\u4e00\u7684ID\uff0c\u6216\u8005\u4efb\u4f55\u7279\u6b8a\u5bf9\u8c61\u3002 \u5728\u667a\u80fd\u6307\u9488\uff08shared pointers\uff09\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5faa\u73af\u5f15\u7528\u5c31\u4f1a\u6307\u9488\u5f15\u8d77\u7684\u3002 \u8fd9\u6b63\u597d\u53d1\u751f\u5728\u4ee5\u4e0a\u7684\u60c5\u51b5\u4e0b\uff1a\u201cLucy\u201d \u6307\u5411\u4e86 \u201cRicky\u201d\uff0c\u7136\u540e \u201cRicky\u201d \u6307\u5411\u4e86 \u201cLucy\u201d\u3002\u5982\u679c\u6709\u4e09\u4e2a\u6307\u9488\uff0c\u4f60\u4f1a\u5f97\u5230\u76f8\u4f3c\u7684\u7ed3\u679c\u5c31\u662f A\u6307\u5411B\uff0cB\u6307\u5411C\uff0cC\u6307\u5411A\u3002\u5728\u73af\u4e2d\uff0c\u667a\u80fd\u6307\u9488\u7684\u6548\u679c\u4f9d\u7136\u662f\u4fdd\u8bc1\u4e0b\u4e00\u4e2a\u5bf9\u8c61\u7684\u5b58\u6d3b \u2014\u2014\u2014\u2014 \u6700\u540e\u4e00\u4e2a\u5bf9\u8c61\u4fdd\u8bc1\u4e86\u7b2c\u4e00\u4e2a\u5bf9\u8c61\u7684\u5b58\u6d3b\uff0c\u56e0\u6b64\uff0c\u6ca1\u6709\u5bf9\u8c61\u4f1a\u88ab\u91ca\u653e\uff0c\u56e0\u4e3a\u4ed6\u4eec\u90fd\u4efb\u4e3a\u5176\u4ed6\u5bf9\u8c61\u4ecd\u7136\u9700\u8981\u5b83\uff01 \u4e00\u4e2a reductive \u7684\u60c5\u51b5 \u00b6 \u4e8b\u5b9e\u8bc1\u660e\uff0c\u5faa\u73af\u5f15\u7528\u7684\u95ee\u9898\u751a\u81f3\u5728\u53ea\u6709\u4e00\u4e2a std::shared_ptr \u7684\u60c5\u51b5\u4e0b\u6210\u7acb\u3002 \u2014\u2014\u2014\u2014 \u4e00\u4e2a std::shared_ptr \u5f15\u7528\u7684\u5bf9\u8c61\u5305\u542b\u4e86\u4e00\u4e2a\u5faa\u73af\u3002\u5c3d\u7ba1\u8fd9\u5728\u5b9e\u9645\u60c5\u51b5\u4e0b\u5f88\u4e0d\u5e38\u89c1\uff0c\u6211\u4eec\u5c06\u4f1a\u5c55\u793a\u7ed9\u4f60\uff0c\u4e3a\u4e86\u8fdb\u4e00\u6b65\u7406\u89e3\uff1a #include <iostream> #include <memory> // for std::shared_ptr class Resource { public : std :: shared_ptr < Resource > m_ptr ; // initially created empty Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { auto ptr1 = std :: make_shared < Resource > (); ptr1 -> m_ptr = ptr1 ; // m_ptr is now sharing the Resource that contains it return 0 ; } \u5728\u4e0a\u65b9\u7684\u4f8b\u5b50\u4e2d\uff0c\u5f53 ptr1 \u79bb\u5f00\u4f5c\u7528\u4e8e\u65f6\uff0c\u4ed6\u4e0d\u4f1a\u91ca\u653e Resource \u56e0\u4e3a Rresource \u7684 m_ptr \u6b63\u5728\u5171\u4eab Resource\u3002\u7d27\u63a5\u7740\u6ca1\u6709\u8c01\u4f1a\u88ab\u5220\u9664 \uff08 m_ptr \u4ece\u672a\u79bb\u5f00\u4f5c\u7528\u4e8e\uff0c\u6240\u4ee5\u5b83\u6ca1\u6709\u673a\u4f1a\u88ab\u5220\u9664\uff09\u3002\u56e0\u6b64\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u8f93\u51fa\uff1a Resource acquired \u5c31\u662f\u8fd9\u6837 std::weak_ptr \u7528\u6765\u505a\u4ec0\u4e48 \u00b6 std::weak_ptr \u5c31\u662f\u7528\u6765\u89e3\u51b3\u4e0a\u65b9\u63cf\u8ff0\u7684\u5faa\u73af\u4f9d\u8d56\u7684\u95ee\u9898\u3002\u4e00\u4e2a \u201cstd::waek_ptr\u201d \u662f\u4e00\u4e2a\u89c2\u5bdf\u8005 \u2014\u2014\u2014\u2014 \u5b83\u53ef\u4ee5\u8bbf\u95ee\u548c\u540c\u6837\u7684\u5bf9\u8c61\u5c31\u50cf std::shared_ptr \u90a3\u6837\uff0c\u4f46\u5b83\u4e0d\u88ab\u8ba4\u4e3a\u662f\u4e00\u4e2a\u62e5\u6709\u8005\u3002\u8bb0\u4f4f\uff0c\u5f53\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5b83\u4ec5\u4ec5\u601d\u8003\u662f\u5426\u6709\u5176\u4ed6\u7684 std::shared_ptr \u5171\u540c\u6301\u6709\u8fd9\u4e2a\u5bf9\u8c61\uff0c std::weak_ptr \u4e0d\u7b97\u6570\uff01 \u8ba9\u6211\u4eec\u4f7f\u7528 weak_ptr \u6765\u89e3\u51b3\u4e4b\u524d\u7684 Persion \u95ee\u9898\uff1a #include <iostream> #include <memory> // for std::shared_ptr and std::weak_ptr #include <string> class Person { std :: string m_name ; std :: weak_ptr < Person > m_partner ; // note: This is now a std::weak_ptr public : Person ( const std :: string & name ) : m_name ( name ) { std :: cout << m_name << \" created \\n \" ; } ~ Person () { std :: cout << m_name << \" destroyed \\n \" ; } friend bool partnerUp ( std :: shared_ptr < Person > & p1 , std :: shared_ptr < Person > & p2 ) { if ( ! p1 || ! p2 ) return false ; p1 -> m_partner = p2 ; p2 -> m_partner = p1 ; std :: cout << p1 -> m_name << \" is now partnered with \" << p2 -> m_name << \" \\n \" ; return true ; } }; int main () { auto lucy = std :: make_shared < Person > ( \"Lucy\" ); auto ricky = std :: make_shared < Person > ( \"Ricky\" ); partnerUp ( lucy , ricky ); return 0 ; } \u8fd9\u6bb5\u4ee3\u7801\u8868\u73b0\u6b63\u5e38\uff1a Lucy created Ricky created Lucy is now partnered with Ricky Ricky destroyed Lucy destroyed \u4ece\u529f\u80fd\u4e0a\u6765\u8bb2\uff0c\u5b83\u540c\u6709\u95ee\u9898\u7684\u4f8b\u5b50\u5de5\u4f5c\u8d77\u6765\u51e0\u4e4e\u4e00\u6837\u3002\u7136\u800c\uff0c\u73b0\u5728\u5f53 ricky \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff0c\u5b83\u68c0\u67e5\u53d1\u73b0\u6ca1\u6709\u5176\u4ed6 std::shared_ptr \u6307\u5411\u4e86 \u201cRicky\u201d\uff08\u201cLucy\u201d \u7684 std::weak_ptr \u4e0d\u7b97\uff09\u3002\u56e0\u6b64\uff0c\u5b83\u4f1a\u91ca\u653e \u201cRicky\u201d\u3002\u540c\u6837\u7684\u60c5\u51b5\u53d1\u751f\u5728 lucy \u4e0a\u3002 \u4f7f\u7528 std::weak_ptr \u00b6 std::weak_ptr \u7684\u7f3a\u70b9\u662f std::weak_ptr \u4e0d\u80fd\u76f4\u63a5\u88ab\u4f7f\u7528\uff08\u5b83\u6ca1\u6709 -> \u64cd\u4f5c\u7b26\uff09\u3002\u8981\u4f7f\u7528 std::weak_ptr \u4f60\u5fc5\u987b\u5148\u8f6c\u5316\u5b83\u6210\u4e3a\u4e00\u4e2a std::shared_ptr \u3002\u8981\u5b8c\u6210\u8f6c\u5316\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528 lock() \u6210\u5458\u51fd\u6570\uff0c\u8fd9\u662f\u4e4b\u524d\u7684\u4f8b\u5b50\u7ecf\u8fc7\u66f4\u65b0\uff1a #include <iostream> #include <memory> // for std::shared_ptr and std::weak_ptr #include <string> class Person { std :: string m_name ; std :: weak_ptr < Person > m_partner ; // note: This is now a std::weak_ptr public : Person ( const std :: string & name ) : m_name ( name ) { std :: cout << m_name << \" created \\n \" ; } ~ Person () { std :: cout << m_name << \" destroyed \\n \" ; } friend bool partnerUp ( std :: shared_ptr < Person > & p1 , std :: shared_ptr < Person > & p2 ) { if ( ! p1 || ! p2 ) return false ; p1 -> m_partner = p2 ; p2 -> m_partner = p1 ; std :: cout << p1 -> m_name << \" is now partnered with \" << p2 -> m_name << \" \\n \" ; return true ; } const std :: shared_ptr < Person > getPartner () const { return m_partner . lock (); } // use lock() to convert weak_ptr to shared_ptr const std :: string & getName () const { return m_name ; } }; int main () { auto lucy = std :: make_shared < Person > ( \"Lucy\" ); auto ricky = std :: make_shared < Person > ( \"Ricky\" ); partnerUp ( lucy , ricky ); auto partner = ricky -> getPartner (); // get shared_ptr to Ricky's partner std :: cout << ricky -> getName () << \"'s partner is: \" << partner -> getName () << '\\n' ; return 0 ; } \u8f93\u51fa\uff1a Lucy created Ricky created Lucy is now partnered with Ricky Ricky's partner is: Lucy Ricky destroyed Lucy destroyed \u5728\u4f7f\u7528 partner \u53d8\u91cf\u7684\u65f6\u5019\uff0c\u6211\u4eec\u65e0\u9700\u5173\u5fc3\u5faa\u73af\u5f15\uff0c\u56e0\u4e3a\u4ed6\u5c31\u662f\u4e00\u4e2a\u51fd\u6570\u5185\u7684\u5c40\u90e8\u53d8\u91cf\u3002\u4ed6\u4f1a\u6700\u7ec8\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u7136\u540e\u5f15\u7528\u6570\u91cf\u4f1a\u51cf\u5c111. \u7ed3\u8bba \u00b6 \u5f53\u4f60\u9700\u8981\u591a\u4e2a\u667a\u80fd\u6307\u9488\u7ba1\u7406\u540c\u4e00\u4e2a\u8d44\u6e90\u65f6\uff0c\u53ef\u4ee5\u7528 std::shared_ptr \u3002\u8d44\u6e90\u5c06\u4f1a\u5728\u6700\u540e\u4e00\u4e2a std::shared_ptr \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\u9500\u6bc1\u3002 \u5f53\u4f60\u9700\u8981\u4e00\u4e2a\u53ea\u80fd\u6307\u9488\u6765\u8bbf\u95ee\u53e6\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u65f6\uff0c\u53ef\u4ee5\u7528 std::weak_ptr \uff0c\u4f46\u662f\u4e0d\u4f1a\u5f97\u5230\u8d44\u6e90\u7684\u6240\u6709\u6743","title":"15.7 std::shared_ptr \u7684\u5faa\u73af\u4f9d\u8d56\u95ee\u9898\uff0c\u4ecb\u7ecd std::weak_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.7-std%3A%3Aweak_ptr/#157-stdshared_ptr-stdweak_ptr","text":"By Alex on March 21 st , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.18 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u770b\u5230\u4e86 std::shared_ptr \u5982\u4f55\u5141\u8bb8\u6211\u4eec\u6709\u591a\u4e2a\u804c\u80fd\u6307\u6b63\u5171\u540c\u62e5\u6709\u540c\u6837\u7684\u8d44\u6e90\uff0c\u7136\u800c\uff0c\u5728\u5177\u4f53\u7684\u60c5\u51b5\u4e0b\uff0c\u8fd9\u53ef\u80fd\u5e26\u6765\u5f88\u591a\u95ee\u9898\uff0c\u601d\u8003\u5982\u4e0b\u4f8b\u5b50\uff0c\u8fd9\u65f6\u5019\u4e24\u4e2a\u5bf9\u8c61\u4e2d\u7684\u667a\u80fd\u6307\u9488\u5206\u522b\u6307\u5411\u4e86\u5176\u4ed6\u5bf9\u8c61\u3002 #include <iostream> #include <memory> // for std::shared_ptr #include <string> class Person { std :: string m_name ; std :: shared_ptr < Person > m_partner ; // initially created empty public : Person ( const std :: string & name ) : m_name ( name ) { std :: cout << m_name << \" created \\n \" ; } ~ Person () { std :: cout << m_name << \" destroyed \\n \" ; } friend bool partnerUp ( std :: shared_ptr < Person > & p1 , std :: shared_ptr < Person > & p2 ) { if ( ! p1 || ! p2 ) return false ; p1 -> m_partner = p2 ; p2 -> m_partner = p1 ; std :: cout << p1 -> m_name << \" is now partnered with \" << p2 -> m_name << \" \\n \" ; return true ; } }; int main () { auto lucy = std :: make_shared < Person > ( \"Lucy\" ); // create a Person named \"Lucy\" auto ricky = std :: make_shared < Person > ( \"Ricky\" ); // create a Person named \"Ricky\" partnerUp ( lucy , ricky ); // Make \"Lucy\" point to \"Ricky\" and vice-versa return 0 ; } \u5728\u4e0a\u4e2a\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528 make_shared() \u52a8\u6001\u5206\u914d\u4e86\u4e24\u4e2a Persons ,\u201cLucy\u201d \u548c \u201cRicky\u201d\uff08\u6765\u4fdd\u8bc1\u4ed6\u4eec\u5728 main()\u7ed3\u675f\u524d\u88ab\u9500\u6bc1 \uff09\u3002\u7d27\u63a5\u7740\uff0c\u6211\u4eec\u8ba9\u4ed6\u4eec\u6210\u4e3a\u642d\u6863\u3002\u8fd9\u4e2a\u64cd\u4f5c\u8bbe\u7f6e \"Lucy\" \u7684 std::shared_ptr \u6307\u5411 \u201cRicky\u201d\uff0c\u5e76\u4e14\u4f7f\u5f97 \u201cRicky\u201d \u5185\u7684 std::shared_ptr \u6307\u5411 \u201cLucy\u201d\u3002\u5171\u4eab\u6307\u9488\u88ab\u8bbe\u8ba1\u7528\u6765\u5171\u4eab\u7684\uff0c\u56e0\u6b64\u8fd9\u6837\u5f88\u68d2\uff0c\u5206\u522b\u8bbe\u7f6e\u4e24\u4e2a Persion \u4e3a\u5bf9\u65b9\u7684\u642d\u6863\u3002 \u7136\u800c\u6267\u884c\u8d77\u6765\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u6ca1\u6709\u6309\u7167\u671f\u671b\u6267\u884c\uff1a Lucy created Ricky created Lucy is now partnered with Ricky \u55ef\uff0c\u4f7f\u5f97\u3002\u6ca1\u6709\u9500\u6bc1\u53d1\u751f\uff0c\u53d1\u751f\u4e86\u4ec0\u4e48\uff1f \u5728 partnerUp() \u88ab\u8c03\u7528\u540e\uff0c\u6709\u4e24\u4e2a\u53ea\u80fd\u6307\u9488\u6307\u5411\u4e86 \u201cRicky\u201d\uff0c\u4e24\u4e2a\u667a\u80fd\u6307\u9488\u6307\u5411\u4e86 \u201cLucy\u201d\u3002 \u5728\u51fd\u6570\u7684\u7ed3\u5c3e\uff0c\u201cricky\u201d \u7684\u5171\u4eab\u6307\u9488\u5148\u79bb\u5f00\u4f5c\u7528\u4e8e\u3002\u5f53\u90a3\u53d1\u751f\u65f6\uff0c\u201cricky\u201d \u68c0\u67e5\u662f\u5426\u6709\u4efb\u4f55\u5176\u4ed6\u7684\u5171\u4eab\u6307\u9488\u5171\u7528\u62e5\u6709 \u201cRicky\u201d\u3002\u786e\u5b9e\u6709\uff08\u201clucy\u2018s m_partner\u201d\uff09\u3002\u56e0\u4e3a\u8fd9\uff0c\u5b83\u6ca1\u6709\u91ca\u653e\u201cRicky\u201d\uff08\u5982\u679c\u5b83\u91ca\u653e\u4e86\uff0c\u90a3\u4e48 \u201cLucy\u201d \u7684 m_partner \u5c31\u4f1a\u53d8\u6210\u60ac\u7a7a\u6307\u9488\uff09\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u73b0\u5728\u6709\u4e00\u4e2a\u53ea\u80fd\u6307\u9488\u6307\u5411 \u201cRicky\u201d\uff08\u201cLucy\u201d \u7684 m_partner\uff09\u548c\u4e24\u4e2a\u53ea\u80fd\u6307\u9488\u6307\u5411 \u201cLucy\u201d\uff08\u53d8\u91cf lucy \u548c \u201cRicky\u201d \u7684 m_partner\uff09\u3002 \u7d27\u63a5\u7740 lucy \u7684\u5171\u4eab\u6307\u9488\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5e76\u4e14\u540c\u6837\u7684\u4e8b\u60c5\u53d1\u751f\u4e86\uff0c\u667a\u80fd\u6307\u9488 lucy \u68c0\u67e5\u662f\u5426\u6709\u5176\u4ed6\u667a\u80fd\u6307\u6b63\u5171\u540c\u62e5\u6709 \u201cLucy\u201d\uff0c\u786e\u5b9e\u5b58\u5728\uff08\u201cRicky\u201d \u7684 m_partner\uff09\uff0c\u56e0\u6b64 \u201cLucy\u201d \u4e0d\u4f1a\u88ab\u91ca\u653e\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6709\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u6307\u5411 \u201cLucy\u201d\uff08\u201cRicky\u201d \u7684 m_partner\uff09\uff0c\u548c\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u6307\u5411 \u201cRicky\u201d\uff08\u201cLucy\u201d \u7684 m_partner\uff09\u3002 \u7d27\u63a5\u7740\uff0c\u7a0b\u5e8f\u7ed3\u675f \u2014\u2014\u2014\u2014 \u201cLucy\u201d \u6216 \u201cRicky\u201d \u90fd\u6ca1\u6709\u88ab\u91ca\u653e\uff01\u672c\u8d28\u4e0a \u201cLucy\u201d \u6700\u540e\u4fdd\u8bc1\u4e86 \u201cRicky\u201d \u4e0d\u88ab\u9500\u6bc1\uff0c\u800c\u4e14 \u201cRicky\u201d \u6700\u540e\u4fdd\u8bc1\u4e86 \u201cLucy\u201d \u4e0d\u88ab\u9500\u6bc1\u3002 It turns out that this can happen any time shared pointers form a circular reference. \u8fd9\u4f1a\u53d1\u751f\u5728\u4efb\u4f55\u65f6\u5019\uff0c\u53ea\u8981\u667a\u80fd\u6307\u9488\u51fa\u73b0\u5faa\u73af\u5f15\u7528\u3002","title":"15.7 std::shared_ptr \u7684\u5faa\u73af\u4f9d\u8d56\u95ee\u9898\uff0c\u4ecb\u7ecd std::weak_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.7-std%3A%3Aweak_ptr/#_1","text":"\u5faa\u73af\u4f9d\u8d56\uff08\u4e5f\u53eb cyclical reference)\u662f\u4e00\u7cfb\u5217\u5f15\u7528\u4e2d\uff0c\u6bcf\u4e00\u4e2a\u5bf9\u8c61\u5f15\u7528\u4e86\u4e0b\u4e00\u4e2a\uff0c\u800c\u6700\u540e\u4e00\u4e2a\u5bf9\u8c61\u5f15\u7528\u4e86\u7b2c\u4e00\u4e2a\uff0c\u9020\u6210\u5faa\u73af\u3002\u8fd9\u4e2a\u5f15\u7528\u4e0d\u9700\u8981\u662f\u786e\u5207\u7684 C++ \u5f15\u7528 \u2014\u2014\u2014\u2014 \u5b83\u53ef\u4ee5\u662f\u6307\u9488\uff0c\u552f\u4e00\u7684ID\uff0c\u6216\u8005\u4efb\u4f55\u7279\u6b8a\u5bf9\u8c61\u3002 \u5728\u667a\u80fd\u6307\u9488\uff08shared pointers\uff09\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5faa\u73af\u5f15\u7528\u5c31\u4f1a\u6307\u9488\u5f15\u8d77\u7684\u3002 \u8fd9\u6b63\u597d\u53d1\u751f\u5728\u4ee5\u4e0a\u7684\u60c5\u51b5\u4e0b\uff1a\u201cLucy\u201d \u6307\u5411\u4e86 \u201cRicky\u201d\uff0c\u7136\u540e \u201cRicky\u201d \u6307\u5411\u4e86 \u201cLucy\u201d\u3002\u5982\u679c\u6709\u4e09\u4e2a\u6307\u9488\uff0c\u4f60\u4f1a\u5f97\u5230\u76f8\u4f3c\u7684\u7ed3\u679c\u5c31\u662f A\u6307\u5411B\uff0cB\u6307\u5411C\uff0cC\u6307\u5411A\u3002\u5728\u73af\u4e2d\uff0c\u667a\u80fd\u6307\u9488\u7684\u6548\u679c\u4f9d\u7136\u662f\u4fdd\u8bc1\u4e0b\u4e00\u4e2a\u5bf9\u8c61\u7684\u5b58\u6d3b \u2014\u2014\u2014\u2014 \u6700\u540e\u4e00\u4e2a\u5bf9\u8c61\u4fdd\u8bc1\u4e86\u7b2c\u4e00\u4e2a\u5bf9\u8c61\u7684\u5b58\u6d3b\uff0c\u56e0\u6b64\uff0c\u6ca1\u6709\u5bf9\u8c61\u4f1a\u88ab\u91ca\u653e\uff0c\u56e0\u4e3a\u4ed6\u4eec\u90fd\u4efb\u4e3a\u5176\u4ed6\u5bf9\u8c61\u4ecd\u7136\u9700\u8981\u5b83\uff01","title":"\u5faa\u73af\u4f9d\u8d56"},{"location":"15-move-semantics-and-smart-pointers/15.7-std%3A%3Aweak_ptr/#reductive","text":"\u4e8b\u5b9e\u8bc1\u660e\uff0c\u5faa\u73af\u5f15\u7528\u7684\u95ee\u9898\u751a\u81f3\u5728\u53ea\u6709\u4e00\u4e2a std::shared_ptr \u7684\u60c5\u51b5\u4e0b\u6210\u7acb\u3002 \u2014\u2014\u2014\u2014 \u4e00\u4e2a std::shared_ptr \u5f15\u7528\u7684\u5bf9\u8c61\u5305\u542b\u4e86\u4e00\u4e2a\u5faa\u73af\u3002\u5c3d\u7ba1\u8fd9\u5728\u5b9e\u9645\u60c5\u51b5\u4e0b\u5f88\u4e0d\u5e38\u89c1\uff0c\u6211\u4eec\u5c06\u4f1a\u5c55\u793a\u7ed9\u4f60\uff0c\u4e3a\u4e86\u8fdb\u4e00\u6b65\u7406\u89e3\uff1a #include <iostream> #include <memory> // for std::shared_ptr class Resource { public : std :: shared_ptr < Resource > m_ptr ; // initially created empty Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { auto ptr1 = std :: make_shared < Resource > (); ptr1 -> m_ptr = ptr1 ; // m_ptr is now sharing the Resource that contains it return 0 ; } \u5728\u4e0a\u65b9\u7684\u4f8b\u5b50\u4e2d\uff0c\u5f53 ptr1 \u79bb\u5f00\u4f5c\u7528\u4e8e\u65f6\uff0c\u4ed6\u4e0d\u4f1a\u91ca\u653e Resource \u56e0\u4e3a Rresource \u7684 m_ptr \u6b63\u5728\u5171\u4eab Resource\u3002\u7d27\u63a5\u7740\u6ca1\u6709\u8c01\u4f1a\u88ab\u5220\u9664 \uff08 m_ptr \u4ece\u672a\u79bb\u5f00\u4f5c\u7528\u4e8e\uff0c\u6240\u4ee5\u5b83\u6ca1\u6709\u673a\u4f1a\u88ab\u5220\u9664\uff09\u3002\u56e0\u6b64\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u8f93\u51fa\uff1a Resource acquired \u5c31\u662f\u8fd9\u6837","title":"\u4e00\u4e2a reductive \u7684\u60c5\u51b5"},{"location":"15-move-semantics-and-smart-pointers/15.7-std%3A%3Aweak_ptr/#stdweak_ptr","text":"std::weak_ptr \u5c31\u662f\u7528\u6765\u89e3\u51b3\u4e0a\u65b9\u63cf\u8ff0\u7684\u5faa\u73af\u4f9d\u8d56\u7684\u95ee\u9898\u3002\u4e00\u4e2a \u201cstd::waek_ptr\u201d \u662f\u4e00\u4e2a\u89c2\u5bdf\u8005 \u2014\u2014\u2014\u2014 \u5b83\u53ef\u4ee5\u8bbf\u95ee\u548c\u540c\u6837\u7684\u5bf9\u8c61\u5c31\u50cf std::shared_ptr \u90a3\u6837\uff0c\u4f46\u5b83\u4e0d\u88ab\u8ba4\u4e3a\u662f\u4e00\u4e2a\u62e5\u6709\u8005\u3002\u8bb0\u4f4f\uff0c\u5f53\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5b83\u4ec5\u4ec5\u601d\u8003\u662f\u5426\u6709\u5176\u4ed6\u7684 std::shared_ptr \u5171\u540c\u6301\u6709\u8fd9\u4e2a\u5bf9\u8c61\uff0c std::weak_ptr \u4e0d\u7b97\u6570\uff01 \u8ba9\u6211\u4eec\u4f7f\u7528 weak_ptr \u6765\u89e3\u51b3\u4e4b\u524d\u7684 Persion \u95ee\u9898\uff1a #include <iostream> #include <memory> // for std::shared_ptr and std::weak_ptr #include <string> class Person { std :: string m_name ; std :: weak_ptr < Person > m_partner ; // note: This is now a std::weak_ptr public : Person ( const std :: string & name ) : m_name ( name ) { std :: cout << m_name << \" created \\n \" ; } ~ Person () { std :: cout << m_name << \" destroyed \\n \" ; } friend bool partnerUp ( std :: shared_ptr < Person > & p1 , std :: shared_ptr < Person > & p2 ) { if ( ! p1 || ! p2 ) return false ; p1 -> m_partner = p2 ; p2 -> m_partner = p1 ; std :: cout << p1 -> m_name << \" is now partnered with \" << p2 -> m_name << \" \\n \" ; return true ; } }; int main () { auto lucy = std :: make_shared < Person > ( \"Lucy\" ); auto ricky = std :: make_shared < Person > ( \"Ricky\" ); partnerUp ( lucy , ricky ); return 0 ; } \u8fd9\u6bb5\u4ee3\u7801\u8868\u73b0\u6b63\u5e38\uff1a Lucy created Ricky created Lucy is now partnered with Ricky Ricky destroyed Lucy destroyed \u4ece\u529f\u80fd\u4e0a\u6765\u8bb2\uff0c\u5b83\u540c\u6709\u95ee\u9898\u7684\u4f8b\u5b50\u5de5\u4f5c\u8d77\u6765\u51e0\u4e4e\u4e00\u6837\u3002\u7136\u800c\uff0c\u73b0\u5728\u5f53 ricky \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff0c\u5b83\u68c0\u67e5\u53d1\u73b0\u6ca1\u6709\u5176\u4ed6 std::shared_ptr \u6307\u5411\u4e86 \u201cRicky\u201d\uff08\u201cLucy\u201d \u7684 std::weak_ptr \u4e0d\u7b97\uff09\u3002\u56e0\u6b64\uff0c\u5b83\u4f1a\u91ca\u653e \u201cRicky\u201d\u3002\u540c\u6837\u7684\u60c5\u51b5\u53d1\u751f\u5728 lucy \u4e0a\u3002","title":"std::weak_ptr \u7528\u6765\u505a\u4ec0\u4e48"},{"location":"15-move-semantics-and-smart-pointers/15.7-std%3A%3Aweak_ptr/#stdweak_ptr_1","text":"std::weak_ptr \u7684\u7f3a\u70b9\u662f std::weak_ptr \u4e0d\u80fd\u76f4\u63a5\u88ab\u4f7f\u7528\uff08\u5b83\u6ca1\u6709 -> \u64cd\u4f5c\u7b26\uff09\u3002\u8981\u4f7f\u7528 std::weak_ptr \u4f60\u5fc5\u987b\u5148\u8f6c\u5316\u5b83\u6210\u4e3a\u4e00\u4e2a std::shared_ptr \u3002\u8981\u5b8c\u6210\u8f6c\u5316\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528 lock() \u6210\u5458\u51fd\u6570\uff0c\u8fd9\u662f\u4e4b\u524d\u7684\u4f8b\u5b50\u7ecf\u8fc7\u66f4\u65b0\uff1a #include <iostream> #include <memory> // for std::shared_ptr and std::weak_ptr #include <string> class Person { std :: string m_name ; std :: weak_ptr < Person > m_partner ; // note: This is now a std::weak_ptr public : Person ( const std :: string & name ) : m_name ( name ) { std :: cout << m_name << \" created \\n \" ; } ~ Person () { std :: cout << m_name << \" destroyed \\n \" ; } friend bool partnerUp ( std :: shared_ptr < Person > & p1 , std :: shared_ptr < Person > & p2 ) { if ( ! p1 || ! p2 ) return false ; p1 -> m_partner = p2 ; p2 -> m_partner = p1 ; std :: cout << p1 -> m_name << \" is now partnered with \" << p2 -> m_name << \" \\n \" ; return true ; } const std :: shared_ptr < Person > getPartner () const { return m_partner . lock (); } // use lock() to convert weak_ptr to shared_ptr const std :: string & getName () const { return m_name ; } }; int main () { auto lucy = std :: make_shared < Person > ( \"Lucy\" ); auto ricky = std :: make_shared < Person > ( \"Ricky\" ); partnerUp ( lucy , ricky ); auto partner = ricky -> getPartner (); // get shared_ptr to Ricky's partner std :: cout << ricky -> getName () << \"'s partner is: \" << partner -> getName () << '\\n' ; return 0 ; } \u8f93\u51fa\uff1a Lucy created Ricky created Lucy is now partnered with Ricky Ricky's partner is: Lucy Ricky destroyed Lucy destroyed \u5728\u4f7f\u7528 partner \u53d8\u91cf\u7684\u65f6\u5019\uff0c\u6211\u4eec\u65e0\u9700\u5173\u5fc3\u5faa\u73af\u5f15\uff0c\u56e0\u4e3a\u4ed6\u5c31\u662f\u4e00\u4e2a\u51fd\u6570\u5185\u7684\u5c40\u90e8\u53d8\u91cf\u3002\u4ed6\u4f1a\u6700\u7ec8\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u7136\u540e\u5f15\u7528\u6570\u91cf\u4f1a\u51cf\u5c111.","title":"\u4f7f\u7528 std::weak_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.7-std%3A%3Aweak_ptr/#_2","text":"\u5f53\u4f60\u9700\u8981\u591a\u4e2a\u667a\u80fd\u6307\u9488\u7ba1\u7406\u540c\u4e00\u4e2a\u8d44\u6e90\u65f6\uff0c\u53ef\u4ee5\u7528 std::shared_ptr \u3002\u8d44\u6e90\u5c06\u4f1a\u5728\u6700\u540e\u4e00\u4e2a std::shared_ptr \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\u9500\u6bc1\u3002 \u5f53\u4f60\u9700\u8981\u4e00\u4e2a\u53ea\u80fd\u6307\u9488\u6765\u8bbf\u95ee\u53e6\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u65f6\uff0c\u53ef\u4ee5\u7528 std::weak_ptr \uff0c\u4f46\u662f\u4e0d\u4f1a\u5f97\u5230\u8d44\u6e90\u7684\u6240\u6709\u6743","title":"\u7ed3\u8bba"},{"location":"18-input-and-output/18.1-input-and-output-streams/","text":"18.1 - \u8f93\u5165\u8f93\u51fa\u6d41 \u00b6 18.1 \u2014 Input and output (I/O) streams By Alex on February 28 th , 2008 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1By dashjay \u8f93\u5165\u548c\u8f93\u51fa\u529f\u80fd\u6ca1\u6709\u5b9a\u4e49\u4f5c\u4e3a C++ \u7684\u6838\u5fc3\u90e8\u5206\uff0c\u4f46\u662f\u4e5f\u88ab\u901a\u8fc7 C++ \u7684\u6807\u51c6\u5e93\u63d0\u4f9b\uff08\u4e5f\u5b58\u5728\u4e8e std \u547d\u540d\u7a7a\u95f4\uff09\u3002\u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u4f60\u5f15\u7528\u4e86 <iostrea> \u5e93\u7684\u5934\u90e8\u5e76\u4e14\u4f7f\u7528 cin \u548c cout \u5bf9\u8c61\u6765\u505a\u7b80\u5355\u7684 I/O. \u5728\u8fd9\u4e2a\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u4f1a\u66f4\u8be6\u7ec6\u7684\u770b\u4e00\u4e0b\u554a iostream \u5e93\u3002 The iostream library \u00b6 \u5f53\u4f60\u5f15\u7528\u4e86 iostream \u7684\u5934\u90e8\uff0c\u4f60\u53ef\u4ee5\u8bbf\u95ee\u6574\u4e2a I/O \u7684\u67b6\u6784\u3002\uff08\u5f15\u5165\u4e86\u4e00\u4e2a\u540d\u5b57\u53eb\u505a iostream \u7684\u7c7b\uff09\u3002\u7c7b\u7ed3\u6784\uff08\u975e\u6587\u4ef6IO\uff09\u770b\u8d77\u6765\u50cf\u8fd9\u6837\uff1a \u7b2c\u4e00\u4ef6\u4f60\u53ef\u80fd\u6ce8\u610f\u5230\u7684\u4e8b\u60c5\u5c31\u662f\u5b83\u4f7f\u7528\u4e86\u591a\u7ee7\u627f\uff08\u4ee5\u524d\u6211\u4eec\u8bf4\u8fc7\u8981\u907f\u514d\u7684\uff09\u3002\u7136\u800c\uff0c iostream \u5e93\u88ab\u8bbe\u8ba1\u5e76\u4e14\u5e7f\u6cdb\u5730\u6d4b\u8bd5\u907f\u514d\u591a\u7ee7\u627f\u7684\u95ee\u9898\uff0c\u56e0\u6b64\u4f60\u53ef\u4ee5\u4e0d\u7528\u4e1d\u6beb\u62c5\u5fc3\u7684\u4f7f\u7528\u5b83\u3002 \u6d41 \u00b6 Streams \u7b2c\u4e8c\u4ef6\u4f60\u53ef\u80fd\u6ce8\u610f\u5230\u7684\u5c31\u662f\u5355\u8bcd stream \uff0c\u5b83\u7ecf\u5e38\u88ab\u6ee5\u7528\u3002\u4f5c\u4e3a\u6700\u57fa\u7840\u7684\u57fa\u7c7b\uff0cC++ \u4e2d\u7684 I/O \u4f7f\u7528\u6d41\u6765\u5b9e\u73b0\u3002\u62bd\u8c61\u6765\u8bb2\uff0c\u4e00\u4e2a stream \u5c31\u662f\u4e00\u4e2a\u5b57\u8282\u5e8f\u5217\u53ef\u4ee5\u88ab\u6309\u987a\u5e8f\u8bbf\u95ee\u3002\u968f\u7740\u65f6\u95f4\u7684\u63a8\u79fb\uff0c\u4e00\u4e2a stream \u53ef\u80fd\u4ea7\u751f\u6216\u8005\u6d88\u8d39\u6f5c\u5728\u7684\u65e0\u9650\u7684\u6570\u636e\u3002 \u901a\u5e38\uff0c\u6211\u4eec\u5904\u7406\u4e24\u79cd\u4e0d\u540c\u7c7b\u578b\u7684\u6d41\u3002\u8f93\u5165\u6d41\u88ab\u7528\u6765\u4ece\u4e00\u4e2a\u6570\u636e\u751f\u4ea7\u8005\u7ef4\u6301\u8f93\u5165\uff0c\u4f8b\u5982\u4e00\u6b21\u952e\u76d8\u89e6\u53d1\uff0c\u4e00\u4e2a\u6587\u4ef6\uff0c\u6216\u8005\u4e00\u4e2a\u7f51\u7edc\u3002\u4f8b\u5982\uff0c\u7528\u6237\u53ef\u80fd\u6309\u4e0b\u4e00\u4e2a\u6309\u94ae\u5f53\u7a0b\u5e8f\u6ca1\u6709\u671f\u5f85\u4efb\u4f55\u8f93\u5165\u3002\u4e0d\u4f1a\u5ffd\u7565\u7528\u6237\u7684\u6309\u952e\uff0c\u800c\u662f\u628a\u6570\u636e\u653e\u8fdb\u8f93\u5165\u6d41\u4e2d\uff0c\u5b83\u4f1a\u7b49\u5f85\u77e5\u9053\u7a0b\u5e8f\u63a5\u6536\u8fd9\u4e2a\u8f93\u5165\u3002 \u76f8\u53cd\u7684\uff0c\u8f93\u51fa\u6d41\u88ab\u7528\u6765\u6301\u7eed\u8f93\u51fa\u63d0\u4f9b\u7ed9\u7279\u5b9a\u7684\u6570\u636e\u6d88\u8d39\u8005\uff0c\u4f8b\u5982\u4e00\u4e2a\u663e\u793a\u5668\uff0c\u4e00\u4e2a\u6587\u4ef6\u6216\u8005\u4e00\u4e2a\u6253\u5370\u673a\u3002\u5f53\u5199\u6570\u636e\u5230\u4efb\u4f55\u8bbe\u5907\uff0c\u5e76\u4e14\u8bbe\u5907\u53ef\u80fd\u6ca1\u6709\u51c6\u5907\u597d\u63a5\u6536\u6570\u636e \u2014\u2014\u2014\u2014 \u4f8b\u5982\uff0c\u6253\u5370\u673a\u4ecd\u7136\u6b63\u5728\u9884\u70ed\u5f53\u7a0b\u5e8f\u5c1d\u8bd5\u5199\u5165\u6570\u636e\u5230\u5b83\u7684\u8f93\u51fa\u6d41\u3002\u6570\u636e\u5c06\u4f1a\u5728\u8f93\u51fa\u6d41\u7b49\u5f85\uff0c\u76f4\u5230\u5f00\u59cb\u6d88\u8d39\u5b83\u3002 \u4e00\u4e9b\u8bbe\u5907\uff0c\u5217\u5982\u6587\u4ef6\u548c\u7f51\u8def\uff0c\u6709\u80fd\u529b\u4f5c\u4e3a\u8f93\u5165\u548c\u8f93\u51fa\u6e90\u3002 \u6d41\u7684\u597d\u5904\u5c31\u662f\u7a0b\u5e8f\u5458\u53ea\u9700\u8981\u5b66\u4f1a\u7b80\u5355\u7684\u4ea4\u4e92\uff0c\u5c31\u53ef\u4ee5\u5728\u4e0d\u540c\u7684\u8bbe\u5907\u4e2d\u8bfb\u5199\u6570\u636e\u3002\u6d41\u5b9e\u9645\u4e0a\u5982\u4f55\u4e0e\u8fde\u63a5\u5230\u5b83\u7684\u5b9e\u9645\u8bbe\u5907\u63a5\u53e3\u8fdb\u884c\u6c9f\u901a\u7531\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a\u3002 C++ \u4e2d\u7684\u8f93\u5165\u8f93\u51fa \u00b6 \u5c3d\u7ba1 ios \u6d3e\u751f\u81ea ios_base \uff0c ios \u901a\u5e38\u662f\u4f60\u4f1a\u4f7f\u7528\u7684\u6700\u57fa\u7840\u7684\u7c7b\u3002 ios \u7c7b\u5b9a\u4e49\u4e86\u5f88\u591a\u4e1c\u897f\uff0c\u5e38\u89c1\u4e8e\u8f93\u5165\u8f93\u51fa\u6d41\u3002\u6211\u4eec\u5c06\u4f1a\u5728\u672a\u6765\u7684\u8bfe\u7a0b\u4e2d\u4f7f\u7528\u4ed6\u4eec\u3002 istream \u7c7b\u662f\u4e00\u4e2a\u57fa\u7840\u7c7b\uff0c\u88ab\u4f7f\u7528\u4e3a\u8f93\u5165\u6d41\u3002\u4f7f\u7528\u8f93\u5165\u6d41\uff0c\u63d0\u53d6\u64cd\u4f5c\u7b26(>>) \u88ab\u7528\u6765\u79fb\u9664\u6d41\u4e2d\u7684\u503c\u3002\u8fd9\u662f\u6709\u610f\u4e49\u7684\uff1a\u5f53\u7528\u6237\u6309\u4e0b\u952e\u76d8\u7684\u952e\uff0c\u8f93\u5165\u7684\u952e\u7801\u88ab\u653e\u5728\u8f93\u5165\u6d41\u4e2d\u3002\u4f60\u7684\u7a0b\u5e8f\u7d27\u63a5\u7740\u4f1a\u63d0\u53d6\u8fd9\u4e2a\u503c\u5f53\u5b83\u53ef\u7528\u65f6\u3002 ostream \u7c7b\u662f\u57fa\u7840\u7684\u5904\u7406\u8f93\u51fa\u6d41\u7684\u7c7b\u3002\u4f7f\u7528\u8f93\u51fa\u6d41\uff0c\u63d2\u5165\u64cd\u4f5c\u7b26(<<)\u88ab\u7528\u6765\u5c06\u503c\u653e\u5165\u6d41\u4e2d\u3002\u8fd9\u4e5f\u5f88\u6709\u610f\u4e49\uff1a\u4f60\u63d2\u5165\u4f60\u7684\u503c\u5230\u6d41\u4e2d\uff0c\u6570\u636e\u4e4b\u540e\u4f1a\u88ab\u6d88\u8d39\u8005\uff08\u4f8b\u5982\uff1a\u663e\u793a\u5668\uff09\u4f7f\u7528\u3002 iostream \u7c7b\u53ef\u4ee5\u540c\u5c5e\u5904\u7406\u8f93\u5165\u548c\u8f93\u51fa\uff0c\u5141\u8bb8\u53cc\u5411I/O \u00b6 \u6700\u540e\uff0c\u6709\u51e0\u4e2a\u7c7b\u540d\u4ee5 _withassign \u7ed3\u5c3e\u7684\u7c7b\u3002\u8fd9\u4e9b\u6d41\u7c7b\u6d3e\u751f\u81ea istream \uff0c ostream \u548c iostream \uff08\u5206\u522b\u7684\uff09\u5e26\u6709\u4e00\u4e2a \u8d4b\u503c\u64cd\u4f5c\u7b26\u5b9a\u4e49\uff0c\u5141\u8bb8\u4f60\u8d4b\u503c\u4e00\u4e2a\u6d41\u7ed9\u53e6\u4e00\u4e2a\u3002\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u4f60\u4e0d\u4f1a\u76f4\u63a5\u64cd\u4f5c\u8fd9\u4e9b\u7c7b\u3002 C++ \u4e2d\u7684\u6807\u51c6\u6d41 \u00b6 A standard stream is a pre-connected stream provided to a computer program by its environment. C++ comes with four predefined standard stream objects that have already been set up for your use. The first three, you have seen before: \u4e00\u4e2a\u6807\u51c6\u6d41\u662f\uff0c\u63d0\u4f9b\u7ed9\u4e00\u4e2a\u7535\u8111\u7a0b\u5e8f\u7684\u4e00\u4e2a\u9884\u94fe\u63a5\u7684\u6d41\uff08A standard stream is a pre-connected stream provided to a computer program by its environment.\uff09\u3002C++ \u9644\u5e26\u4e864\u4e2a\u9884\u5b9a\u4e49\u7684\u6807\u51c6\u6d41\uff0c\u88ab\u5b9a\u4e49\u6765\u63d0\u4f9b\u7ed9\u4f60\u4f7f\u7528\u7684\uff0c\u4f60\u4e4b\u524d\u770b\u5230\u8fc7\u7684\uff1a cin \u2014\u2014 \u4e00\u4e2a istream_withassign \u7c7b\uff0c\u8fde\u63a5\u5230\u6807\u51c6\u8f93\u5165\uff08\u901a\u5e38\u662f\u952e\u76d8\uff09 cout \u2014\u2014 \u4e00\u4e2a ostream_withassign \u7c7b\uff0c\u8fde\u63a5\u5230\u6807\u6ce8\u8f93\u51fa\uff08\u901a\u5e38\u662f\u663e\u793a\u5668\uff09 cerr \u2014\u2014 \u4e00\u4e2a ostream_withassign \u7c7b\uff0c\u8fde\u63a5\u5230\u6807\u51c6\u9519\u8bef\uff08\u901a\u5e38\u662f\u663e\u793a\u5668\uff09\uff0c\u63d0\u4f9b\u65e0buffer\u7684\u8f93\u51fa clog \u2014\u2014 \u4e00\u4e2a ostream_withassign \u7c7b\uff0c\u8fde\u63a5\u5230\u6807\u51c6\u9519\u8bef\uff08\u901a\u5e38\u662f\u663e\u793a\u5668\uff09\uff0c\u63d0\u4f9b\u6709buffer\u7684\u8f93\u51fa \u65e0 buffer \u70b9\u7684\u8f93\u51fa\u901a\u5e38\u88ab\u7acb\u523b\u6267\u884c\uff0c\u800c\u5e26buffer\u7684\u8f93\u51fa\u901a\u5e38\u88ab\u50a8\u5b58\u5e76\u4e14\u4ee5\u5757\u4e3a\u5355\u4f4d\u5199\u51fa\u3002\u56e0\u4e3a clog \u4e0d\u662f\u5f88\u5e38\u7528\uff0c\u5b83\u901a\u5e38\u4e5f\u88ab\u6807\u51c6\u6d41\u5217\u8868\u4e2d\u5ffd\u7565\u3002 \u5728\u63a5\u4e0b\u6765\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u770b\u66f4\u591a\u7684 I/O \u76f8\u5173\u7684\u8be6\u7ec6\u529f\u80fd","title":"18.1 - \u8f93\u5165\u8f93\u51fa\u6d41"},{"location":"18-input-and-output/18.1-input-and-output-streams/#181-","text":"18.1 \u2014 Input and output (I/O) streams By Alex on February 28 th , 2008 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1By dashjay \u8f93\u5165\u548c\u8f93\u51fa\u529f\u80fd\u6ca1\u6709\u5b9a\u4e49\u4f5c\u4e3a C++ \u7684\u6838\u5fc3\u90e8\u5206\uff0c\u4f46\u662f\u4e5f\u88ab\u901a\u8fc7 C++ \u7684\u6807\u51c6\u5e93\u63d0\u4f9b\uff08\u4e5f\u5b58\u5728\u4e8e std \u547d\u540d\u7a7a\u95f4\uff09\u3002\u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u4f60\u5f15\u7528\u4e86 <iostrea> \u5e93\u7684\u5934\u90e8\u5e76\u4e14\u4f7f\u7528 cin \u548c cout \u5bf9\u8c61\u6765\u505a\u7b80\u5355\u7684 I/O. \u5728\u8fd9\u4e2a\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u4f1a\u66f4\u8be6\u7ec6\u7684\u770b\u4e00\u4e0b\u554a iostream \u5e93\u3002","title":"18.1 - \u8f93\u5165\u8f93\u51fa\u6d41"},{"location":"18-input-and-output/18.1-input-and-output-streams/#the-iostream-library","text":"\u5f53\u4f60\u5f15\u7528\u4e86 iostream \u7684\u5934\u90e8\uff0c\u4f60\u53ef\u4ee5\u8bbf\u95ee\u6574\u4e2a I/O \u7684\u67b6\u6784\u3002\uff08\u5f15\u5165\u4e86\u4e00\u4e2a\u540d\u5b57\u53eb\u505a iostream \u7684\u7c7b\uff09\u3002\u7c7b\u7ed3\u6784\uff08\u975e\u6587\u4ef6IO\uff09\u770b\u8d77\u6765\u50cf\u8fd9\u6837\uff1a \u7b2c\u4e00\u4ef6\u4f60\u53ef\u80fd\u6ce8\u610f\u5230\u7684\u4e8b\u60c5\u5c31\u662f\u5b83\u4f7f\u7528\u4e86\u591a\u7ee7\u627f\uff08\u4ee5\u524d\u6211\u4eec\u8bf4\u8fc7\u8981\u907f\u514d\u7684\uff09\u3002\u7136\u800c\uff0c iostream \u5e93\u88ab\u8bbe\u8ba1\u5e76\u4e14\u5e7f\u6cdb\u5730\u6d4b\u8bd5\u907f\u514d\u591a\u7ee7\u627f\u7684\u95ee\u9898\uff0c\u56e0\u6b64\u4f60\u53ef\u4ee5\u4e0d\u7528\u4e1d\u6beb\u62c5\u5fc3\u7684\u4f7f\u7528\u5b83\u3002","title":"The iostream library"},{"location":"18-input-and-output/18.1-input-and-output-streams/#_1","text":"Streams \u7b2c\u4e8c\u4ef6\u4f60\u53ef\u80fd\u6ce8\u610f\u5230\u7684\u5c31\u662f\u5355\u8bcd stream \uff0c\u5b83\u7ecf\u5e38\u88ab\u6ee5\u7528\u3002\u4f5c\u4e3a\u6700\u57fa\u7840\u7684\u57fa\u7c7b\uff0cC++ \u4e2d\u7684 I/O \u4f7f\u7528\u6d41\u6765\u5b9e\u73b0\u3002\u62bd\u8c61\u6765\u8bb2\uff0c\u4e00\u4e2a stream \u5c31\u662f\u4e00\u4e2a\u5b57\u8282\u5e8f\u5217\u53ef\u4ee5\u88ab\u6309\u987a\u5e8f\u8bbf\u95ee\u3002\u968f\u7740\u65f6\u95f4\u7684\u63a8\u79fb\uff0c\u4e00\u4e2a stream \u53ef\u80fd\u4ea7\u751f\u6216\u8005\u6d88\u8d39\u6f5c\u5728\u7684\u65e0\u9650\u7684\u6570\u636e\u3002 \u901a\u5e38\uff0c\u6211\u4eec\u5904\u7406\u4e24\u79cd\u4e0d\u540c\u7c7b\u578b\u7684\u6d41\u3002\u8f93\u5165\u6d41\u88ab\u7528\u6765\u4ece\u4e00\u4e2a\u6570\u636e\u751f\u4ea7\u8005\u7ef4\u6301\u8f93\u5165\uff0c\u4f8b\u5982\u4e00\u6b21\u952e\u76d8\u89e6\u53d1\uff0c\u4e00\u4e2a\u6587\u4ef6\uff0c\u6216\u8005\u4e00\u4e2a\u7f51\u7edc\u3002\u4f8b\u5982\uff0c\u7528\u6237\u53ef\u80fd\u6309\u4e0b\u4e00\u4e2a\u6309\u94ae\u5f53\u7a0b\u5e8f\u6ca1\u6709\u671f\u5f85\u4efb\u4f55\u8f93\u5165\u3002\u4e0d\u4f1a\u5ffd\u7565\u7528\u6237\u7684\u6309\u952e\uff0c\u800c\u662f\u628a\u6570\u636e\u653e\u8fdb\u8f93\u5165\u6d41\u4e2d\uff0c\u5b83\u4f1a\u7b49\u5f85\u77e5\u9053\u7a0b\u5e8f\u63a5\u6536\u8fd9\u4e2a\u8f93\u5165\u3002 \u76f8\u53cd\u7684\uff0c\u8f93\u51fa\u6d41\u88ab\u7528\u6765\u6301\u7eed\u8f93\u51fa\u63d0\u4f9b\u7ed9\u7279\u5b9a\u7684\u6570\u636e\u6d88\u8d39\u8005\uff0c\u4f8b\u5982\u4e00\u4e2a\u663e\u793a\u5668\uff0c\u4e00\u4e2a\u6587\u4ef6\u6216\u8005\u4e00\u4e2a\u6253\u5370\u673a\u3002\u5f53\u5199\u6570\u636e\u5230\u4efb\u4f55\u8bbe\u5907\uff0c\u5e76\u4e14\u8bbe\u5907\u53ef\u80fd\u6ca1\u6709\u51c6\u5907\u597d\u63a5\u6536\u6570\u636e \u2014\u2014\u2014\u2014 \u4f8b\u5982\uff0c\u6253\u5370\u673a\u4ecd\u7136\u6b63\u5728\u9884\u70ed\u5f53\u7a0b\u5e8f\u5c1d\u8bd5\u5199\u5165\u6570\u636e\u5230\u5b83\u7684\u8f93\u51fa\u6d41\u3002\u6570\u636e\u5c06\u4f1a\u5728\u8f93\u51fa\u6d41\u7b49\u5f85\uff0c\u76f4\u5230\u5f00\u59cb\u6d88\u8d39\u5b83\u3002 \u4e00\u4e9b\u8bbe\u5907\uff0c\u5217\u5982\u6587\u4ef6\u548c\u7f51\u8def\uff0c\u6709\u80fd\u529b\u4f5c\u4e3a\u8f93\u5165\u548c\u8f93\u51fa\u6e90\u3002 \u6d41\u7684\u597d\u5904\u5c31\u662f\u7a0b\u5e8f\u5458\u53ea\u9700\u8981\u5b66\u4f1a\u7b80\u5355\u7684\u4ea4\u4e92\uff0c\u5c31\u53ef\u4ee5\u5728\u4e0d\u540c\u7684\u8bbe\u5907\u4e2d\u8bfb\u5199\u6570\u636e\u3002\u6d41\u5b9e\u9645\u4e0a\u5982\u4f55\u4e0e\u8fde\u63a5\u5230\u5b83\u7684\u5b9e\u9645\u8bbe\u5907\u63a5\u53e3\u8fdb\u884c\u6c9f\u901a\u7531\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a\u3002","title":"\u6d41"},{"location":"18-input-and-output/18.1-input-and-output-streams/#c","text":"\u5c3d\u7ba1 ios \u6d3e\u751f\u81ea ios_base \uff0c ios \u901a\u5e38\u662f\u4f60\u4f1a\u4f7f\u7528\u7684\u6700\u57fa\u7840\u7684\u7c7b\u3002 ios \u7c7b\u5b9a\u4e49\u4e86\u5f88\u591a\u4e1c\u897f\uff0c\u5e38\u89c1\u4e8e\u8f93\u5165\u8f93\u51fa\u6d41\u3002\u6211\u4eec\u5c06\u4f1a\u5728\u672a\u6765\u7684\u8bfe\u7a0b\u4e2d\u4f7f\u7528\u4ed6\u4eec\u3002 istream \u7c7b\u662f\u4e00\u4e2a\u57fa\u7840\u7c7b\uff0c\u88ab\u4f7f\u7528\u4e3a\u8f93\u5165\u6d41\u3002\u4f7f\u7528\u8f93\u5165\u6d41\uff0c\u63d0\u53d6\u64cd\u4f5c\u7b26(>>) \u88ab\u7528\u6765\u79fb\u9664\u6d41\u4e2d\u7684\u503c\u3002\u8fd9\u662f\u6709\u610f\u4e49\u7684\uff1a\u5f53\u7528\u6237\u6309\u4e0b\u952e\u76d8\u7684\u952e\uff0c\u8f93\u5165\u7684\u952e\u7801\u88ab\u653e\u5728\u8f93\u5165\u6d41\u4e2d\u3002\u4f60\u7684\u7a0b\u5e8f\u7d27\u63a5\u7740\u4f1a\u63d0\u53d6\u8fd9\u4e2a\u503c\u5f53\u5b83\u53ef\u7528\u65f6\u3002 ostream \u7c7b\u662f\u57fa\u7840\u7684\u5904\u7406\u8f93\u51fa\u6d41\u7684\u7c7b\u3002\u4f7f\u7528\u8f93\u51fa\u6d41\uff0c\u63d2\u5165\u64cd\u4f5c\u7b26(<<)\u88ab\u7528\u6765\u5c06\u503c\u653e\u5165\u6d41\u4e2d\u3002\u8fd9\u4e5f\u5f88\u6709\u610f\u4e49\uff1a\u4f60\u63d2\u5165\u4f60\u7684\u503c\u5230\u6d41\u4e2d\uff0c\u6570\u636e\u4e4b\u540e\u4f1a\u88ab\u6d88\u8d39\u8005\uff08\u4f8b\u5982\uff1a\u663e\u793a\u5668\uff09\u4f7f\u7528\u3002","title":"C++ \u4e2d\u7684\u8f93\u5165\u8f93\u51fa"},{"location":"18-input-and-output/18.1-input-and-output-streams/#iostream-io","text":"\u6700\u540e\uff0c\u6709\u51e0\u4e2a\u7c7b\u540d\u4ee5 _withassign \u7ed3\u5c3e\u7684\u7c7b\u3002\u8fd9\u4e9b\u6d41\u7c7b\u6d3e\u751f\u81ea istream \uff0c ostream \u548c iostream \uff08\u5206\u522b\u7684\uff09\u5e26\u6709\u4e00\u4e2a \u8d4b\u503c\u64cd\u4f5c\u7b26\u5b9a\u4e49\uff0c\u5141\u8bb8\u4f60\u8d4b\u503c\u4e00\u4e2a\u6d41\u7ed9\u53e6\u4e00\u4e2a\u3002\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u4f60\u4e0d\u4f1a\u76f4\u63a5\u64cd\u4f5c\u8fd9\u4e9b\u7c7b\u3002","title":"iostream \u7c7b\u53ef\u4ee5\u540c\u5c5e\u5904\u7406\u8f93\u5165\u548c\u8f93\u51fa\uff0c\u5141\u8bb8\u53cc\u5411I/O"},{"location":"18-input-and-output/18.1-input-and-output-streams/#c_1","text":"A standard stream is a pre-connected stream provided to a computer program by its environment. C++ comes with four predefined standard stream objects that have already been set up for your use. The first three, you have seen before: \u4e00\u4e2a\u6807\u51c6\u6d41\u662f\uff0c\u63d0\u4f9b\u7ed9\u4e00\u4e2a\u7535\u8111\u7a0b\u5e8f\u7684\u4e00\u4e2a\u9884\u94fe\u63a5\u7684\u6d41\uff08A standard stream is a pre-connected stream provided to a computer program by its environment.\uff09\u3002C++ \u9644\u5e26\u4e864\u4e2a\u9884\u5b9a\u4e49\u7684\u6807\u51c6\u6d41\uff0c\u88ab\u5b9a\u4e49\u6765\u63d0\u4f9b\u7ed9\u4f60\u4f7f\u7528\u7684\uff0c\u4f60\u4e4b\u524d\u770b\u5230\u8fc7\u7684\uff1a cin \u2014\u2014 \u4e00\u4e2a istream_withassign \u7c7b\uff0c\u8fde\u63a5\u5230\u6807\u51c6\u8f93\u5165\uff08\u901a\u5e38\u662f\u952e\u76d8\uff09 cout \u2014\u2014 \u4e00\u4e2a ostream_withassign \u7c7b\uff0c\u8fde\u63a5\u5230\u6807\u6ce8\u8f93\u51fa\uff08\u901a\u5e38\u662f\u663e\u793a\u5668\uff09 cerr \u2014\u2014 \u4e00\u4e2a ostream_withassign \u7c7b\uff0c\u8fde\u63a5\u5230\u6807\u51c6\u9519\u8bef\uff08\u901a\u5e38\u662f\u663e\u793a\u5668\uff09\uff0c\u63d0\u4f9b\u65e0buffer\u7684\u8f93\u51fa clog \u2014\u2014 \u4e00\u4e2a ostream_withassign \u7c7b\uff0c\u8fde\u63a5\u5230\u6807\u51c6\u9519\u8bef\uff08\u901a\u5e38\u662f\u663e\u793a\u5668\uff09\uff0c\u63d0\u4f9b\u6709buffer\u7684\u8f93\u51fa \u65e0 buffer \u70b9\u7684\u8f93\u51fa\u901a\u5e38\u88ab\u7acb\u523b\u6267\u884c\uff0c\u800c\u5e26buffer\u7684\u8f93\u51fa\u901a\u5e38\u88ab\u50a8\u5b58\u5e76\u4e14\u4ee5\u5757\u4e3a\u5355\u4f4d\u5199\u51fa\u3002\u56e0\u4e3a clog \u4e0d\u662f\u5f88\u5e38\u7528\uff0c\u5b83\u901a\u5e38\u4e5f\u88ab\u6807\u51c6\u6d41\u5217\u8868\u4e2d\u5ffd\u7565\u3002 \u5728\u63a5\u4e0b\u6765\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u770b\u66f4\u591a\u7684 I/O \u76f8\u5173\u7684\u8be6\u7ec6\u529f\u80fd","title":"C++ \u4e2d\u7684\u6807\u51c6\u6d41"}]}